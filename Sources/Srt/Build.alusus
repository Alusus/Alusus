import "Core";
import "Spp";
import "Srl/Console";
import "Srl/String";
import "Srl/System";
import "Srl/Memory";
import "Srl/Array";

if Srl.String.compare(Process.language, "ar") == 0 {
  Core.importFile("Build/I18n/ar.alusus");
} else {
  Core.importFile("Build/I18n/en.alusus");
};

@merge module Build
{
    use Core.Basic;
    use Srl;

    type Unit {
        def element: ref[TiObject];
        def outputFilename: CharsPtr;
        def deps: Array[String];

        handler this~init() {}

        handler this~init(e: ref[TiObject], fn: CharsPtr) {
            this.element~no_deref = e;
            this.outputFilename = fn;
            this.addDependency(e);
        }

        function addDependency (d: String) {
            this.deps.add(d);
        }

        function addDependency (e: ref[TiObject]) => Bool {
            if !this.addDependenciesFromModifier(e, "deps") return false;
            if !this.addDependenciesFromModifier(e, "اعتماديات") return false;
            return true;
        }

        function addDependenciesFromModifier (e: ref[TiObject], modifierKwd: ptr[array[Char]]) => Bool {
            def modifier: ref[TiObject](Spp.astMgr.findModifierForElement(e, modifierKwd));
            if modifier~ptr != 0 {
                def deps: Array[String];
                if !Spp.astMgr.getModifierStringParams(modifier, deps) return false;
                def i: Word;
                for i = 0, i < deps.getLength(), ++i this.addDependency(deps(i));
            }
            return true;
        }
    }

    type Exe {
        @injection def unit: Unit;

        handler this~init(e: ref[TiObject], fn: CharsPtr) {
            this.unit~init(e, fn);
        }

        function getDepsString (): String {
            def depsString: String("");
            def i: Word;
            for i = 0, i < this.deps.getLength(), ++i {
                depsString += " -l:";
                depsString += this.deps(i);
            }
            return depsString;
        }

        function generate () => Bool {
            if !Spp.buildMgr.buildObjectFileForElement(this.element, "/tmp/output.o", 0) {
                Console.print(I18n.objectGenerationError, Console.Style.FG_RED, this.outputFilename);
                return false;
            }
            def cmd: array[Char, 600];
            String.assign(cmd~ptr, "gcc -no-pie /tmp/output.o -o %s %s", this.outputFilename, this.getDepsString().buf);
            if System.exec(cmd~ptr) != 0 {
                Console.print(I18n.exeGenerationError, Console.Style.FG_RED, this.outputFilename);
                return false;
            }
            return true;
        }
    }

    type Wasm {
        @injection def unit: Unit;

        handler this~init(e: ref[TiObject], fn: CharsPtr) {
            this.unit~init(e, fn);
        }

        function getDepsString (): String {
            def depsString: String("");
            def i: Word;
            for i = 0, i < this.deps.getLength(), ++i {
                depsString += " ";
                depsString += this.deps(i);
            }
            return depsString;
        }

        function generate () => Bool {
            if !Spp.buildMgr.buildObjectFileForElement(this.element, "/tmp/output.o", "wasm32-unknown-unknown") {
                Console.print(I18n.objectGenerationError, Console.Style.FG_RED, this.outputFilename);
                return false;
            }
            def cmd: array[Char, 600];
            String.assign(
                cmd~ptr, "wasm-ld-10 --no-entry --allow-undefined --export-all %s /tmp/output.o -o %s ",
                this.getDepsString().buf, this.outputFilename
            );
            if System.exec(cmd~ptr) != 0 {
                Console.print(I18n.exeGenerationError, Console.Style.FG_RED, this.outputFilename);
                return false;
            }
            return true;
        }
    }

    function genExecutable (element: ref[TiObject], outputFilename: CharsPtr) => Bool
    {
        def exe: Exe(element, outputFilename);
        return exe.generate();
    }

    function genWasm (element: ref[TiObject], outputFilename: CharsPtr) => Bool
    {
        def wasm: Wasm(element, outputFilename);
        return wasm.generate();
    }
}

import "globals.alusus";
import "Srl/Memory.alusus";

@merge module Srl {
  module String {
    
    @expname[strchr]
    func findChar(s: ptr[Char], c: Int): ptr[Char];
    
    @expname[memchr]
    func findChar(s: ptr[Void], c: Int, n: Int[64]): ptr[Void];
    
    @expname[strrchr]
    func findLastChar(s: ptr[Char], c: Int): ptr[Char];
    
    @expname[strstr]
    func findString(haystack: ptr[Char], needle: ptr[Char]): ptr[Char];
    
    @expname[strcmp]
    func compare(s1: ptr[Char], s2: ptr[Char]): Int;
    
    @expname[strncmp]
    func compare(s1: ptr[Char], s2: ptr[Char], n: Int[64]): Int;

    func equal(s1: ptr[Char], s2: ptr[Char]): bool {
      if compare(s1, s2) == 0 {
        return 1;
      } else {
        return 0
      };
    };
    
    @expname[strcpy]
    func copy(dest: ptr[Char], src: ptr[Char]): ptr[Void];
    
    @expname[strncpy]
    func copy(dest: ptr[Char], src: ptr[Char], n: Int[64]): ptr[Void];
    
    @expname[strcat]
    func concat(dest: ptr[Char], src: ptr[Char]): ptr[Char];
    
    @expname[strncat]
    func concat(dest: ptr[Char], src: ptr[Char], n: Int[64]): ptr[Char];
    
    @expname[strlen]
    func getLength(s: ptr[Char]): Int[64];
    
    @expname[sprintf]
    func assign(target: ptr[Char], format: ptr[Word[8]], args: ...any): Int[32];
    
    @expname[sscanf]
    func scan(target: ptr[Char], format: ptr[Word[8]], args: ...any): Int[32];

    def _maxChars: alias array[Char, 10240];

    type RegexMatches {
      def count: Int;
      def matches: array[_maxChars];
    };

    type regex_t {
      def buffer: ptr[Char];
      def allocated: Word[64];
      def used: Word[64];
      def syntax: Word[64];
      def fastmap: ptr[Char];
      def translate: ptr[Char];
      def re_nsub: Int;
      def flags: Word[8];
    };

    type regmatch_t {
        def rm_so: int;  // Byte offset from string's start to substring's start.
        def rm_eo: int;  // Byte offset from string's start to substring's end.
    };

    @expname[regcomp]
    func regcomp(preg: ptr[regex_t], pattern: ptr[array[Char]], cflags: Int): Int[32];
    
    @expname[regexec]
    func regexec(preg: ptr[regex_t], pattern: ptr[array[Char]], size: Int, match: ptr[array[regmatch_t]], cflags: Int): Int[32];
    
    @expname[regfree]
    func regfree(preg: ptr[regex_t]);

    def _results: array[_maxChars, 100];
    def _regmatch: array[regmatch_t, 255];
    func regex(pattern: ptr[array[Char]], string: ptr[array[Char]], mode: Int): ptr[RegexMatches] {
      def i: Int;
      def len: int;
      def reg: regex_t;

      regcomp(reg~ptr, pattern, 1);
      if regexec(reg~ptr, string, _regmatch~size / regmatch_t~size, _regmatch~ptr, 1) == 0 {
        for i = 0, _regmatch(i).rm_so != -1, i++ {
          len = _regmatch(i).rm_eo - _regmatch(i).rm_so;
          Memory.copy(_results(i)~ptr, string~cnt(_regmatch(i).rm_so)~ptr, len);
          _results(i)(len) = 0;
        };
      } else {
        i = 0;
      };

      def matches: ptr[RegexMatches];
      matches = Memory.alloc(Int~size + (_maxChars~size * i))~cast[ptr[RegexMatches]];
      matches~cnt.count = i;
      Memory.copy(matches~cnt.matches~ptr, _results~ptr, i * _maxChars~size);

      regfree(reg~ptr);

      return matches;
    };
  };
};

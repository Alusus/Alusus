import "Srl/refs_base";
import "Core/Basic";
import "Core/Data";
import "Spp/Ast";

// Pre-generate shared refs to avoid circular dependency.
if 1 {
    Srl.SrdRef[Core.Basic.TiObject]();
    Srl.SrdRef[Core.Data.Ast.MergeList]();
    Srl.SrdRef[Core.Data.Ast.LinkOperator]();
    Srl.SrdRef[Core.Data.Ast.List]();
    Srl.SrdRef[Core.Data.Ast.Identifier]();
    Srl.SrdRef[Spp.Ast.Variable]();
}

@merge module Srl {
    @merge class SrdRef {
        preprocess { generateSmartRefAutoImplicitCasts(this_type~ast, T~ast, ast SrdRef) }
    }

    @merge class WkRef {
        preprocess { generateSmartRefAutoImplicitCasts(this_type~ast, T~ast, ast WkRef) }
    }

    func generateSmartRefAutoImplicitCasts(
        originalTp: ref[Core.Basic.TiObject], tp: ref[Core.Basic.TiObject], className: ref[Core.Basic.TiObject]
    ) {
        if not Core.Basic.isDerivedFrom[tp, Spp.Ast.UserType] return;
        def elements: Array[ref[Core.Basic.TiObject]] = Spp.astMgr.findElements(
            (ast elementType == "var"),
            tp,
            Spp.SeekerFlags.SKIP_OWNERS | Spp.SeekerFlags.SKIP_USES | Spp.SeekerFlags.SKIP_CHILDREN
        );
        if elements.getLength() == 0 return;

        if not Spp.astMgr.isInjection(elements(0)) return;

        def varType: ref[Spp.Ast.Type](Spp.astMgr.traceType(elements(0)));
        if varType~ptr == originalTp~ptr return;

        Spp.astMgr.insertAst(
            (ast handler this~cast[ClassName[OutType]] {
                return ClassName[OutType](this.refCounter, castRef[this.obj, OutType]);
            }),
            Map[String, ref[Core.Basic.TiObject]]()
                .set(String("ClassName"), className)
                .set(String("OutType"), Spp.Ast.Variable().{
                    Core.Basic.MapContainerOf[this].setElement("type", varType);
                })
        );

        generateSmartRefAutoImplicitCasts(originalTp, varType, className);
    }
}

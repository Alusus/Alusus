<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <title>مرجع الاستخدام | لغة الأسس البرمجية</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="Resources/rtl/bootstrap.min.css">
    <link rel="stylesheet" href="Resources/font-awesome.min.css">
    <link rel="stylesheet" href="Resources/style.css">
    <link rel="stylesheet" href="Resources/highlight.default.css">
    <script src="Resources/jquery.min.js"></script>
    <script src="Resources/popper.min.js"></script>
    <script src="Resources/bootstrap.min.js"></script>
</head>

<body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light fixed-top">
        <div class="container">
            <a class="navbar-brand" href="index.html"><img src="Resources/logo.gif" alt="Alusus Programming Language" class="site-logo"></a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNavDropdown">
              <h3 style="padding-top: 0px; margin-top: 0px;">لغة الأسس - مرجع استخدام اللغة</h3>
            </div>
        </div>
    </nav>
    <div class="container">
        <!--content-separator-->
        <div class="row">
            <div class="col-md-3">
                <div class="card side-sticky">
                    <div class="card-header">مرجع الاستخدام</div>
                    <div class="card-content">
                        <a href="#General" class="top-level">مفاهيم عامة</a><br>
                          <ul class="unstyled-list">
                            <li><a href="#General-definitions">التعريفات</a></li>
                            <li><a href="#General-structure">الهيكل العام للبرنامج</a></li>
                            <li><a href="#General-comments">التعليقات</a></li>
                            <li><a href="#General-modifiers">المبدلات</a></li>
                          </ul>
                        <a href="#BasicTypes" class="top-level">الأصناف الأساسية للمتغيرات</a><br>
                        <a href="#OperatorsAndOperations" class="top-level">التراكيب والمؤثرات</a><br>
                          <ul class="unstyled-list">
                            <li><a href="#OperatorsAndOperations-operators">المؤثرات</a></li>
                            <li><a href="#OperatorsAndOperations-priorities">التحكم بالأسبقية</a></li>
                            <li><a href="#OperatorsAndOperations-literals">الرموز الحرفية</a></li>
                          </ul>
                        <a href="#Commands" class="top-level">أوامر التحكم</a><br>
                          <ul class="unstyled-list">
                            <li><a href="#Commands-conditionals">الجمل الشرطية</a></li>
                            <li><a href="#Commands-loops">الحلقات</a></li>
                            <li><a href="#Commands-continue">الأمر `أكمل` (continue)</a></li>
                            <li><a href="#Commands-break">الأمر `اقطع` (break)</a></li>
                          </ul>
                        <a href="#Functions" class="top-level">الدالّات</a><br>
                          <ul class="unstyled-list">
                            <li><a href="#Functions-variadic">المعطيات المرنة</a></li>
                            <li><a href="#Functions-anonymous">الدالات الضمنية</a></li>
                          </ul>
                        <a href="#Types" class="top-level">أصناف المستخدم</a><br>
                          <ul class="unstyled-list">
                            <li><a href="#Types-templates">قوالب الأصناف</a></li>
                            <li><a href="#Types-methods">الوظائف (methods)</a></li>
                            <li><a href="#Types-props">الخصال (properties)</a></li>
                            <li><a href="#Types-sharedmembers">العناصر المشتركة</a></li>
                            <li><a href="#Types-methodptrs">مؤشرات الوظائف</a></li>
                            <li><a href="#Types-custominit">تخصيص تهيئة الكائنات</a></li>
                            <li><a href="#Types-customterminate">تخصيص إتلاف الكائنات</a></li>
                            <li><a href="#Types-initorder">تسلسل تهيئة الكائنات</a></li>
                            <li><a href="#Types-customops">تخصيص المؤثرات</a></li>
                            <li><a href="#Types-tempvarinitcustomization">تخصيص إنشاء المتغيرات المؤقتة</a></li>
                            <li><a href="#Types-injection">حقن التعريفات</a></li>
                          </ul>
                        <a href="#TypeInference" class="top-level">استنباط الأصناف</a><br>
                          <ul class="unstyled-list">
                            <li><a href="#TypeInference-typeop">مؤثر ~صنف (~type)</a></li>
                            <li><a href="#TypeInference-sizeop">مؤثر ~حجم (~size)</a></li>
                          </ul>
                        <a href="#Pointers" class="top-level">المؤشرات</a><br>
                        <a href="#References" class="top-level">السندات</a><br>
                          <ul class="unstyled-list">
                            <li><a href="#References-tempref">السندات المؤقتة</a></li>
                            <li><a href="#References-noderef">مؤثر ~عطل_التتبع (~no_deref)</a></li>
                          </ul>
                        <a href="#Arrays" class="top-level">المصفوفات</a><br>
                        <a href="#Casting" class="top-level">تمثيل الأصناف</a><br>
                        <a href="#TempObjects" class="top-level">الكائنات المؤقتة</a><br>
                        <a href="#CommandPacks" class="top-level">رزم الأوامر</a><br>
                          <ul class="unstyled-list">
                            <li><a href="#CommandPacks-usein">مؤثر ~استخدم_في (~use_in)</a></li>
                          </ul>
                        <a href="#DynamicInit" class="top-level">حجز وتهيئة الكائنات ديناميكيا</a><br>
                        <a href="#Alias" class="top-level">الألقاب</a><br>
                        <a href="#Modules" class="top-level">الوحدات</a><br>
                        <a href="#Macros" class="top-level">الماكروهات</a><br>
                          <ul class="unstyled-list">
                            <li><a href="#Macros-strtemplates">القوالب في المعرفات وسلاسل المحارف</a></li>
                            <li><a href="#Macros-cmacrocomparison">مقارنة مع ماكرو لغة السي</a></li>
                          </ul>
                        <a href="#Ast" class="top-level">شجرة البنية المجردة (AST)</a><br>
                        <a href="#Preprocess" class="top-level">المعالجة التمهيدية</a><br>
                        <a href="#Merge" class="top-level">دمج التعريفات</a><br>
                        <a href="#Import" class="top-level">شمل مكتبات أو ملفات مصدرية</a><br>
                        <a href="#Process" class="top-level">الوحدة: الـعملية (Process)</a><br>
                    </div>
                </div>
            </div>
            <div class="col-md-9">
                <p>
                    يضم هذا المرجع تعليمات البرمجة الإجرائية باستخدام مكتبة نمط البرمجة المعياري (Standard Programming Paradigm).
                </p>

                <!-- ********************************************************************** -->
                <h3 id="General">مفاهيم عامة</h3>
                <hr>
                <div>
                    <h4>المعرّفات (identifiers)</h4>
                    المعرّفات تستخدم للإشارة إلى دالة أو متغير أو صنف وتبدأ بحرف هجائي عربي أو انجليزي أو بالرمز _. يمكن للمعرفات أن تحتوي أيضاً على الأرقام 0-9 وعلى الحركات والشدّة أيضاً.

                    <h4>الفصل بين الجمل</h4>
                    تستخدم الفاصلة المنقوطة للفصل بين الجمل بطريقة مشابهة للفاصلة الإعتيادية التي تفصل بين الحدود داخل القوائم. بمعنى آخر فإن الفاصلة المنقوطة ليست جزءاً من الجملة ويُمكن إهمالها إن لم يأت بعدها جملة أخرى.

                    <h4>الأقواس الهلالية والأقواس المعقوفة</h4>
                    تستخدم الأقواس الهلالية في الأمور التي تُعالج أثناء تنفيذ البرنامج مثل جمع الحدود داخل التراكيب أو إرسال المدخلات إلى الدالّات، بينما تستخدم الأقواس المعقوفة في الأمور التي تُعالج أثناء الترجمة مثل تحديد نوع المؤشر أو المصفوفة. بمعنى آخر، إن كانت المعلومة
                    مرسلةً إلى المترجم نفسه تُسخدم الأقواس المعقوفة، وإلا فالأقواس الهلالية.

                    <h4>الأقواس الحاصرة</h4>
                    تستخدم الأقواس الحاصرة لحصر مجموعة من الجمل في كتلة واحدة. وتستخدم هذه الكتل في جواب الجمل الشرطية ومتون الحلقات والهياكل والدالات والوحدات.

                    <h4 id="General-definitions">التعريفات</h4>
                    كل التعريفات تتم باستخدام الأمر "عرّف" (def) ويأخذ الصيغة التالية:
                    <pre dir=rtl class="code" style="text-align:right;">
  عرّف &lt;معرِّف&gt; : &lt;تعريف&gt;</pre>
                    <pre dir=ltr class="code">
  def &lt;identifier&gt; : &lt;definition&gt;</pre> التعريف يمكن أن يكون اسم أحد الأصناف وينتج عن التعريف متغير من ذلك الصنف، أو يكون أحد الأوامر التعريفية الأخرى مثل الدالات والهياكل. المثال التالي يعرّف متغيراً من صنف الأعداد الصحيحة:
                    <pre dir=rtl class="samplecode" style="text-align:right;">
  عرّف م : العدد_الصحيح</pre>
                    <pre dir=ltr class="samplecode">
  def i : Int</pre> يمكن أيضاً تعريف الثوابت بنفس الطريقة وذلك بوضع القيمة نفسها بدل الصنف ويمكن هذا مع الأعداد الصحيحة والعائمة بالإضافة إلى سلاسل المحارف، كما في المثال التالي:
                    <pre dir=rtl class="samplecode" style="text-align:right;">
  عرّف البسملة: "بسم الله الرحمن الرحيم"؛
  عرف النسبة_الثابتة: 3.141592؛
  عرف عدد_أيام_الاسبوع: 7؛</pre>
                    <pre dir=ltr class="samplecode">
  def hello: "Hello World";
  def pi: 3.141592;
  def daysPerWeek: 7;</pre>

                    <br/>
                    <h4 id="General-structure">الهيكل العام للبرنامج</h4>
                    كل برنامج بلغة الأسُس يجب أن يشمل المكتبة "libalusus_spp.so" إما بشكل مباشر أو بشكل غير مباشر وذلك لأن هذه المكتبة هي التي تحتوي على تعريفات الأوامر الأساسية المتعلقة بالبرمجة الإجرائية. لذلك يبدأ كل برنامج بالأمر "اشمل" أو "import".
                    <pre class="code" dir=ltr>
  import "libalusus_spp.so";</pre> غالباً لن تحتاج لشمل مكتبة البناء المعيارية مباشرة، وإنما تشمل ملفات تعريفية أخرى تقوم بدورها بشمل مكتبة البناء المعيارية. على سبيل المثال:
                    <pre class="code" dir=ltr>
  import "Srl/Console.alusus";</pre> أو:
                    <pre class="code" dir=rtl style="text-align:right;">
  اشمل "مـتم/طـرفية.أسس"؛</pre> يحتوي كل برنامج على تعريف لوحدة وهذه الوحدة هي التي تحتوي على تعريفات البرنامج.
                    <pre dir=ltr class="samplecode">
  def HelloWorld : module
  {
    ...
  }</pre>
                    <pre dir=rtl class="samplecode" style="text-align:right;">
  عرّف الـبسملة : وحدة
  {
    ...
  }</pre> بعد ذلك يجب أن يضم البرنامج الأمر نفّذ (run) لتنفيذ البرنامج. السبب في ذلك يكمن في قدرة المبرمج على الاختيار بين التنفيذ المباشر (JIT compilation) أو التحويل إلى ملف تشغيلي (عبر الأمر build). خاصية التحويل إلى ملف تنفيذي
                    ليست مكتملة بعد وسيتم إكمالها في إصدار آخر. الأمر "نفّذ" يكتب بالشكل التالي:
                    <pre dir=rtl class="code" style="text-align:right;">
  نفّذ &lt;اسم_وحدة&gt.&lt;اسم_الدالة&gt؛</pre>
                    <pre dir=ltr class="code">
  run &lt;module_name&gt;.&lt;function_name&gt;</pre>

                    <h4 id="General-comments">التعليقات</h4>
                    التعليقات في لغة الأسُس تبدأ بالرمز // وتنتهي عند نهاية السطر، أي أنها مشابهة للتعليقات مفردة السطر (single line comment) في لغة سي++ أو جافا.

                <h4 id="General-modifiers">المبدلات</h4>
                يمكن وسم عناصر الشفرة المصدرية بمبدلات تستخدم لاحقا في مجالات مختلفة. المبدل يمكن أن يغير طريقة ترجمة وتنفيذ الشفرة الموسومة ويمكن أن لا يفعل سوى إضافة بيانات وصفية. المبدل له النسق التالي:
<pre class="code" dir=rtl style="text-align:right;">
  @&lt;كلمة_تعريفية&gt; &lt;تعريف_العنصر_المراد_وسمه&gt;
  @&lt;كلمة_تعريفية&gt;[&lt;معطيات&gt;] &lt;تعريف_العنصر_المراد_وسمه&gt;
</pre>
<pre class="code" dir=ltr>
  @&lt;keyword&gt; &lt;def_of_element_to_be_tagged&gt;
  @&lt;keyword&gt;[&lt;arguments&gt;] &lt;def_of_element_to_be_tagged&gt;
</pre>
                يعتمد المترجم على مبدلات معرفة مسبقا لإضافة خواص معينة على التعريفات المختلفة كما هو موضح في مواضع عدة من هذه الوثيقة. وبإمكان المستخدم إضافة مبدلات خاصة وقراءتها لاحقا باستخدام دالة `نـبم.هات_محارف_مبدل`.
<pre class="samplecode" dir=rtl style="text-align:right;">
  @مبدلي["معطى1"، "معطى2"] دالة دالتي { ... }؛
</pre>
<pre class="samplecode" dir=ltr>
  @mymodifier["arg1", "arg2"] func myFunc { ... };
</pre>
                </div>

                <!-- ********************************************************************** -->
                <h3 id="BasicTypes">الأصناف الأساسية للمتغيرات</h3>
                <hr>
                <div>
                    <ul>
                        <li><b>صـحيح (Int)</b><br/> عدد صحيح. يتم تحديد عدد البتات بين أقواس معقوفة. تحديد عدد البتات اختياري وبدونه يكون العدد الافتراضي للبتات 32.
                            <pre dir=rtl class="code" style="text-align:right;">
صـحيح // 32 بتة
صـحيح[1]
صـحيح[8]
صـحيح[16]
صـحيح[32]
صـحيح[64]</pre>
                            <pre dir=ltr class="code">
Int // 32 bits
Int[1]
Int[8]
Int[16]
Int[32]
Int[64]</pre>
                        </li>
                        <br/>

                        <li><b>صـحيح_متكيف (ArchInt)</b><br/> عدد صحيح بعدد بتات مطابقة لمعمارية النظام، أي بحجم 32 بت على أنظمة 32 بت وبحجم 64 بت على أنظمة 64 بت.
                        </li>
                        <br/>

                        <li><b>طـبيعي (Word)</b><br/> عدد صحيح موجب. يتم تحديد عدد البتات بين أقواس معقوفة. تحديد عدد البتات اختياري وبدونه يكون العدد الافتراضي للبتات 32.
                            <pre dir=rtl class="code" style="text-align:right;">
طـبيعي // 32 بتة
طـبيعي[1]
طـبيعي[8]
طـبيعي[16]
طـبيعي[32]
طـبيعي[64]</pre>
                            <pre dir=ltr class="code">
Word // 32 bits
Word[1]
Word[8]
Word[16]
Word[32]
Word[64]</pre>
                        </li>
                        <br/>

                        <li><b>طـبيعي_متكيف (ArchWord)</b><br/> عدد صحيح موجب بعدد بتات مطابقة لمعمارية النظام، أي بحجم 32 بت على أنظمة 32 بت وبحجم 64 بت على أنظمة 64 بت.
                        </li>
                        <br/>

                        <li><b>عـائم (Float)</b><br/> عدد عائم. يتم تحديد عدد البتات بين أقواس معقوفة. تحديد عدد البتات اختياري وبدونه يكون العدد الافتراضي للبتات 32.
                            <pre dir=rtl class="code" style="text-align:right;">
عـائم // 32 بتة
عـائم[32]
عـائم[64]</pre>
                            <pre dir=ltr class="code">
Float // 32 bits
Float[32]
Float[64]</pre>
                        </li>
                        <br/>

                        <li><b>مـحرف (Char)</b><br/> محرف، وهو مجرد لقب للصنف `طـبيعي[8]`.
                        </li>
                        <br/>

                        <li><b>ثـنائي (Bool)</b><br/> قيمية ثنائية، وهو مجرب لقب للصنف `طـبيعي[1]`.
                        </li>
                        <br/>

                        <li><b>مصفوفة (array)</b><br/> مصفوفة من المتغيرات. تُعرف بتحديد صنف المتغيرات وعدد الخانات بين أقواس معقوفة كما يلي:
                            <pre dir=rtl class="code" style="text-align:right;">
مصفوفة[الصنف، عدد_الخانات]</pre>
                            <pre dir=ltr class="code">
array[the_type, element_count]</pre>
                        </li>
                        <br/>

                        <li><b>مؤشر (ptr)</b><br/> مؤشر إلى متغير. صنف المتغير يحدد بين أقواس معقوفة، كما يلي:
                            <pre dir=rtl class="code" style="text-align:right;">
مؤشر[الصنف]</pre>
                            <pre dir=ltr class="code">
ptr[the_type]</pre>
                        </li>
                        <br/>

                    </ul>
                </div>

                <!-- ********************************************************************** -->
                <h3 id="OperatorsAndOperations">التراكيب والمؤثرات</h3>
                <hr>
                <div>
                    <h4 id="OperatorsAndOperations-operators">المؤثرات</h4>
                    فيما يلي قائمة المؤثرات مرتبة تصاعدياً حسب الأسبقية، أي أن العناصر الأولى بأسبقية أقل:<br/>
                    <b>ملاحظة: </b> بعض هذه المؤثرات غير مدعومة بعد وسيتم دعمها في إصدار لاحق.
                    <ul>
                        <li><b>مؤثرات التعيين</b><br/>
                            <table class="dict">
                                <tr>
                                    <td dir=ltr>=</td>
                                    <td>تحديد قيمة جديدة</tr>
                                <tr>
                                    <td dir=ltr>+=</td>
                                    <td>إضافة قيمة للقيمة الحالية</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>-=</td>
                                    <td>طرح قيمة من القيمة الحالية</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>*=</td>
                                    <td>ضرب القيمة الحالية بقيمة أخرى</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>/=</td>
                                    <td>تقسيم القيمة الحالية على قيمة أخرى</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>%=</td>
                                    <td>تقسيم القيمة الحالية على قيمة أخرى والاحتفاظ بالباقي بدل نتيجة القسمة</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>&=</td>
                                    <td>تطبيق عملية 'و' المنطقية على القيمة الحالية</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>|=</td>
                                    <td>تطبيق عملية 'أو' المنطقية على القيمة الحالية</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>$=</td>
                                    <td>تطبيق عملية xor المنطقية على القيمة الحالية</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>&lt;&lt;=</td>
                                    <td>تزحيف جميع البتّات يساراً مراتباَ بتعداد القيمة المعطاة</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>=&gt;&gt;</td>
                                    <td>تزحيف جميع البتّات يميناً مراتباً بتعداد القيمة المعطاة</td>
                                </tr>
                            </table>
                        </li>
                        <li><b>مؤثرات العمليات المنطقية</b><br/>
                            <table class="dict">
                                <tr>
                                    <td dir=ltr>و</td>
                                    <td>عملية `و` المنطقية، ويمكن كتابتها and ايضاً</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>أو</td>
                                    <td>عملية `أو` المنطقية، ويمكن كتابتها or أيضاً</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>||</td>
                                    <td>صيغة رمزية ل or</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>&&</td>
                                    <td>صيغة رمزية ل and</td>
                                </tr>
                            </table>
                        </li>
                        <li><b>مؤثرات المقارنة</b><br/>
                            <table class="dict">
                                <tr>
                                    <td dir=ltr>==</td>
                                    <td>فحص مساواة</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>!=</td>
                                    <td>فحص عدم المساواة</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>&lt;</td>
                                    <td>فحص أصغر</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>&gt;</td>
                                    <td>فحص أكبر</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>&lt;=</td>
                                    <td>فحص أصغر أو يساوي</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>&gt;=</td>
                                    <td>فحص أكبر أو يساوي</td>
                                </tr>
                            </table>
                        </li>
                        <li><b>مؤثرات الجمع والطرح</b><br/>
                            <table class="dict">
                                <tr>
                                    <td dir=ltr>+</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>-</td>
                                </tr>
                            </table>
                        </li>
                        <li><b>مؤثرات الضرب والقسمة</b><br/>
                            <table class="dict">
                                <tr>
                                    <td dir=ltr>*</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>/</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>%</td>
                                    <td>تحصيل باقي القسمة</td>
                                </tr>
                            </table>
                        </li>
                        <li><b>مؤثرات العمليات البتّية</b><br/> هذه المؤثرات لتطبيق عمليات منطقية على مستوى البتّات، أي تطبيق العمليات على كل بت وما يقابله، بالإضافة إلى عمليات تزحيف البتّات.
                            <table class="dict">
                                <tr>
                                    <td dir=ltr>|</td>
                                    <td>عملية 'أو'</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>$</td>
                                    <td>عملية xor</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>&</td>
                                    <td>عملية 'و'</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>&lt;&lt;</td>
                                    <td>تزحيف البتّات يميناً مراتباً بتعداد القيمة المعطاة</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>&gt;&gt;</td>
                                    <td>تزحيف البتّات يساراً مراتباً بتعداد القيمة المعطاة</td>
                                </tr>
                            </table>
                        </li>
                        <li><b>المؤثرات الأحادية السابقة</b>
                            <table class="dict">
                                <tr>
                                    <td>++</td>
                                    <td>زيادة بواحد</td>
                                </tr>
                                <tr>
                                    <td>--</td>
                                    <td>إنقاص بواحد</td>
                                </tr>
                                <tr>
                                    <td>+</td>
                                    <td>إشارة الرقم الموجب</td>
                                </tr>
                                <tr>
                                    <td>-</td>
                                    <td>إشارة الرقم السالب</td>
                                </tr>
                                <tr>
                                    <td>!</td>
                                    <td>علامة النفي البتّية (عكس قيمة البتّات)</td>
                                </tr>
                                <tr>
                                    <td>!!</td>
                                    <td>علامة النفي المنطقية</td>
                                </tr>
                            </table>
                        </li>
                        <li><b>المؤثرات الأحادية اللاحقة</b>
                            <table class="dict">
                                <tr>
                                    <td>++</td>
                                    <td>زيادة بواحد</td>
                                </tr>
                                <tr>
                                    <td>--</td>
                                    <td>إنقاص بواحد</td>
                                </tr>
                            </table>
                        </li>
                        <li><b>مؤثرات أخرى</b>
                            <table class="dict">
                                <tr>
                                    <td>.</td>
                                    <td>الولوج إلى أحد أعضاء عنصر</td>
                                </tr>
                                <tr>
                                    <td>.{}</td>
                                    <td>رزمة الأوامر</td>
                                </tr>
                            </table>
                        </li>
                    </ul>

                    <h4 id="OperatorsAndOperations-priorities">التحكم بالأسبقية</h4>
                    تستخدم الأقواس الهلالية للتحكم بالأسبقية في التراكيب. على سبيل المثال التركيب التالي ينفذ عملية الضرب قبل الجمع:
                    <pre class="samplecode" style="text-align:right;">
  س = ص + ع * م</pre> بينما التركيب التالي ينفذ الجمع قبل الضرب:
                    <pre class="samplecode" style="text-align:right;">
  س = (ص + ع) * م</pre>

                    <h4 id="OperatorsAndOperations-literals">الرموز الحرفية</h4>
                    بالإضافة للمتغيرات، بالإمكان استخدام الرموز الحرفي في التراكيب. وهذه قائمة الرموز الحرفية المدعومة في لغة الأسُس:
                    <ul>
                        <li><b>الأعداد الصحيحة</b><br/> تكتب كعدد عشري وتُمثل ب32 بت. مثلا: 132
                        </li>
                        <li><b>أعداد الفاصلة العائمة</b><br/> تكتب كعدد حقيقي وتُمثل ب32 بت. مثلا: 1.32
                        </li>
                        <li><b>سلاسل المحارف</b><br/> سلاسل المحارف تُحصر بعلامتي اقتباس، كما في المثال التالي:
                            <pre class="samplecode" style="text-align:right;">
  "بسم الله الرحمن الرحيم"</pre> يمكن كتابة الرموز الخاصة باستخدام علامة \ وفيما يلي قائمة الرموز الخاصة:
                            <table class="dict">
                                <tr>
                                    <td dir=ltr>\n</td>
                                    <td>\ج</td>
                                    <td>بداية سطر جديد</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>\r</td>
                                    <td>\ر</td>
                                    <td>رجوع إلى بداية السطر</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>\t</td>
                                    <td>\ت</td>
                                    <td>إدراج علامة تاب (tab)</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>\"</td>
                                    <td></td>
                                    <td>إدراج علامة اقتباس</td>
                                </tr>
                                <tr>
                                    <td dir=ltr>\\</td>
                                    <td></td>
                                    <td>إدراج علامة \</td>
                                </tr>
                            </table>
                        </li>
                    </ul>
                </div>

                <!-- ********************************************************************** -->
                <h3 id="Commands">أوامر التحكم</h3>
                <hr>
                <div>
                    <h4 id="Commands-conditionals">الجمل الشرطية</h4>
                    تكتب الجمل الشرطية بالصيغة التالية:
                    <pre class="code" dir=rtl style="text-align:right;">
  إذا &lt;تركيب شرطي&gt; &lt;جملة&gt;
  إذا &lt;تركيب شرطي&gt; { &lt;مجموعة جمل&gt; }
  إذا &lt;تركيب شرطي&gt; &lt;جملة_أو_كتلة&gt; وإلا &lt;جملة_أو_كتلة&gt;</pre>
                    <pre class="code" dir=ltr>
  if &lt;condition expression&gt; &lt;statement&gt;
  if &lt;condition expression&gt; { &lt;group of statements&gt; }
  if &lt;condition expression&gt; &lt;statement_or_block&gt; else &lt;statement_or_block&gt;</pre> ليس مشروطاً حصر تركيب الشرط بأقواس هلالية لكن ذلك متاح.

                    <h4 id="Commands-loops">الحلقات</h4>
                    تكتب الحلقات بالصيغ التالية:
                    <pre class="code" dir=rtl style="text-align:right;">
  بينما &lt;تركيب شرطي&gt; &lt;جملة&gt;
  بينما &lt;تركيب شرطي&gt; { &lt;مجموعة جمل&gt; }
  لكل &lt;تهيئة عداد&gt;، &lt;تركيب شرطي&gt;، &lt;تحديث عداد&gt; &lt;جملة&gt;
  لكل &lt;تهيئة عداد&gt;، &lt;تركيب شرطي&gt;، &lt;تحديث عداد&gt; { &lt;مجموعة جمل&gt; }</pre>
                    <pre class="code" dir=ltr>
  while &lt;condition expression&gt; &lt;statement&gt;
  while &lt;condition expression&gt; { &lt;group of statements&gt; }
  for &lt;counter initialization&gt;, &lt;condition expression&gt;, &lt;counter update&gt; &lt;statement&gt;
  for &lt;counter initialization&gt;, &lt;condition expression&gt;, &lt;counter update&gt; { &lt;group of statement&gt; }</pre> مثلما هو الحال مع الجمل الشرطية، ليس مشترطاً حصر التركيب الشرطي في "بينما" أو التراكيب الثلاث المتعلقة
                    بالعداد في "لكل" بأقواس هلالية، لكن ذلك متاح. مثال:
                    <pre class="samplecode" dir=rtl style="text-align:right;">
  بينما ن!=0 ن=قم_بعملية()؛
  بينما ن!=0 { ن = قم_بعملية() }؛
  لكل ع=0، ع<10، ع++ اطبع("%d\ج"، ع)؛
  لكل (ع=0، ع<10، ع++) اطبع("%d\ج"، ع)؛
  لكل ع=0، ع<10، ع++ { اطبع("%d\ج"، ع) }؛</pre>
                    <pre class="samplecode" dir=ltr>
  while r!=0 r=performOperation();
  while r!=0 { r = performOperation() }
  for i=0, i&lt;10, i++ print("%d\n", i);
  for (i=0, i&lt;10, i++) print("%d\n", i);
  for i=0, i&lt;10, i++ { print("%d\n", i) };</pre>

                    <h4 id="Commands-continue">الأمر `أكمل` (continue)</h4>
                    يستخدم لتجاوز ما تبقى من الدورة الحالية للحلقة والبدء بدورة جديدة. يمكن تحديد رقم الحلقة المراد تجاوز دورتها في حالة الحلقات المتداخلة.
                    <pre class="code" dir=rtl style="text-align:right;">
  أكمل؛ // بدء دورة جديدة من الحلقة الحالية.
  أكمل 2؛ // الخروج من الحلقة الحالية وبدء دورة جديدة من الحلقة الخارجية.</pre>
                    <pre class="code" dir=ltr>
  continue;
  continue 2;</pre>

                    <h4 id="Commands-break">الأمر `اقطع` (break)</h4>
                    الخروج من الحلقة. يمكن تحديد رقم الحلقة المراد الخروج منها في حالة الحلقات المتداخلة.
                    <pre class="code" dir=rtl style="text-align:right;">
  اقطع؛ // الخروج من الحلقة الحالية.
  اقطع 2؛ // الخروج من الحلقة الحالية والخارجية</pre>
                    <pre class="code" dir=ltr>
  break;
  break 2;</pre>
                </div>

                <!-- ********************************************************************** -->
                <h3 id="Functions">الدالّات</h3>
                <hr>
                <div>
                    تعرّف الدالات باستخدام الأمر "دالّة" كتعريف في الأمر "عرّف":
                    <pre class="code" dir=rtl style="text-align:right;">
  عرّف &lt;اسم_الدالة&gt; : دالّة (&lt;معطيات&gt;) =&gt; &lt;صنف_النتيجة&gt; { &lt;متن_الدالة&gt; }</pre>
                    <pre class="code" dir=ltr>
  def &lt;func name&gt; : function (&lt;arguments&gt;) =&gt; &lt;return_type&gt; { &lt;function_body&gt; }</pre> وتكون المعطيات بالصيغة التالية:
                    <pre class="code" dir=rtl style="text-align:right;">
  &lt;اسم_المعطى&gt;:&lt;نوع_المعطى&gt;، &lt;اسم_المعطى&gt;:&lt;نوع_المعطى&gt; ...</pre>
                    <pre class="code" dir=ltr>
  &lt;arg_name&gt;:&lt;arg_type&gt;, &lt;arg_name&gt;:&lt;arg_type&gt; ...</pre> كما في المثال التالي:
                    <pre class="samplecode" dir=rtl style="text-align:right;">
  عرف مضروب : دالّة (ع:العدد_الصحيح) => العدد_الصحيح
  {
    إذا ع==1 ارجع 1؛
    ارجع ع * مضروب(ع-1)؛
  }</pre>
                    <pre class="samplecode" dir=ltr>
  def factorial : function (i:Int) => Int
  {
    if i==1 return 1;
    return i*factorial(i-1);
  }</pre> يمكن أيضًا استخدام الصيغة المختصرة دون الحاجة للأمر "عرف" كما يلي:
                    <pre class="code" dir=rtl style="text-align:right;">
  دالة &lt;اسم_الدالة&gt; (&lt;معطيات&gt;) =&gt; &lt;صنف_النتيجة&gt; { &lt;متن_الدالة&gt; }</pre>
                    <pre class="code" dir=ltr>
  function &lt;func name&gt; (&lt;arguments&gt;) =&gt; &lt;return_type&gt; { &lt;function_body&gt; }</pre> كما في المثال التالي:
                    <pre class="samplecode" dir=rtl style="text-align:right;">
  دالة مضروب (ع:العدد_الصحيح) => العدد_الصحيح
  {
    إذا ع==1 أرجع 1؛
    أرجع ع * مضروب(ع-1)؛
  }</pre>
                    <pre class="samplecode" dir=ltr>
  function factorial (i:Int) => Int
  {
    if i==1 return 1;
    return i*factorial(i-1);
  }</pre> استدعاء الدوال يتم باستخدام اسم الدالة يليه قائمة المعطيات بين قوسين هلاليين. إن لم تكن للدالة أي معطيات فيجب إتباع اسمها بقوسين هلاليين فارغين.
                    <pre class="samplecode" dir=rtl style="text-align:right;">
  س = إقرأ_رقماً()؛
  ص = إقرأ_رقماً()؛
  ارسم_نقطة(س، ص)؛</pre>
                    <pre class="samplecode" dir=ltr>
  x = readNumber();
  y = readNumber();
  drawPoint(x, y);</pre>

                  <h4 id="Functions-variadic">المعطيات المرنة</h4>
                  يمكن تعريف دالة بمعطيات مرنة (variadic function) ما يسمح للمستخدم باستدعاء الدالة بعدد غير ثابت من المعطيات. بخلاف لغات أخرى كلمة السي،
                  يمكن في الأسس تحديد صنف هذه المعطيات كما يمكن تحديد عدد أدنى وأعلى من المعطيات. تحديد المعطيات كمعطيات مرنة يتم باستخدام المؤثر ... عند
                  تعريف صنف المعطى. أي أن تسبيق صنف المعطى بـ... يجعل ذلك المعطى مرنا ما يمكن المستخدم من تمرير عدد غير محدد من ذلك الصنف.
<pre class="code" dir=rtl style="text-align:right;">
  &lt;اسم_مجموعة_المعطيات&gt;: ...&lt;صنفها&gt;
  &lt;اسم_مجموعة_المعطيات&gt;: ...[&lt;صنفها&gt;، &lt;العدد_الأدنى&gt;، &lt;العدد_الأعلى&gt;]
</pre>
<pre class="code" dir=ltr>
  &lt;arg_group_name&gt;: ...&lt;args_type&gt;
  &lt;arg_group_name&gt;: ...[&lt;args_type&gt;, &lt;min_count&gt;, &lt;max_count&gt;]
</pre>
                  أمثلة:
<pre class="samplecode" dir=rtl style="text-align:right;">
  // دالة تستقبل عددا غير محدد من العناصر بصنف غير محدد.
  دالة اطبع (بنية: مؤشر[مصفوفة[محرف]]، عناصر: ...أيما) { ... }

  // دالة تستقبل عددا غير محدد من العناصر صنفها عائم.
  دالة اطبع (عدد: صحيح، عناصر: ...عائم) { ... }

  // دالة تستقبل عناصر صنفها عائم يتراوح عددها بين 2 و 5.
  دالة اطبع (عدد: صحيح، عناصر: ...[عائم، 2، 5]) { ... }
</pre>
<pre class="samplecode" dir=ltr>
  // Function receiving unspecified number of args with unspecified type.
  function print (format: ptr[array[char]], ...any) { ... }

  // Function receiving unspecified number of args with type Float.
  function print (count: Int, args: ...Float) { ... }

  // Function receiving Float args counting between 2 and 5.
  function print (count: Int, args: ...[Float, 2, 5]) { ... }
</pre>
<br>
                  <h5>استدعاء دالة مرنة المعطيات</h5>
                  استدعاء دالة مرنة المعطيات يتم بنفس طريقة استدعاء أي دالة أخرى، لكن إذا كانت الدالة تستلم عدد المعطيات متبوعا بالمعطيات
                  المرنة فيمكن استخدام الأقواس المزهرة {} والتي يحولها مترجم الأسس تلقائيا إلى عدد المعطيات متبوعا بتلك المعطيات، كما في المثال:
<pre class="samplecode" dir=rtl style="text-align:right;">
  دالة اطبع (عدد: صحيح، عناصر: ...عائم) { ... }

  اطبع({ 5.5، 3.7، 1.0 })؛
  // الاستدعاء السابق مطابق للاستدعاء التالي، مترجم الأسس يضيف عدد العناصر (3)
  // تلقائيا في بداية الاستدعاء.
  اطبع(3، 5.5، 3.7، 1.0)؛
</pre>
<pre class="samplecode" dir=ltr>
  function print (count: Int, args: ...Float) { ... }

  print({ 5.5, 3.7, 1.0 });
  // The upper call is identical to the one below; Alusus automatically inserts
  // the count (3) before the args.
  print(3, 5.5, 3.7, 1.0);
</pre>
<br>
                  <h5>استخدام المعطيات المرنة داخل الدالة</h5>
                  الوصول إلى المعطيات المرنة يتم عبر المؤثر <b>~المعطى_التالي (~next_arg)</b> على اسم مجموعة المعطيات وإعطائه صنف المعطى.
                  المؤثر يحتاج صنف المعطى لأن التعريف قد لا يحدد صنفا للمعطيات وبالتالي يحتاج المستخدم أن يحدد الصنف بنفسه اعتمادا على معطيات
                  أخرى مثل سلسلة محارف تحدد بنية المعطيات المرنة كما هو الحال مع دالة printf في السي. من المهم الملاحظة أن كل استخدام للمؤثر
                  ~المعطى_التالي يسحب عنصرا من مجموعة المعطيات، أي أن الولوج للمعطيات يتم بشكل تسلسلي ولا يمكن الولوج لنفس العنصر عدة مرات
                  أو الولوج بشكل عشوائي. كما أن تحديد عدد العناصر والوقوف بعد سحب آخر عنصر مسؤولية المبرمج حيث أن الأسس لا تملك طريقة تعرف
                  بها عدد العناصر المتبقية، ولذلك يحتاج المستخدم لاستقبال لإضافة عدد العناصر كمعطى أولي في الدالة كما هو الحال مع الأمثلة
                  أعلاه. المثال التالي لدالة تطبع معطيات صنفها صحيح أو عائم ويتم تحديد عدد وصنف المعطيات في المعطى الأولي للدالة:
<pre class="samplecode" dir=rtl style="text-align:right;">
  دالة اطبع (بنية: مؤشر[محرف]، عناصر: ...أيما) {
    بينما بنية~محتوى != 0 {
      إذا بنية~محتوى == '#' اطبع_عددا_صحيحا(عناصر~المعطى_التالي[صحيح])
      وإلا اطبع_عددا_عائما(عناصر~المعطى_التالي[عائم])؛
      بنية = بنية + 1؛
    }
  }

  اطبع("#$##$"، 5، 5.5، 8، 7، 2.3)؛
</pre>
<pre class="samplecode" dir=ltr>
  function print (format: ptr[Char], args: ...any) {
    while format~cnt != 0 {
      if format~cnt == '#' printInteger(args~next_arg[Int])
      else printFloat(args~next_arg[Float]);
      format = format + 1;
    }
  }

  print("#$##$", 5, 5.5, 8, 7, 2.3);
</pre>

                  <h4 id="Functions-anonymous">الدالات الضمنية</h4>
                  الدالات الضمنية هي الدالات التي تُعرف ضمن تركيب دون أن يكون لها اسم، وتستخدم عادة عند الحاجة لتمرير مؤشر على دالة كمعطى لدالة أخرى. تعريف هذه الدالات يكون بكتابتها بطريقة عادية ضمن أي تركيب دون إعطائها إسمًا، وفي هذه الحالة ستترجم القيمة إلى مؤشر تلك الدالة، كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
دالة رتب (
    قيود: سند[مـصفوفة[قـيد]]،
    قارن: مؤشر[دالة (سند[قـيد]، سند[قـيد])]
) {
    عرف م: صحيح؛
    عرف ن: صحيح؛
    لكل م = 0، م < قيود.هات_الطول() - 1، ++م {
        لكل ن = م + 1، ن < قيود.هات_الطول()، ن++ {
            إذا قارن(قيود(م)، قيود(ن)) {
                // بدل م مكان ن
            }
        }
    }
}

// رتب تصاعديا
رتب(قيود، دالة (ق1: سند[قـيد]، ق2: سند[قـيد]) {
    أرجع ق1.س > ق2.س؛
})؛

// رتب تنازليا
رتب(قيود، دالة (ق1: سند[قـيد]، ق2: سند[قـيد]) {
    أرجع ق1.س < ق2.س؛
})؛
</pre>
<pre class="samplecode" dir=ltr>
func sort (
    records: ref[Array[Record]],
    compare: ptr[func (ref[Record], ref[Record])]
) {
    def i: Int;
    def j: Int;
    for i = 0, i < records.getLength() - 1, ++i {
        for j = i + 1, j < records.getLength(), ++j {
            if compare(records(i), records(j)) {
                // Replace i with j;
            }
        }
    }
}

// Sort ascending.
sort(records, func (r1: ref[Record], r2: ref[Record]) {
    return r1.x > r2.x;
});

// Sort descending.
sort(records, func (r1: ref[Record], r2: ref[Record]) {
    return r1.x < r2.x;
});
</pre>
                  يمكن للدالات الضمنية الولوج إلى المتغيرات العمومية خارجها، لكن لا يمكنها الولوج إلى المتغيرات المحلية ضمن دالة خارجية تحوي الدالة الضمنية، وذلك لأن الدالة الخارجية قد ينتهي تنفيذها وتُزال متغيراتها من الذاكرة قبل استدعاء الدالة الضمنية. للولوج إلى متغيرات محلية ضمن دالة خارجية يحتاج المستخدم لاستخدام <a href="./srt-reference.ar.html#closure">المغلفات</a> بدل الدالات الضمنية.
                </div>

                <!-- ********************************************************************** -->
                <h3 id="Types">أصناف المستخدم</h3>
                <hr>
                <div>
                    تعرّف الهياكل باستخدام الأمر "صنف" كتعريف في الأمر "عرّف":
<pre class="code" dir=rtl style="text-align:right;">
  عرّف &lt;اسم_الصنف&gt; : صنف { &lt;مجموعة_تعريفات&gt; }
</pre>
<pre class="code" dir=ltr>
  def &lt;type_name&gt; : class { &lt;definition_statements&gt; }
</pre>
 بعد تعريف الصنف يصبح الصنف متوفراً لتعريف المتغيرات. الولوج إلى عناصر الهيكل يتم باستخدام مؤثر النقطة. مثال:
                    <pre class="samplecode" dir=rtl style="text-align:right;">
  عرّف النقطة : صنف {
    عرّف س : العدد_الحقيقي؛
    عرّف ص : العدد_الحقيقي؛
  }؛
  .
  .
  عرّف ن : النقطة؛
  ن.س = إقرأ_قيمة()؛
  ن.ص = إقرأ_قيمة()؛</pre>
<pre class="samplecode" dir=ltr>
  def Point : class {
    def x : Float;
    def y : Float
  };
  .
  .
  def p : Point;
  p.x = readValue();
  p.y = readValue();
</pre>
 يمكن أيضًا استخدام الصيغة المختصرة التي تغنيك عن استعمال الأمر "عرف"، كما يلي:
<pre class="code" dir=rtl style="text-align:right;">
  صنف &lt;اسم_الصنف&gt; { &lt;مجموعة_تعريفات&gt; }
</pre>
<pre class="code" dir=ltr>
  class &lt;type_name&gt; { &lt;definition_statements&gt; }
</pre>
 كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف النقطة {
    عرّف س : العدد_الحقيقي؛
    عرّف ص : العدد_الحقيقي؛
  }؛
  .
  .
  عرّف ن : النقطة؛
  ن.س = إقرأ_قيمة()؛
  ن.ص = إقرأ_قيمة()؛
</pre>
<pre class="samplecode" dir=ltr>
  class Point {
    def x : Float;
    def y : Float
  };
  .
  .
  def p : Point;
  p.x = readValue();
  p.y = readValue();
</pre>
                <h4 id="Types-templates">قوالب الأصناف</h4>
                يمكن تعريف قوالب الأصناف بتعريف معطيات يستخدمها الصنف في متنه ويتم تمرير هذا المعطى أثناء تعريف متغير من ذلك الصنف. التعريف والاستخدام يأخذان الصيغة التالية:
<pre class="code" dir=rtl style="text-align:right;">
  صنف &lt;اسم_الصنف&gt; [&lt;تعريف_معطيات_القالب&gt;] { &lt;متن_الصنف&gt; }

  عرف &lt;اسم_المتغير&gt;: &lt;اسم_الصنف&gt;[&lt;معطيات_القالب&gt;]؛
</pre>
<pre class="code" dir=ltr>
  class &lt;type_name&gt; [&lt;template_arg_defs&gt;] { &lt;type_body&gt; }

  def &lt;var_name&gt;: &lt;type_name&gt;[&lt;template_args&gt;];
</pre>
                كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف نـقطة [نوع: صنف] {
    عرف س: نوع؛
    عرف ص: نوع؛
  }؛

  عرف موقع_صحيح: نـقطة[صحيح]؛
  عرف موقع_عائم: نـقطة[عائم]؛
</pre>
<pre class="samplecode" dir=ltr>
  class Point [T: type] {
    def x: T;
    def y: T;
  };

  def intPoint: Point[int];
  def floatPoint: Point[float];
</pre>
                معطيات القوالب يمكن أن تكون من خمسة أنواع:
                <ul>
                 <li>صنف type</li>
                 <li>دالة function</li>
                 <li>صحيح integer</li>
                 <li>محارف string</li>
                 <li>شبم ast</li>
                </ul>
                <p>المعطيات من نوع `شبم` (ast) يمكن استخدامها في المعالجة التمهيدية للصنف، فهي تمكن المستخدم من تمرير شفرة مصدرية كمعطى للقالب، ثم أثناء المعالجة التمهيدية يمكن قراءة ذلك المعطى والتعامل معه بأي طريقة كانت ومن ثم حشر الشفرة المعطاة أو شفرة مشتقة منها داخل طبعة القالب الناتجة. من الجدير ملاحظ أن المعالجة التمهيدية لقوالب الأصناف تتكرر مع كل طبعة من ذلك الصنف.</p>
                من الممكن أيضا تحديد قيم مبدئية لمعطيات القوالب، كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف نـقطة [نوع: صنف، القيمة_المبدئية: صحيح = 0] {
    عرف س: نوع = القيمة_المبدئية؛
    عرف ص: نوع = القيمة_المبدئية؛
  }

  عرف موقع1: نـقطة[صحيح]؛ // س و ص سيكونان 0.
  عرف موقع2: نـقطة[صحيح، 1]؛ // س و ص سيكونان 1.
</pre>
<pre class="samplecode" dir=ltr>
  class Point [T: type, V: integer = 0] {
    def x: T = V;
    def y: T = V;
  }

  def point1: Point[Int]; // x and y will be 0.
  def point2: Point[Int, 1]; // x and y will be 1.
</pre>

                <h4 id="Types-methods">الوظائف (methods)</h4>
                الوظائف هي دالات تعرف داخل الأصناف ويتم استدعاؤها باستخدام كائن من ذلك الصنف. تُعرف الوظائف بتعريف دالة داخل متن الصنف مع إضافة المبدل `@عضو` (@member) لتلك الدالة وجعل أول معطى لتلك الدالة سندًا لذلك الصنف.
<pre class="code" dir=rtl style="text-align:right;">
صنف &lt;اسم_الصنف&gt; {
  @عضو دالة &lt;اسم_الوظيفة&gt; (هذا: سند[هذا_الصنف]، &lt;تعريفات_المعطيات&gt;): &lt;صنف_الإرجاع&gt; {
    &lt;متن_الوظيفة&gt;
  }؛
}؛

&lt;اسم_الكائن&gt;.&lt;اسم_الوظيفة&gt;(&lt;المعطيات&gt;)؛
</pre>
<pre class="code" dir=ltr>
class &lt;type_name&gt; {
  @member func &lt;method_name&gt; (this: ref[this_type], &lt;arg_definitions&gt;): &lt;ret_type&gt; {
    &lt;method_body&gt;
  };
};

&lt;object_name&gt;.&lt;method_name&gt;(&lt;arguments&gt;);
</pre>
                داخل الوظيفة يمكنك الوصول إلى الكائن المرتبط بذلك الاستدعاء باستخدام المعطى الأول للدالة (هذا) كما لو كان المستخدم قد مرر ذلك الكائن إلى الدالة يدويًا. مثال:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف نـقطة {
    عرف س: عائم؛
    عرف ص: عائم؛
    @عضو دالة هات_المسافة (هذا: سند[هذا_الصنف]): عائم {
      ارجع ريـاضيات.جذر(هذا.س * هذا.س + هذا.ص * هذا.ص)؛
    }؛
  }؛
  عرف ن: نـقطة؛
  ن.س = 3؛
  ن.ص = 4؛
  اطبع(ن.هات_المسافة())؛ // سيطبع 5
</pre>
<pre class="samplecode" dir=ltr>
  class Point {
    def x: float;
    def y: float;
    @member func getDistance (this: ref[this_type]):float {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    };
  }:
  def p: Point;
  p.x = 3;
  p.y = 4;
  print(p.getDistance()); // prints 5
</pre>
                يمكن أيضًا تعريف الوظائف باستخدام الأمر `عملية` (handler) وهو مجرد تجميل لغوي للطريقة المذكورة أعلاه:
<pre class="code" dir=rtl style="text-align:right;">
صنف &lt;اسم_الصنف&gt; {
  عملية هذا.&lt;اسم_الوظيفة&gt; (&lt;تعريفات_المعطيات&gt;): &lt;صنف_الإرجاع&gt; {
    &lt;متن_الوظيفة&gt;
  }؛
}؛

&lt;اسم_الكائن&gt;.&lt;اسم_الوظيفة&gt;(&lt;المعطيات&gt;)؛
</pre>
<pre class="code" dir=ltr>
class &lt;type_name&gt; {
  handler this.&lt;method_name&gt; (&lt;arg_definitions&gt;): &lt;ret_type&gt; {
    &lt;method_body&gt;
  };
};

&lt;object_name&gt;.&lt;method_name&gt;(&lt;arguments&gt;);
</pre>
                مثال:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف نـقطة {
    عرف س: عائم؛
    عرف ص: عائم؛
    عملية هذا.هات_المسافة (): عائم {
      ارجع ريـاضيات.جذر(هذا.س * هذا.س + هذا.ص * هذا.ص)؛
    }؛
  }؛
  عرف ن: نـقطة؛
  ن.س = 3؛
  ن.ص = 4؛
  اطبع(ن.هات_المسافة())؛ // سيطبع 5
</pre>
<pre class="samplecode" dir=ltr>
  class Point {
    def x: float;
    def y: float;
    handler this.getDistance ():float {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    };
  }:
  def p: Point;
  p.x = 3;
  p.y = 4;
  print(p.getDistance()); // prints 5
</pre>

                <h4 id="Types-props">الخصال (properties)</h4>
                الخصال وظائف لكنها تختلف بأن استدعاءها يتم باستخدام أحد المؤثرات التي يحددها تعريف الخصلة بدل استدعائها كدالة، كما هو موضح في المثال لاحقًا. تُعرف الخصال كما تُعرف الوظائف، لكن بإضافة المؤثر `@عملية` (@operation) إلى التعريف، كما يلي:
<pre class="code" dir=rtl style="text-align:right;">
صنف &lt;اسم_الصنف&gt; {
  @عضو
  @عملية["&lt;المؤثر&gt;"]
  دالة &lt;اسم_الخصلة&gt; (هذا: سند[هذا_الصنف]، &lt;تعريف_المعطى&gt;): &lt;صنف_الإرجاع&gt; {
    &lt;متن_الخصلة&gt;
  }؛
}؛

&lt;اسم_الكائن&gt;.&lt;اسم_الوظيفة&gt; &lt;المؤثر&gt; &lt;المعطيات&gt;؛
</pre>
<pre class="code" dir=ltr>
class &lt;type_name&gt; {
  @member
  @operation["&lt;operator&gt;"]
  func &lt;method_name&gt; (this: ref[this_type], &lt;arg_def&gt;): &lt;ret_type&gt; {
    &lt;method_body&gt;
  };
};

&lt;object_name&gt;.&lt;method_name&gt; &lt;operator&gt; &lt;arguments&gt;;
</pre>
                المثال التالي يوضح تعريف عملية = على خصلة:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف مـدة {
    عرف بداية: عائم؛
    عرف نهاية: عائم؛
    @عضو @عملية["="] دالة طول (هذا: سند[هذا_الصنف]، ط: عائم) {
      هذا.نهاية = هذا.بداية + ط؛
    }؛
  }؛
  عرف م: مـدة؛
  م.بداية = 10؛
  م.طول = 50؛ // ستوضع القيمة 60 في م.نهاية
</pre>
<pre class="samplecode" dir=ltr>
  class Period {
    def start: float;
    def end: float;
    @member @operation["="] func length (this: ref[this_type], l:float) {
      this.end = this.start + l;
    };
  }:
  def p: Period;
  p.start = 10;
  p.length = 50; // p.end will be set to 60
</pre>
                في المثال أعلاه عُرفت عملية التعيين على الخصلة `طول` (length) دون العمليات الأخرى، هذا يعني أن أي من العمليات الأخرى لا يمكن تطبيقها على هذه الخصلة، بما فيها محاولة قراءة الخصلة. للتمكن من قراءة الخصلة نحتاج لتعريف عملية جديدة للخصلة مع تحديد معطى العملية كسلسلة محارف فارغة بدل سلسلة محارف تحتوي المؤثر المطلوب. مثال:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف مـدة {
    عرف بداية: عائم؛
    عرف نهاية: عائم؛
    @عضو @عملية[""] دالة طول (هذا: سند[هذا_الصنف]): عائم {
      أرجع هذا.نهاية - هذا.بداية؛
    }؛
  }؛
  عرف م: مـدة؛
  م.بداية = 10؛
  م.نهاية = 60؛
  اطبع_عائم(م.طول)؛ // سيطبع 50
</pre>
<pre class="samplecode" dir=ltr>
  class Period {
    def start: float;
    def end: float;
    @member @operation[""] func length (this: ref[this_type]): float {
      return this.end - this.start;
    };
  }:
  def p: Period;
  p.start = 10;
  p.end = 60;
  printFloat(p.length) // prints 50
</pre>
                يمكن أيضا استخدام الأمر `عملية` (handler) لتبسيط كتابة هذه الخصال، كما يلي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف مـدة {
    عرف بداية: عائم؛
    عرف نهاية: عائم؛
    عملية هذا.طول = عائم {
        هذا.نهاية = هذا.بداية + قيمة؛
        أرجع قيمة؛
    }؛
    عملية هذا.طول: عائم {
      أرجع هذا.نهاية - هذا.بداية؛
    }؛
  }؛
  عرف م: مـدة؛
  م.بداية = 10؛
  م.طول = 50؛ // قيمة م.نهاية ستكون 60
  اطبع_عائم(م.طول)؛ // سيطبع 50
</pre>
<pre class="samplecode" dir=ltr>
  class Period {
    def start: float;
    def end: float;
    handler this.length = float {
        this.end = this.start + value;
        return value;
    };
    handler this.length: float {
      return this.end - this.start;
    };
  }:
  def p: Period;
  p.start = 10;
  p.length = 50; // p.end will be 60;
  printFloat(p.length) // prints 50
</pre>
                لاحظ في المثال أعلاه أن عملية التعيين فيها عبارة إرجاع، وذلك لأن الأمر `عملية` يُعرف تلقائيا صنف إرجاع لدالة الخصلة بصنف يطابق صنف المعطى.

                <h4 id="Types-sharedmembers">العناصر المشتركة</h4>
                يمكن تعريف متغيرات ودالات مشتركة داخل أصناف المستخدم، وهذه العناصر المشتركة تكون غير مرتبطة بأي كائن من هذا الصنف وإنما تتصرف كأنها دالات ومتغيرات عمومية وفرقها الوحيد عن المتغيرات والدالات العمومية أنها معرفة داخل مجال مختلف ولاستدعائها تحتاج أن تسبق اسمها باسم ذلك الصنف، كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف نـقطة {
    @مشترك عرف عدد: صحيح = 0؛
    عرف س: صحيح؛
    عرف ص: صحيح؛
    دالة أنشئ_نقطة (ا: صحيح، ب: صحيح): نـقطة {
      ++عدد؛
      س = ا؛ // خطأ
      ص = ب؛ // خطأ
      عرف ن: نـقطة؛
      ن.س = ا؛
      ن.ص = ب؛
      ارجع ن؛
    }؛
  }؛
  عرف ن: نـقطة = نـقطة.أنشئ_نقطة(1، 2)؛
  اطبع(نـقطة.عدد)؛ // يطبع 1
  اطبع(ن.عدد)؛ // خطأ
  اطبع(نـقطة.س)؛ // خطأ
</pre>
<pre class="samplecode" dir=ltr>
  class Point {
    @shared def count: int;
    def x: int;
    def y: int;
    func getPoint (a: int, b: int): Point {
      ++count;
      x = a; // error
      y = b; // error
      def p: Point;
      p.x = a;
      p.y = b;
      return p;
    };
  }:
  def p: Point = Point.getPoint(1, 2);
  print(Point.count); // prints 1
  print(p.count); // error
  print(Point.x); // error
</pre>
                كما هو موضح في المثال أعلاه، تعريف المتغيرات المشتركة يحتاج للمبدل `@مشترك` (@shared) بينما تعريف الدوال المشتركة لا يحتاج لأي مبدل خاص لأن أي دالة تعرف داخل صنف تكون مشتركة ما لم يُضف لتعريفها المبدل `@عضو` (@member).

                <h4 id="Types-methodptrs">مؤشرات الوظائف</h4>
                تعريف مؤشر على دالة بمبدل `@عضو` (@member) يجعله مؤشرًا على وظيفة، أي أنك لن تستطيع تعيين قيمة المؤشر ليؤشر على دالة اعتيادية وإنما يجب لقيمة
                المؤشر أن تشير إلى وظيفة في نفس الصنف. المثال التالي يوضح الأمر:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف صـنفي {
    @عضو دالة افعل (هذا: سند[هذا_الصنف]، ص: صحيح) { ... }
    عرف مد: مؤشر[@عضو دالة (ص: صحيح)]؛
  }

  عرف ص: صـنفي؛
  ص.مد = صـنفي.افعل~مؤشر؛ // صحيح
  ص.مد(4)؛

  دالة افعل2 (ص: صحيح) { ... }
  ص.مد = افعل2~مؤشر؛ // خاطئ
</pre>
<pre class="samplecode" dir=ltr>
  class MyType {
    @member func doSomething (this: ref[this_type], j: Int) { ... }
    def pf: ptr[@member func (Int)];
  }

  def mt: MyType;
  mt.pf = MyType.doSomething~ptr; // correct
  mt.pf(5);

  func doSomething2 (j: Int) { ... }
  mt.pf = doSomething2~ptr; // error
</pre>
                مؤشرات الوظائف مفيدة لبعض خصائص البرمجة الكائنية مثل تعددية الأشكال الموروثة (polymorphism). لاحظ أن الوظائف يجب أن تبدأ بالمعطى `هذا` (this) وإلا فلن يكون استدعاء الدالة ممكنًا.<br>
                لكن ماذا لو أردنا تعريف مؤشر على دالة عامة غير مرتبطة بالكائن الذي يحتوي المؤشر؟ تعريف مؤشر على دالة بلا مبدل `@عضو` يؤدي الغرض، كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف صـنفي {
    @عضو دالة افعل (هذا: سند[هذا_الصنف]، ص: صحيح) { ... }
    عرف مد: مؤشر[دالة (ص: صحيح)]؛
  }

  عرف ص: صـنفي؛
  ص.مد = صـنفي.افعل~مؤشر؛ // خاطئ

  دالة افعل2 (ص: صحيح) { ... }
  ص.مد = افعل2~مؤشر؛ // صحيح
</pre>
<pre class="samplecode" dir=ltr>
  class MyType {
    @member func doSomething (this: ref[this_type], j: Int) { ... }
    def pf: ptr[func (Int)];
  }

  def mt: MyType;
  mt.pf = MyType.doSomething~ptr; // error

  func doSomething2 (j: Int) { ... }
  mt.pf = doSomething2~ptr; // correct
</pre>
                يمكن استخدام الأمر `عملية` (handler) لتبسيط تعريف مؤشرات الوظائف، حيث أن تعريف مؤشر الوظيفة يشبه تعريف الوظيفة مع اختلاف واحد وهو إضافة الكلمة المفتاحية `كمؤشر` (as_ptr) في نهاية التعريف قبل متن الدالة، كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف صـنفي {
    عملية هذا.مو(ص: صحيح) كمؤشر { ... }؛
  }
</pre>
<pre class="samplecode" dir=ltr>
  class MyType {
    handler this.mp(i: Int) as_ptr { ... };
  }
</pre>
                التعريف أعلاه يعرف المؤشر ويعرف في نفس الوقت الدالة ويقوم أيضًا بتعيين قيمة المؤشر أثناء تهيئة الكائن ليشير إلى الدالة.<br>
                يمكن أيضًا استخدام `عملية` لتعريف المؤشر فقط دون دالة يشير إليها، كما يلي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف صـنفي {
    عملية هذا.مو(ص: صحيح) كمؤشر؛
  }
</pre>
<pre class="samplecode" dir=ltr>
  class MyType {
    handler this.mp(i: Int) as_ptr;
  }
</pre>
                وفي حالة توفر المؤشر مسبقًا والرغبة فقط بتعريف الدالة وتهيئة المؤشر الموجود مسبقًا ليشير إلى الدالة تستخدم الصيغة التالية:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف صـنفي {
    عملية هذا.مو(ص: صحيح) حدد_مؤشر { ... }؛
  }
</pre>
<pre class="samplecode" dir=ltr>
  class MyType {
    handler this.mp(i: Int) set_ptr { ... };
  }
</pre>
                تعريف المؤشر بشكل منفصل عن تحديد قيمته مفيد في البرمجة الكائنية، وتحديدًا في تعددية الأشكال الموروثة (polymorphism)، حيث يُعرف المؤشر في الصنف الأصل وتحدد قيمته في الفرع.

                <h4 id="Types-custominit">تخصيص تهيئة الكائنات</h4>
                يمكن للمستخدم تخصيص عملية تهيئة الكائنات باستخدام الأمر `عملية` (handler) وهذه صيغته:
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا~هيئ (&lt;معطيات&gt;) { &lt;متن_الدالة&gt; }؛
</pre>
<pre class="code" dir=ltr>
  handler this~init (&lt;argument_definitions&gt;) { &lt;body&gt; };
</pre>
                عند تعريف هذه العملية داخل الصنف يقوم المترجم باستدعاء هذه الدالة كلما احتاج لتهيئة كائن جديد. يمكن تعريف معطيات لهذه الدالة إذا أردت تهيئة الكائن من كائن آخر كما هو الحال عند إرجاع هذا الكائن من دالة كقيمة أو استلامه في الدالة كمعطى. فعند تهيئة العنصر في إحدى هذه الحالات يقوم المترجم باستدعاء هذه الدالة وتمرير العنصر الأصلي كي تقوم الدلة بنسخه لـ`هذا`. أما في حالة عدم تخصيص عملية التهيئة فإن المترجم في هذه الحالات يقوم بنسخ ذاكرة الكائن.<br>
                <b>ملاحظة: </b> عند تعريف أي عملية لتخصيص التهيئة يمتنع المترجم عن التهيئة الافتراضية في كل الحالات وبالتالي تحتاج لتعريف كل حالات التهيئة، أي حالة التهيئة بدون معطيات وحالة التهيئة من كائن آخر.<br>
                المثال التالي يوضح تخصيص التهيئة:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف نـقطة {
    عرف س: صحيح؛
    عرف ص: صحيح؛

    عملية هذا~هيئ() {
      هذا.س = 0؛
      هذا.ص = 0؛
    }؛
    عملية هذا~هيئ(مصدر: سند[نـقطة]) {
      هذا.س = مصدر.س؛
      هذا.ص = مصدر.ص؛
    }؛
  }؛

  عرف ن: نـقطة: // يستدعي عملية التهيئة دون معطيات.
  دالة هات_نقطة (): نـقطة {
    عرف ن: نقطة؛
    ارجع ن: // يستدعي عملية التهيئة بالمعطى لتهيئة العنصر الذي سيستلم ن
  }؛
</pre>
<pre class="samplecode" dir=ltr>
  class Point {
    def x: int;
    def y: int;

    handler this~init() {
      this.x = 0;
      this.y = 0;
    };
    handler this~init(src: ref[Point]) {
      this.x = src.x;
      this.y = src.y;
    };
  }:

  def p: Point; // calls this~init()
  func getPoint (): Point {
    def p: Point;
    return p; // calls this~init(src)
  };
</pre>
                عند وجود عمليات تهيئة بمعطيات فإن تعريف المتغير يحتاج لتمرير هذه المعطيات، ويكون التعريف كالتالي:
<pre class="code" dir=rtl style="text-align:right;">
  عرف &lt;اسم_المتغير&gt;: &lt;صنف_المتغير&gt;(&lt;معطيات&gt;)؛
</pre>
<pre class="code" dir=ltr>
  def &lt;var_name&gt;: &lt;var_type&gt;(&lt;arguments&gt;);
</pre>
                المثال التالي يوضح تهيئة بمعطيات:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف نـقطة {
    عرف س: صحيح؛
    عرف ص: صحيح؛

    عملية هذا~هيئ(س: صحيح، ص: صحيح) {
      هذا.س = س؛
      هذا.ص = ص؛
    }؛
  }؛

  عرف ن: نـقطة(5، 10)؛
</pre>
<pre class="samplecode" dir=ltr>
  class Point {
    def x: int;
    def y: int;

    handler this~init(x: int, y: int) {
      this.x = x;
      this.y = y;
    };
  }:

  def p: Point(5, 10);
</pre>

                يمكن أيضا تخصيص التهيئة بدون معطيات بكتابة عمليات تلك التهيئة مباشرة داخل متن الصنف، وهذا مطابق لتعريف `عملية هذا~هيئ()`، كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف نـقطة {
    عرف س: صحيح؛
    عرف ص: صحيح؛

    هذا.س = 0؛ // مطابق لفعلها داخل عملية هذا~هيئ()
    هذا.ص = 0؛ // مطابق لفعلها داخل عملية هذا~هيئ()

    عملية هذا~هيئ(مصدر: سند[نـقطة]) {
      هذا.س = مصدر.س؛
      هذا.ص = مصدر.ص؛
    }؛
  }؛

  عرف ن: نـقطة: // يستدعي عملية التهيئة دون معطيات.
  دالة هات_نقطة (): نـقطة {
    عرف ن: نقطة؛
    ارجع ن: // يستدعي عملية التهيئة بالمعطى لتهيئة العنصر الذي سيستلم ن
  }؛
</pre>
<pre class="samplecode" dir=ltr>
  class Point {
    def x: int;
    def y: int;

    this.x = 0;
    this.y = 0;

    handler this~init(src: ref[Point]) {
      this.x = src.x;
      this.y = src.y;
    };
  }:
</pre>
                <b>ملاحظة: </b>إذا احتوى الصنف على متغيرات من صنف ذي تهيئة مخصصة، فإن الصنف الخارجي يعتبر ذا تهيئة مخصصة أيضا حتى لو لم يعرف المستخدم علميات تهيئة لذلك الصنف. السبب في ذلك أن المترجم تلقائيا يعرف دالات تهيئة لتهيئة العناصر الداخلية.

                <h4 id="Types-customterminate">تخصيص إتلاف الكائنات</h4>
                مثلما هو الحال مع تهيئة الكائنات، يمكن للمستخدم تخصيص عملية إتلاف الكائن وذلك بإضافة التعريف التالي إلى الصنف:
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا~أتلف () { &lt;متن_الدالة&gt; }؛
</pre>
<pre class="code" dir=ltr>
  handler this~terminate () { &lt;body&gt; };
</pre>
                عند خروج التنفيذ من أي مجال فإن المترجم يقوم تلقائيا باستدعاء هذه الدالة لكل العناصر المعرفة ضمن ذلك المجال. يمكن استخدام هذه الدالة لتحرير أي موارد تم حجزها من قبل ذلك الكائن.

                <h4 id="Types-initorder">تسلسل تهيئة الكائنات</h4>
                عند تهيئة كائن ذي تهيئة مخصصة فإن المترجم يبدأ أولا بتهيئة كل متغير من متغيرات الكائن تهيئة كاملة قبل أن يستدعي دالة التهيئة التابعة للكائن نفسه. والتسلسل نفسه يتبع عند تهيئة كل متغير من المتغيرات إذا كان هو الآخر يحتوي على متغيرات بتهيئة مخصصة. بمعنى آخر التهيئة تتم دائما من الأطراف إلى الجذر، أما عملية الإتلاف فتكون بشكل عكسي، أي يبدأ الإتلاف من الجذر إلى الأطراف، أي بتنفيذ دالة الإتلاف للكائن الرئيسي ثم للعناصر الداخلية ثم العناصر الأعمق وهكذا بشكل مشابه لخوارزية بحث العمق أولا.

                <h4 id="Types-customops">تخصيص المؤثرات</h4>
                يمكن للمستخدم أيضا تخصيص المؤثرات المطبقة على الكائنات باستخدام الأمر `عملية` (handler) بطريقة مشابهة لتخصيص التهيئة مع استخدام المؤثر المطلوب بدل الأمر `~هيئ`. المثال التالي يوضح تخصيص مؤثر المساواة على كائن:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف نـص {
    ...
    عملية هذا = مؤشر[مصفوفة[محرف]] {
      هذا.انسخ_محارف(قيمة)؛
    }؛
    عملية هذا == مؤشر[مصفوفة[محرف]] {
      ارجع هذا.قارن(قيمة)؛
    }؛
  }؛

  عرف ن: نـص؛
  ن = "بسم الله"؛
  إذا ن == "بسم الله" اطبع("النص مطابق")؛
</pre>
<pre class="samplecode" dir=ltr>
  class String {
    ...
    handler this = ptr[array[char]] {
      this.copyChars(value);
    };
    handler this == ptr[array[char]] {
      return this.compare(value);
    };
  };

  def s: String;
  s = "hello world";
  if s == "hello world" print("text is identical");
</pre>
                يمكن باستخدام هذه الطريقة تخصيص كل المؤثرات، أي تخصيص أي من مؤثرات المقارنة أو العمليات الرياضية أو العمليات البتية كما يمكن أيضا تخصيص الأقواس كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف نـص {
    ...
    عملية هذا(موقع: صحيح): محرف {
      ارجع هذا.هات_محرف(موقع)؛
    }؛
  }؛

  عرف ن: نـص؛
  ن = "!@#$"؛
  اطبع(ن(1))؛ // سيطبع @
</pre>
<pre class="samplecode" dir=ltr>
  class String {
    ...
    handler this(pos: int): char {
      return this.getChar(pos);
    };
  };

  def s: String;
  s = "!@#$";
  print(s(1)); // prints @
</pre>

                <h4 id="Types-tempvarinitcustomization">تخصيص إنشاء المتغيرات المؤقتة</h4>
                يمكن تخصيص عملية إنشاء المتغيرات المؤقتة، والتي يتم إنشاؤها بإتباع اسم الصنف بأقواس. تخصيص هذه العملية يتم بتخصيص مؤثر الأقواس على الصنف ذاته وليس على كائن من ذاك الصنف، أي مؤثر الأقواس على `هذا_الصنف` (this_type) بدل `هذا` (this). المثال التالي يوضح الطريقة:
<pre class="samplecode" dir=rtl style="text-align:right;">
صنف قـيد {
    ...
    عملية هذا_الصنف(): سند[قـيد] {
        عرف س: سند[قـيد]؛
        س~مؤشر = ذاكـرة.احجز(قـيد~حجم)~مثل[مؤشر[قـيد]]؛
        س~هيئ()؛
        أرجع س؛
    }
}

دالتي(قـيد())؛ // سيستدعي العملية المخصصة وسينشئ الكائن ديناميكيا
    // بدل إنشاء متغير مؤقت على المكدس.
</pre>
<pre class="samplecode" dir=ltr>
class Record {
    ...
    handler this_type(): ref[Record] {
        def r: ref[Record];
        r~ptr = Memory.alloc(Record~size)~cast[ptr[Record]];
        r~init();
        return r;
    }
};

myFunc(Record()); // Will call the custom operation and allocate dynamically
    // on the heap instead of creating a temp var on the heap.
</pre>

                <h4 id="Types-injection">حقن التعريفات</h4>
                خاصية حقن التعريفات تمكن المستخدم من جعل عناصر تعريف معين متوفرة مباشرة في المجال الخارجي، وهذه الخاصية من لبنات البناء الأساسية التي يمكن استخدامها لتوفير خاصيات أخرى مثل الوراثة (inheritance) أو المؤشرات الذكية أو غيرها. كل ما تحتاج لجعل عناصر تعريف متوفرة داخل مجال الصنف الحاوي أن تَسِم التعريف بالمبدل @حقنة (injection) كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف داخـلي {
    عرف س: صحيح؛
    دالة اطبع_س { ... }؛
  }؛

  صنف خـارجي {
    @حقنة عرف د: داخـلي؛
    عرف ص: صحيح؛
    دالة اطبع_ص { ... }؛
  }؛

  عرف خ: خـارجي؛
  خ.س = 1؛ // يحولها المترجم إلى خ.د.س
  خ.ص = 2؛
  خ.اطبع_س()؛ // يحولها المترجم إلى خ.د.اطبع_س()
  خ.اطبع_ص()؛
</pre>
<pre class="samplecode" dir=ltr>
  class Inner {
    def x: Int;
    func printX { ... };
  };

  class Outer {
    @injection def i: Inner;
    def y: Int;
    func printY { ... };
  };

  def o: Outer;
  o.x = 1; // compiler translates it to o.i.x
  o.y = 2;
  o.printX(); // compiler translates it to o.i.printX()
  o.printY();
</pre>
                </div>

                <!-- ********************************************************************** -->
                <h3 id="TypeInference">استنباط الأصناف</h3>
                <hr>
                <div>
                  يمكن استنباط معلومات عن الأصناف أثناء الترجمة باستخدام المؤثرات التالية:

                  <h4 id="TypeInference-typeop">مؤثر ~صنف (~type)</h4>
                  باستخدام هذا المؤثر يمكن استنباط صنف متغير معين كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرف س: صحيح[64]؛
  عرف ص: س~صنف؛ // صنف ص هنا مطابق لصنف س، وهو عدد صحيح[64].

  عرف م: مؤشر؛
  م = س~مثل[مؤشر]؛
  م = س~مثل[م~صنف]؛ // مطابقة للجملة أعلاه.
</pre>
<pre class="samplecode" dir=ltr>
  def x: Int[64];
  def y: x~type; // y here has the same type as x, which is Int[64].

  def p: ptr;
  p = x~cast[ptr];
  p = x~cast[p~type]; // Equivalent to the upper statement.
</pre>
                  هذا المؤثر مفيد بشكل أساسي في القوالب والماكروهات حيث صنف المتغير قد لا يكون معروفا إلا عند استخدام القالب أو الماكرو.

                  <h4 id="TypeInference-sizeop">مؤثر ~حجم (~size)</h4>
                  يستخدم هذا المؤثر لمعرفة حجم صنف أو متغير في الذاكرة، أي عدد البايتات التي يستهلكها الصنف في الذاكرة. يمكن استخدام هذا المؤثر على
                  صنف أو متغير أو حتى على تركيب، كما في الأمثلة التالية:
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرف س: صحيح[16]؛
  عرف ص: صحيح[32]؛
  دالة هات_صحيح (): صحيح { ... }؛

  طـرفية.اطبع(س~حجم)؛ // يطبع 2.
  طـرفية.اطبع(ص~حجم)؛ // يطبع 4.
  طـرفية.اطبع(صـحيح[64]~حجم)؛ // يطبع 8
  طـرفية.اطبع(هات_صحيح()~حجم)؛ // يطبع 4؛
  طـرفية.اطبع((س + ص)~حجم)؛ // يطبع 4؛
</pre>
<pre class="samplecode" dir=ltr>
  def x: Int[16];
  def y: Int[32];
  func getInt (): Int { ... };

  Console.print(x~size); // Prints 2.
  Console.print(y~size); // Prints 4.
  Console.print(Int[64]~size); // Prints 8.
  Console.print(getInt()~size); // Prints 4.
  Console.print((x + y)~size); // Prints 4.
</pre>

                </div>

                <!-- ********************************************************************** -->
                <h3 id="Pointers">المؤشرات</h3>
                <hr>
                <div>
                    المؤشرات تستخدم للإشارة إلى مواقع في الذاكرة والتحكم بمحتويات تلك المواقع. تُعرّف المؤشرات باستخدام الصنف "مؤشر" (ptr) متبوعاً بقوسين معقوفين بينهما صنف محتوى الذاكرة المشار إليه بالمؤشر:
<pre class="code" dir=rtl style="text-align:right;">
  عرّف &lt;اسم_المؤشر&gt; : مؤشر[&lt;صنف_المحتوى&gt;]
</pre>
<pre class="code" dir=ltr>
  def &lt;ptr_name&gt; : ptr[&lt;content_type&gt;]
</pre>
                    يمكن الولوج إلى المحتوى المشار إليه بالمؤشر عن طريق المؤثر "~محتوى" (~cnt) ويمكن الحصول على موقع أي متغير عن طريق المؤثر "~مؤشر" (~ptr) كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرّف م : مؤشر[العدد_الصحيح]؛
  عرّف س : العدد_الصحيح؛
  س = 5؛
  م = س~مؤشر؛
  م~محتوى = 1؛
  // قيمة س الآن 1 وليس 5.
</pre>
<pre class="samplecode" dir=ltr>
  def p : ptr[Int];
  def x : Int;
  x = 5;
  p = x~ptr;
  p~cnt = 1;
  // x is now equal to 1, not 5.
</pre>
                    يمكن تطبيق عمليات الجمع والطرح على المؤشرات، وفي هذه الحالة فإن مقدار الزيادة لقيمة المؤشر ستكون من مضاعفات حجم الصنف الذي يشير إليه المؤشر. على سبيل المثال، إذا أضفت 1 لمؤشر على عدد صحيح فإن قيم المؤشر ستزداد بمقدار حجم العدد الصحيح، أي بمقدار 4 بايتات في حالة العدد الصحيح بصيغة 32 بت.
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرّف م1: مؤشر[صحيح[32]] = ...؛
  عرف م2: مؤشر[محرف] = ...؛
  م1 = م1 + 1؛ // سيزداد بمقدار 4.
  م1 = م1 + 5؛ // سيزداد بمقدار 4 * 5، أي 20.
  م2 = م2 + 1؛ // سيزداد بمقدار 1.
  م2 = م2 + 5؛ // سيزداد بمقدار 5.
</pre>
<pre class="samplecode" dir=ltr>
  def p1: ptr[Int[32]] = ...;
  def p2: ptr[Char] = ...;
  p1 = p1 + 1; // Incremented by 4.
  p1 = p1 + 5; // Incremented by 5 * 4.
  p2 = p2 + 1; // Incremented by 1.
  p2 = p2 + 5; // Incremented by 5.
</pre>
                </div>

                <!-- ********************************************************************** -->
                <h3 id="References">السندات</h3>
                <hr>
                <div>
                السندات مشابهة لعمل المؤشرات إلا أنها أبسط في التعامل من المؤشرات حيث لا تتطلب منك سوى تعريف المتغير على أنه سند ومن ثم التعامل معه بنفس طريقة التعامل مع متغيرات اعتيادية، اي الوصول إلى المحتوى دون الحاجة لاستخدام المؤثر `~محتوى`.
<pre class="code" dir=rtl style="text-align:right;">
  عرّف &lt;اسم_السند&gt; : سند[&lt;صنف_المحتوى&gt;]
</pre>
<pre class="code" dir=ltr>
  def &lt;ref_name&gt; : ref[&lt;content_type&gt;]
</pre>
                قبل استخدام السند تحتاج لتحديد قيمة المؤشر لذلك السند ويختلف ذلك فيما لو كان السند أحد معطيات دالة أم لا. إذا كان السند معطى لدالة فكل ما تحتاج لفعله تمرير متغير من صنف محتوى السند لتلك الدالة ويتولى المترجم تلقائيا تمرير مؤشر المتغير واستخدامه لذلك السند كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  دالة ضاعف (سم: سند[صحيح]) { سم *= 2 }؛

  عرف م: صحيح = 5؛
  افعل(م)؛
  // الآن م == 10
</pre>
<pre class="samplecode" dir=ltr>
  func twice (ri: ref[int]) { ri *= 2 };

  def i: int = 5;
  twice(i);
  // now i == 10
</pre>
                في حالة كون السند معرفا كمتغير اعتيادي وليس معطى لدالة فتحتاج لتحديد مؤشره يدويا كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرف سم: سند[صحيح]؛
  عرف م: صحيح؛
  سم~مؤشر = م~مؤشر؛
  سم = 3؛
  // الآن م == 3
</pre>
<pre class="samplecode" dir=ltr>
  def ri: ref[Int];
  def i: Int;
  ri~ptr = i~ptr;
  ri = 3;
  // now i == 3
</pre>
                بالإمكان أيضا استخدام المؤثر `~مؤشر` لجعل السند يشير إلى حجز ديناميكي للذاكرة:
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرف سم: سند[صـنفي]؛
  سم~مؤشر = ذاكـرة.احجز(صـنفي~حجم)~مثل[مؤشر[صـنفي]]؛
</pre>
<pre class="samplecode" dir=ltr>
  def r: ref[MyType];
  r~ptr = Memory.alloc(MyType~size)~cast[ptr[MyType]];
</pre>
                كما يمكنك تعريف سند لسند كما في المثال:
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرف سسم: سند[سند[صحيح]]؛
  عرف سم: سند[صحيح]؛
  عرف م: صحيح؛
  سم~مؤشر = م~مؤشر؛
  سسم~مؤشر~مؤشر = سم~مؤشر~مؤشر؛
  سسم = 3؛
  // الآن م == 3
</pre>
<pre class="samplecode" dir=ltr>
  def rri: ref[ref[Int]];
  def ri: ref[Int];
  def i: Int;
  ri~ptr = i~ptr;
  rri~ptr~ptr = ri~ptr~ptr;
  rri = 3;
  // now i == 3
</pre>
                لاحظ أن المؤثر `~مؤشر` يبدأ دائما من المحتوى. بمعنى آخر لو عرفنا سسص على أنه `سند[سند[صحيح]]` وعرفنا سص على أنه `سند[صحيح]` فإن `سسص~مؤشر` و `سص~مؤشر` كلاهما يرجعان مؤشرا على صحيح. كما أن العمليات التي نطبقها على السند دائما تطبق على المحتوى بغض النظر عن عمق السند، لذا فإن `سسص = 5` و `سص = 5` كلاهما يعدلان المحتوى رغم أن الأول سند مزدوج.

                  <h4 id="References-tempref">السندات المؤقتة</h4>
                  إذا كانت الدالة تستقبل سندا فلا يمكن استدعاؤها باستخدام قيمة. على سبيل المثال، إذا كانت الدالة ا ترجع قيمة وكانت الدالة
                  ب تستقبل سند لنفس الصنف، فلا يمكن تمرير القيمة المرجعة من ا كمعطى للدالة ب. هذا الأمر مقصود لتجنب الأخطاء غير المقصودة
                  والتي قد تؤدي إلى segmentation fault (لأن وجود القيمة في الذاكرة مؤقت وبالتالي فالاحتفاظ بسند لتلك القيمة سيؤدلي لاحقاً
                  إلى ولوج لذاكرة غير مرخصة). لكن في بعض الحالات قد يكون استلام سند على قيمة مؤقتة آمنًا لأن الحاجة لتلك القيمة المؤقتة تنتهي
                  بعد الخروج من الدالة. في هذه الحالات يمكن تعريف السند على أنه سند مؤقت وفي هذه الحالة سيقوم المترجم تلقائيًا بتمرير سند
                  حتى لو أعطيناه قيمة وليس متغيرًا (سيقوم في هذه الحالة بتحويل القيمة إلى سند تلقائيًا). مثال:
<pre class="samplecode" dir=rtl style="text-align:right;">
  دالة استلم_سند1 (س: سند[صحيح]) { ... }
  دالة استلم_سند2 (س: سند_مؤقت[صحيح]) { ... }

  استلم_سند1(7ص32)؛ // خطأ. الدالة تحتاج إلى متغير وليس قيمة.
  استلم_سند2(7ص32)؛ // مقبول. سيحول المترجم هذه القيمة تلقائيًا إلى سند.
</pre>
<pre class="samplecode" dir=ltr>
  func receiveRef1 (r: ref[Int]) { ... }
  func receiveRef2 (r: temp_ref[Int]) { ... }

  receiveRef1(7i32); // Error. The functions needs a variable, not a value.
  receiveRef2(7i32); // Accepted. The compiler will automatically generate a reference out of this value.
</pre>

                  <h4 id="References-noderef">مؤثر ~عطل_التتبع (~no_deref)</h4>
                  في بعض الحالات قد نحتاج لمنع المترجم من تتبع السند إلى القيمة، كما في الحالات التي نحتاج فيها لتغيير السند نفسه
                  وليس القيمة التي يؤشر إليها. في هذه الحالات نستخدم المؤثر ~عطل_التتبع لإخبار المترجم أننا نريد تعديل السند نفسه
                  وليس القيمة. كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرف ع: صحيح؛
  عرف س: سند[صحيح]؛

  س = ع؛ // سيؤدي لتغيير القيمة المخزونة في الموقع الذي يشير إليه س.
  س~عطل_التتبع = ع؛ // سيجعل س يشير إلى ع.
</pre>
<pre class="samplecode" dir=ltr>
  def i: Int;
  def r: ref[Int];

  r = i; // Will change the value pointed to by r.
  r~no_deref = i; // Will make r point to i.
</pre>
                  استخدام مؤثر ~عطل_التتبع على متغير غير سند ليس له أي تأثير لكنه لا يؤدي إلى خطأ.
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرف ع: صحيح؛
  ع~عطل_التتبع = 7؛ // مطابق لـ: ع = 7؛
</pre>
<pre class="samplecode" dir=ltr>
  def i: Int;
  i~no_deref = 7; // Equivalent to: i = 7;
</pre>
                  هذا المؤثر مهم جدا في حالة القوالب. بدون استخدام هذا المؤثر فإن القوالب ستتصرف بصورة مختلفة عند استخدامها مع السندات عما
                  سيكون تصرفها في حالة استخدامها مع أصناف أخرى غير السندات. لاحظ المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف صـنف1 [ن: صنف] {
    عرف س: ن؛
    س = 0؛
  }
  عرف ك: صـنف1[صحيح]؛ // لا مشكلة. سيصفر قيمة س.
  عرف ل: صـنف1[سند[صحيح]]؛ // سيؤدي إلى segfault لأنه سيحاول تصفير موقع عشوائي لأن س سند.


  صنف صـنف2 [ن: صنف] {
    عرف س: ن؛
    س~عطل_التتبع = 0؛
  }
  عرف م: صـنف2[صحيح]؛ // لا مشكلة. سيصفر قيمة س.
  عرف ن: صـنف2[سند[صحيح]]؛ // لا مشكلة. سيصفر قيمة س، اي قيمة المؤشر.
</pre>
<pre class="samplecode" dir=ltr>
  class Tp1 [T: type] {
    def x: T;
    x = 0;
  }
  def i: Tp1[Int]; // No problem, x will be set to 0.
  def j: Tp1[ref[Int]]; // Causes segfault for updating a random location in memory.

  class Tp2 [T: type] {
    def x: T;
    x~no_deref = 0;
  }
  def k: Tp2[Int]; // No problem, value of x will be set to 0.
  def l: Tp2[ref[Int]]; // No problem, value of x will be set to 0, i.e. the pointer value.
</pre>

                </div>

                <!-- ********************************************************************** -->
                <h3 id="Arrays">المصفوفات</h3>
                <hr>
                <div>
                    تعرّف المصفوفات باستخدام الصنف "مصفوفة" (array) متبوعاً بأقواس معقوفة تحتوي صنف عناصر المصفوفة وعددها:
                    <pre class="code" dir=rtl style="text-align:right;">
  عرّف &lt;اسم_المصفوفة&gt; : مصفوفة[&lt;صنف_العناصر&gt;، &lt;عدد_العناصر&gt;]</pre>
                    <pre class="code" dir=ltr>
  def &lt;array_name&gt; : array[&lt;element_type&gt;, &lt;element_count&gt;]</pre> يمكن الدخول إلى عناصر المصفوفة بإعطاء رقم العنصر المعني بين قوسين معقوفين. مثال:
                    <pre class="samplecode" dir=rtl style="text-align:right;">
  عرّف مصفوفتي : مصفوفة[صحيح، 10]؛
  عرّف ع : صحيح؛
  لكل ع=0، ع&lt;10، ع++ {
    مصفوفتي[ع] = مضروب(ع)
  }</pre>
                    <pre class="samplecode" dir=ltr>
  def myArray : array[Int, 10];
  def i : Int;
  for i=0, i&lt;10, i++ {
    myArray[i] = factorial(i)
  }</pre>
                </div>

                <!-- ********************************************************************** -->
                <h3 id="Casting">تمثيل الأصناف</h3>
                <hr>
                <div>
                    يمكن تمثيل المتغيرات بصنف غير صنفها الحقيقي باستخدام المؤثر "~مثّل" (~cast) متبوعاً بقوسين معقوفين بينهما الصنف المراد تمثيله، كما في المثال التالي:
                    <pre class="samplecode" dir=rtl style="text-align:right;">
  عرّف ح : عـائم؛
  إطبع_عددا_صحيحا(ح~مثّل[صحيح])؛</pre>
                    <pre class="samplecode" dir=ltr>
  def f : Float;
  printInteger(f~cast[Int]);</pre> في الوقت الحالي عملية التمثيل محدودة ومازالت قيد التطوير، لكنها قريباً ستدعم تمثيل الأصناف دون قيود، مثل تمثيل عدد صحيح كمؤشر أو تمثيل مؤشر لصنف ما كمؤشر لصنف آخر.
                </div>

                <!-- ********************************************************************** -->
                <h3 id="TempObjects">الكائنات المؤقتة</h3>
                <hr>
                <div>
                يمكن إنشاء الكائنات بشكل مؤقت دون ربطها بمتغير وذلك باستخدام أقواس فارغة أو مصحوبة بمعطيات التهيئة، كما في المثال:
<pre class="samplecode" dir=rtl style="text-align:right;">
  ارسم_نقطة(نـقطة())؛
  ارسم_نقطة(نـقطة(5، 10))؛
</pre>
<pre class="samplecode" dir=ltr>
  drawPoint(Point());
  drawPoint(Point(5, 10));
</pre>
                في المثال أعلاه يُنشأ كائن مؤقت من صنف `نـقطة` أثناء استدعاء دالة `ارسم_نقطة`، ويُتلف هذا الكائن تلقائيًا بعد الانتهاء من تنفيذ الجملة. إتلاف الكائنات المؤقتة يتم دائمًا بعد الانتهاء من تنفيذ الجملة كاملة (التي يُنشأ فيها الكائن المؤقت) وليس بعد انتهاء تنفيذ الجزء الذي يستخدم الكائن المؤقت. على سبيل المثال:
<pre class="samplecode" dir=rtl style="text-align:right;">
  اطبع(احسب_المسافة(نـقطة(5، 10)، نـقطة(20، 25)))؛
</pre>
<pre class="samplecode" dir=ltr>
  print(calculateDistance(Point(5, 10), Point(20, 25)));
</pre>
                في المثال أعلاه يتم إتلاف الكائنين المؤقتين بعد الانتهاء من تنفيذ الجملة كلها، أي بعد الانتهاء من تنفيذ دالة الطباعة وليس بعد الانتهاء من تنفيذ دالة `احسب_المسافة`.

                </div>

                <!-- ********************************************************************** -->
                <h3 id="CommandPacks">رزم الأوامر</h3>
                <hr>
                <div>
                تمكن هذه الخاصية المستخدم من تنفيذ مجموعة من الأوامر على كائن دون الخروج من السياق الحالي للتنفيذ ودون تكرار اسم الكائن وذلك باستخدام مؤثر النقطة متبوعًا برزمة من الجمل بين قوسين حاصرين، كما في المثال التالي:
                المقصود بعدم الخروج من سياق التنفيذ الحالي أن البرنامج ينفذ رزمة الأوامر بشكل اعتراضي قبل أن يعود ليكمل التنفيذ من حيث كان قبل تنفيذ الرزمة.
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف نـقطة {
    عرف س: صـحيح؛
    عرف ص: صـحيح؛
  }
  
  عرف ن: نـقطة؛
  ن.{ س = 5؛ ص = 10 }؛
  // الجملة أعلاه مطابقة ل:
  // ن.س = 5؛
  // ن.ص = 10؛
</pre>
<pre class="samplecode" dir=ltr>
  class Point {
    def x: Int;
    def y: Int;
  }
  
  def p: Point;
  p.{ x = 5; y = 10 };
  // Upper statement is equivalent to:
  // p.x = 5;
  // p.y = 10;
</pre>
                المقصود بعدم الخروج من سياق التنفيذ الحالي أن البرنامج ينفذ رزمة الأوامر بشكل اعتراضي قبل أن يعود ليكمل التنفيذ من حيث كان قبل تنفيذ الرزمة. على سبيل المثال:
<pre class="samplecode" dir=rtl style="text-align:right;">
  ارسم_نقطة(ن.{ س = 5؛ ص = 10 })؛
</pre>
<pre class="samplecode" dir=ltr>
  drawPoint(p.{ x = 5; y = 10 });
</pre>
                في المثال أعلاه تُنفذ رزمة الأوامر على المتغير ن قبل تمريره إلى الدالة `ارسم_نقطة`، وبالتالي فإن الجملة مطابقة لـ:
<pre class="samplecode" dir=rtl style="text-align:right;">
  ن.س = 5؛
  ن.ص = 10؛
  ارسم_نقطة(ن)؛
</pre>
<pre class="samplecode" dir=ltr>
  p.x = 5;
  p.y = 10;
  drawPoint(p);
</pre>
                يمكن أيضًا تنفيذ رزمة الأوامر على كائن مؤقت، كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  ارسم_نقطة(نـقطة().{ س = 5؛ ص = 10 })؛
</pre>
<pre class="samplecode" dir=ltr>
  drawPoint(Point().{ x = 5; y = 10 });
</pre>
                في داخل رزمة الأوامر، الكلمة المفتاحية `هذا` (this) تشير إلى الكائن الذي تُنفذ عليه رزمة الأوامر، وبالتالي يمكنك كتابة الجملة أعلاه بهذه الطريقة:
<pre class="samplecode" dir=rtl style="text-align:right;">
  نـقطة().{ س = 5؛ ص = 10؛ ارسم_نقطة(هذا) }؛
</pre>
<pre class="samplecode" dir=ltr>
  Point().{ x = 5; y = 10; drawPoint(this) };
</pre>
                يمكن أيضًا استخدام رزمة الأوامر مع الأصناف الأساسية، كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  اطبع("أدخل رقمًا: ")؛
  عرف ر: صحيح(أدخل_صحيح())؛
  اطبع("الرقم %s.\ج"، مؤشر[محرف]().{
      إذا ر > 0 هذا = "موجب"
      وإلا إذا ر < 0 هذا = "سالب"
      وإلا هذا = "صفر"
  })؛
</pre>
<pre class="samplecode" dir=ltr>
  print("Enter a number: ");
  def i: Int(getInt());
  print("Number is %s.\n", ptr[Char]().{
      if i > 0 this = "positive"
      else if i < 0 this = "negative"
      else this = "zero"
  });
</pre>
                  <h4 id="CommandPacks-usein">مؤثر ~استخدم_في (~use_in)</h4>
                  في بعض الحالات تكون رزم الأوامر متداخلة، أو تكون داخل دالة عضو وقد يؤدي هذا إلى تضارب المتغير `هذا` (this) ما بين الرزم المتداخلة أو ما بين الرزمة والدالة العضو. لتجنب هذا التضارب يمكن استخدام المؤثر ~use-in الذي يستخدم لإنشاء رزم الأوامر كما هو الحال مع المؤثر `.{}` مع فرق واحد أنه يتيح للمستخدم تحديد اسم مختلف للمتغير بدل `هذا`. كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف صـنف {
    عرف ع: صحيح؛
    عملية هذا.هل_الرقم_موجب (): نـص {
      أرجع نـص()~استخدم_في(أنا){
        إذا هذا.ع > 0 أنا = "موجب"
        وإلا إذا هذا.ع < 0 أنا = "سالب"
        وإلا أنا = "صفر"؛
      }؛
    }
  }
</pre>
<pre class="samplecode" dir=ltr>
  class Type {
    def i: int;
    handler isNumPositive (): String {
      return String()~use_in(self){
        if this.i > 0 self = "positive"
        else if this.i < 0 self = "negative"
        else self = "zero"
      };
    }
  }
</pre>
                  في هذا المثال رزمة أوامر تم إنشاؤها باستخدام المؤثر `~استخدم_في` بدل المؤثر `.{}`، وفي هذه الرزمة الكلمة `هذا` (this) تشير إلى الكائن بدل أن تشير إلى المتغير المؤقت ذي الصنف `نـص` (String) الذي أصبح يُشار إليه الآن بالكلمة `أنا` (self)،<br>
                  في حال استخدم المؤثر ~استخدم_في دون إعداء اسم بين القوسين (أي بإعطائه متنا فقط) فإن النتيجة مطابقة تمامًا لاستخدام المؤثر `.{}`.
                </div>

                <!-- ********************************************************************** -->
                <h3 id="DynamicInit">حجز وتهيئة الكائنات ديناميكيا</h3>
                <hr>
                <div>
                يمكن للمستخدم أن يهيئ الكائنات المنشأة ديناميكيًا باستخدام الأمر `~هيئ` (~init) كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف نـقطة {
    عملية هذا~هيئ() { ... }؛
    عملية هذا~أتلف() { ... }؛
    ...
  }؛

  عرف ن: سند[نـقطة]؛
  ن~مؤشر = ذاكـرة.احجز(نـقطة~حجم)~مثل[مؤشر[نـقطة]]؛
  ن~هيئ()؛
</pre>
<pre class="samplecode" dir=ltr>
  class Point {
    handler this~init() { ... };
    handler this~terminate() { ... };
    ...
  };

  def p: ref[Point];
  p~ptr = Memory.alloc(Point~size)~cast[ptr[Point]];
  p~init();
</pre>
                الفرق بين استخدام الأمر `~هيئ` واستدعاء دالة مستخدم عادية مخصصة للتهيئة أن استخدام `~هيئ` يضمن لك أيضا تهيئة المتغيرات الداخلية لهذا الصنف (إذا كانت هي الأخرى ذات تهيئة مخصصة). أي أن الأمر `~هيئ` يضمن تهيئة شجرة المتغيرات كاملة بكل الأعماق بدل أن تحتاج أن تهيئ كل متغير يدويا. مثلاً، إذا كان الصنف نـقطة يحتوي على متغير من صنف مخصص التهيئة ويحتوي هو الآخر على متغيرات من أصناف مخصصة التهيئة فإن الأمر `~هيئ` يضمن لك تهيئة كل هذه العناصر وبالتسلسل المطلوب.<br>
                كما هو الحال ما تهيئة الكائنات، يمكن للمستخدم استدعاء دالة الإتلاف يدويا لإتلاف الكائنات المحجوزة ديناميكيا، وبهذه الصيغة:
<pre class="samplecode" dir=rtl style="text-align:right;">
  ن~أتلف()؛
</pre>
<pre class="samplecode" dir=ltr>
  p~terminate();
</pre>

                </div>

                <!-- ********************************************************************** -->
                <h3 id="Alias">الألقاب</h3>
                <hr>
                <div>
                    لتيسير استخدام المكتبات المكتوبة بالانجليزية داخل برامج مكتوبة بالعربية (أو العكس) يمكن إنشاء ألقاب للدالّات والأصناف والمتغيرات وذلك باستخدام الأمر "لقب" (alias) كتعريف للأمر "عرّف". بعد ذلك يمكن استخدام الأسم الأصلي أو اللقب كيفما يشاء المستخدم فكلاهما
                    يشيران إلى نفس المعرّف. على سبيل المثال الصنف "العدد_الصحيح" هو لقب للصنف "Int" والدالة "اطبع" هي لقب للدالة "printf" وقد تم تعريف هذه الألقاب مسبقاً في الملف "متم.أسس" كما يلي:
                    <pre class="samplecode" dir=rtl style="text-align:right;">
  عرّف العدد_الصحيح : لقب int؛
  عرّف اطبع : لقب printf؛</pre> إنشاء الألقاب لا يشترط أن يكون بين لغتين، فيمكن تعريف لقب انجليزي لمعرّف انجليزي على سبيل المثال، كما في الصنف Int الذي هو لقب لـint.
                </div>

                <!-- ********************************************************************** -->
                <h3 id="Modules">الوحدات</h3>
                <hr>
                <div>
                    الوحدة مجال يمكن وضع التعريفات داخله. يمكن للوحدة أن تحتوي دالات أو متغيرات أو أصناف كما يمكن للوحدة أن تحتوي وحدات أخرى. تساعد الوحدات في تجنب الاصطدام الناتج من التشابه بين أسماء التعريفات حيث أن التعريفات داخل أي وحدة غير مرئية داخل الوحدات الأخرى
                    ما لم تتم الإشارة إليها بشكل صريح.<br> يمكن تعريف الوحدة باستخدام الأمر `وحدة` (module) كما يلي:
                    <pre class="code" dir=rtl style="text-align:right;">
  عرّف &lt;اسم_الوحدة&gt; : وحدة { &lt;التعريفات&gt; }؛</pre>
                    <pre class="code" dir=ltr>
  def &lt;module_name&gt; : module { &lt;definitions&gt; };</pre> يمكن الوصول إلى تعريفات داخل وحدة أخرى بأحد الطرق التالية:
                    <ul>
                        <li>أن تكون الوحدة الحالية نفسها داخل الوحدة التي تحتوي التعريف المطلوب كما في المثال التالي:
                            <pre class="samplecode" dir=rtl style="text-align:right;">
  عرف الـخارجية: وحدة {
    عرف م: صـحيح؛

    عرف الـداخلية: وحدة {
      عرف اطبع_م: دالة {
        اطبع(م)؛
      }
    }
  }</pre>
                            <pre class="samplecode" dir=ltr>
  def Outer: module {
    def v: Int;

    def Inner: module {
      def printV: function {
        print(v);
      }
    }
  }</pre>
                        </li>
                        <li>أن يتم ذكر المجال الكامل للتعريف المراد الوصول إليه، ابتداءًا من أي مجال مشترك كما في المثال التالي:
                            <pre class="samplecode" dir=rtl style="text-align:right;">
  عرف الـخارجية: وحدة {
    عرف الـداخلية1: وحدة {
      عرف م: صـحيح؛
    }؛

    عرف الـداخلية2: وحدة {
      عرف اطبع_م: دالة {
        اطبع(الـداخلية1.م)؛
      }
    }
  }</pre>
                            <pre class="samplecode" dir=ltr>
  def Outer: module {
    def Inner1: module {
      def v: Int;
    };

    def Inner2: module {
      def printV: function {
        print(Inner1.v);
      }
    }
  }</pre>
                        </li>
                        <li>باستخدام الأمر `استخدم` (use). يستخدم هذا الأمر لجعل مجال معين متوفرًا داخل المجال الحالي وصيغته كما يلي:
                            <pre class="code" dir=rtl style="text-align:right;">
  استخدم &lt;المجال_الكامل_للوحدة_المستهدفة&gt;؛</pre>
                            <pre class="code" dir=ltr>
  use &lt;full_path_of_targetted_module&gt;;</pre> هذا الأمر مفيد لتجنب الحاجة لتكرار ذكر المجال الكامل. يمكن استخدام هذا الأمر داخل وحدة أخرى أو داخل دالة ولا يمكن استخدامه في المجال الرئيسي خارج الوحدات. المثال التالي يوضح
                            استخدام الأمر:
                            <pre class="samplecode" dir=rtl style="text-align:right;">
  عرف الـخارجية: وحدة {
    عرف الـداخلية1: وحدة {
      عرف الـداخلية2: وحدة {
        عرف م: صـحيح؛
      }؛
    }؛

    استخدم الـداخلية1.الـداخلية2؛

    عرف اطبع_م: دالة {
      اطبع(م)؛
    }
  }</pre>
                            <pre class="samplecode" dir=ltr>
  def Outer: module {
    def Inner1: module {
      def Inner2: module {
        def v: Int;
      };
    };

    use Inner1.Inner2;

    def printV: function {
      print(v);
    }
  }</pre>
                        </li>
                    </ul>
                    يمكن أيضًا استخدام الصيغة المختصرة التي تغنيك عن الأمر "عرف":
                    <pre class="code" dir=rtl style="text-align:right;">
  وحدة &lt;اسم_الوحدة&gt; { &lt;التعريفات&gt; }؛</pre>
                    <pre class="code" dir=ltr>
  module &lt;module_name&gt; { &lt;definitions&gt; };</pre> كما في المثال التالي:
                    <pre class="samplecode" dir=rtl style="text-align:right;">
  وحدة الـخارجية {
    وحدة الـداخلية1 {
      وحدة الـداخلية2 {
        عرف م: صـحيح؛
      }؛
    }؛
  }</pre>
                    <pre class="samplecode" dir=ltr>
  module Outer {
    module Inner1 {
      module Inner2 {
        def v: Int;
      };
    };
  }</pre>
                </div>

                <!-- ********************************************************************** -->
                <h3 id="Macros">الماكروهات</h3>
                <hr>
                <div>
                    الماكرو هو مجموعة من الأوامر يمكن تكرارها بسهولة في أي مكان من البرنامج. يتم تعريف الماكرو كما يلي:
                    <pre class="code" dir=rtl style="text-align:right;">
  عرّف &lt;اسم_الماكرو&gt; : ماكرو [&lt;قائمة_المدخلات&gt;] &lt;متن_الماكرو&gt;</pre>
                    <pre class="code" dir=ltr>
  def &lt;macro_name&gt; : macro [&lt;arg_list&gt;] &lt;macro_body&gt;</pre> متن الماكرو يمكن أن يكون سطراً واحداً أو مجموعة أسطر بين أقواس حاصرة. ثم يُستخدم الماكرو لاحقاً في البرنامج بكتابة اسمه متبوعاً بالمعطيات بين أقواس معقوفة،
                    كما في المثال التالي:
                    <pre class="samplecode" dir=rtl style="text-align:right;">
  عرّف تربيع: ماكرو [م] م * م؛
  .
  .
  ص = تربيع[س]؛</pre>
                    <pre class="samplecode" dir=ltr>
  def power2: macro [n] n * n;
  .
  .
  s = power2[a];</pre> يمكن كذلك استخدام الصيغة المختصرة التي تغنيك عن استخدام الأمر "عرف":
                    <pre class="code" dir=rtl style="text-align:right;">
  ماكرو &lt;اسم_الماكرو&gt; [&lt;قائمة_المدخلات&gt;] &lt;متن_الماكرو&gt;</pre>
                    <pre class="code" dir=ltr>
  macro &lt;macro_name&gt; [&lt;arg_list&gt;] &lt;macro_body&gt;</pre> كما في المثال التالي:
                    <pre class="samplecode" dir=rtl style="text-align:right;">
  ماكرو تربيع [م] م * م؛
  .
  .
  ص = تربيع[س]؛</pre>
                    <pre class="samplecode" dir=ltr>
  macro power2 [n] n * n;
  .
  .
  s = power2[a];</pre>
                    <h4 id="Macros-strtemplates">القوالب في المعرفات وسلاسل المحارف</h4>
                    يمكن استخدام القوالب مع المعرفات وسلاسل المحارف داخل الماكرو ويتم ذلك في المعرفات بحصر القسم المتغير من المعرف بين شارحتين سفليتين متتاليتين من كل جانب، أما في سلاسل المحارف فيتم حصر القسم المتغير بين قوسين حاصرين مزدوجين، كما في المثال التالي:
                    <pre class="samplecode" dir=rtl style="text-align:right;">
  عرّف اطبع_متغيرات: ماكرو [م] {
    اطبع("{{م}}1 = %d\ج"، __م__1)؛
    اطبع("{{م}}2 = %d\ج"، __م__2)؛
  }؛
  .
  .
  س1 = 5؛
  س2 = 6؛
  اطبع_متغيرات[س]؛

  // سيطبع التالي:
  //  س1 = 5
  //  س2 = 6</pre>
                    <pre class="samplecode" dir=ltr>
  def print_vars: macro [v] {
    print("{{v}}1 = %d\n", __v__1);
    print("{{v}}2 = %d\n", __v__2);
  };
  .
  .
  s1 = 5;
  s2 = 6;
  print_vars[s];

  // will print:
  //  s1 = 5
  //  s2 = 6</pre>
                    <h4 id="Macros-cmacrocomparison">الفرق بين ماكرو لغة الأسُس وماكرو لغة السي</h4>
                    الماكرو في لغة الأسُس مختلف عن نظيره في لغة السي في طريقة المعالجة. في لغة السي الماكرو يعالج نصياً في مرحلة تسبق الإعراب بينما في لغة الأسُس الماكرو يعالج أثناء مرحلة الإعراب نفسها وهذا يؤدي إلى الفروقات التالية:
                    <ul>
                        <li>في لغة الأسُس الماكرو تأثيره محدود ضمن مجال تعريفه بعكس الماكر في لغة السي حيث يكون غير محدود بأي مجال. بمعنى آخر، في لغة الأسُس إذا عرفت ماكرو داخل مجال معين وحاولت استخدامه داخل مجال آخر فسيمنعك المترجم من ذلك.</li>
                        <li>يمكن في لغة الأسُس تعريف عدة ماكروهات بنفس الاسم طالما أنها معرفة ضمن مجالات مختلفة، وهذا غير ممكن في لغة السي.</li>
                        <li>في لغة الأسُس الأخطاء الإعرابية داخل الماكرو يتم استشعارها مباشرة بعكس لغة السي حيث لا تُستشعر الأخطاء الإعرابية إلا بعد انتهاء معالجة الماكرو والبدء بمرحلة الإعراب.</li>
                        <li>في لغة الأسُس لا يمكن تعريف ماكرو يحتوي متنه على أجزاء غير مكتملة من القواعد بعكس لغة السي التي تتيح ذلك. مثلاً، في لغة السي يمكن تعريف ماكرو يحتوي على جزء غير مكتمل من القواعد ويقوم المستخدم يتجميع ماكروهات متعددة للحصول على برنامج
                            صحيح قواعدياً وهذا الأمر غير ممكن في لغة الأسُس التي تمنع أن يكون متن أي ماكرو غير مكتمل قواعدياً.</li>
                    </ul>
                </div>

                <!-- ********************************************************************** -->
                <h3 id="Ast">شجرة البنية المجردة (Abstract Syntax Tree)</h3>
                <hr>
                <div>
                  الشفرة المصدرية بعد إعرابها تُحول إلى شجرة من البيانات تسمى شجرة البيانات المجردة (Abstract Syntax Tree) ويمكن للمستخدم الوصول لهذه
                  البيانات. الوصول لهذه البيانات مفيد في بعض التعاملات مع المترجم مثل ترجمة دالة إلى شفرة تنفيذية أو ما شابه، كما أنه مفيد في
                  تطوير خصائص جديدة عن طريق توليد شفرة جديدة برمجيا أو قراءة شفرة برمجيا لأي غرض كان. يمكن الوصول لشجرة البنية المجردة بطريقتين:
                  <ul>
                    <li>استخدام المؤثر <b>~شبم (~ast)</b> على أي عنصر من الشفرة المصدرية للحصول على شجرة ذلك العنصر.
<pre class="samplecode" dir=rtl style="text-align:right;">
  مدير_البناء.أنشء_ملفا_رقميا_لعنصر(دالتي~شبم)
</pre>
<pre class="samplecode" dir=ltr>
  buildMgr.buildObjectFileForElement(myFunction~ast)
</pre>
                    </li>
                    <li>استخدام الإيعاز <b>شبم (ast)</b> وإعطائه شفرة مصدرية للحصول على شجرة تلك الشفرة.
<pre class="samplecode" dir=rtl style="text-align:right;">
  مدير_شبم.احشر_شبم(شبم { ع = 0 }، ...)
</pre>
<pre class="samplecode" dir=ltr>
  astMgr.insertAst(ast { i = 0 }, ...)
</pre>
                    اي أن الفرق بين إيعاز `شبم` والمؤثر `~شبم` أن الإيعاز يمكنك من كتابة الشفرة مباشرة ضمن الإيعاز بدل كتابتها ضمن تعريف ثم
                    استخدام المؤثر ~شبم على اسم ذلك التعريف.
                     <p>
                     مبدئيًا، يقوم المترجم بالمعالجة التمهيدية لمعطى الأمر `شبم` قبل استخدامه في مواقع أخرى من الشفرة المصدرية. على سبيل المثال، لنفرض أنك تستخدم الأمر `شبم` لكتابة شفرة مصدرية يتم حشرها باستخدام دالة `احشر_شبم`، والشفرة المصدرية المرغوب حشرها (معطى شبم) تحتوي على الأمر `تمهيد`. مبدئيًا، يعالج المترجم عبارة التمهيد ضمن معطى `شبم` نفسه، أي قبل تنفيذ الشفرة التي تحتوي استدعاء `احشر_شبم`. أحيانًا تحتاج لتأخير المعالجة التمهيدية لتتم بعد حشر الشفرة، أي بعد الانتهاء من تنفيذ دالة `احشر_شبم`. لفعل ذلك يمكن إضافة المبدل `@بلا_تمهيد` (@no_preprocess) للأمر `شبم`، كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  ماكرو م [اسم] "__{{اسم}}__"؛
  مدير_شبم.احشر_شبم(شبم م[تجربة])؛ // سيحشر: "__تجربة__"
  مدير_شبم.احشر_شبم(@بلا_تمهيد شبم م[تجربة])؛ // سيحشر: م[تجربة]
</pre>
<pre class="samplecode" dir=ltr>
  macro m [name] "__{{name}}__";
  astMgr.insertAst(ast m[test]); // inserts: "__test__"
  astMgr.insertAst(@no_preprocess ast m[test]); // inserts: m[test]
</pre>
                     </p>
                    </li>
                  </ul>
                </div>

                  <!-- ********************************************************************** -->
                <h3 id="Preprocess">المعالجة التمهيدية</h3>
                <hr>
                <div>
                  المعالجة التمهيدية تمكن المستخدم من تنفيذ شفرة مباشرة قبل ترجمة أي دالة أو صنف، وتمكن المستخدم من إنشاء وإدخال شفرة جديدة برمجيًا.
                  تفيد هذه الخاصية في توليد شفرة برمجية اعتمادا على تعريف أبسط، وبالتالي تطوير اللغة وإضافة خاصيات جديدة بطريقة بسيطة.
                  فيما يلي صيغة عبارة `تمهيد`:
<pre class="code" dir=rtl style="text-align:right;">
  تمهيد &lt;متن_التمهيد&gt;
</pre>
<pre class="code" dir=ltr>
  preprocess &lt;preprocess_body&gt;
</pre>
                  داخل متن التمهيد يمكن للمستخدم كتابة شفرة بلغة الأسس نفسها دون قيود ويمكنه إنشاء وإدخال شفرة جديدة باستخدام الكائن `نـبم.مدير_شبم` (Spp.astMgr).
                  يمكن الاطلاع على دليل المكتبات التنفيذية لمعلومات مفصلة حول الوحدة `نـبم`. المثال التالي يوضح إنشاء مجموعة عبارات تعيين لمتغيرات يتم الاستعلام عنها
                  بطريقة ديناميكية:
<pre class="samplecode" dir=rtl style="text-align:right;">
  تمهيد {
      عرف متغيرات: مـصفوفة[نـص] = جد_أسماء_المتغيرات(...)؛
      عرف ع: صحيح؛
      لكل ع = 0، ع &lt; متغيرات.هات_الطول()، ++ع {
          نـبم.مدير_شبم.احشر_شبم(
              شبم { هذا.اسم = 0 }،
              تـطبيق[نـص، سند[الـقلب.أسـاسيات.كـائن_بهوية]]()
                  .حدد(نـص("اسم")، الـقلب.أسـاسيات.نـص_بهوية(متغيرات(ع)))
          )؛
      }
  }
</pre>
<pre class="samplecode" dir=ltr>
  preprocess {
      def vars: Array[String] = findVarNames(...);
      def i: Int;
      for i = 0, i &lt; vars.getLength(), ++i {
          Spp.astMgr.insertAst(
              ast { this.name = 0 },
              Map[String, ref[Core.Basic.TiObject]]()
                  .set(String("name"), Core.Basic.TiStr(vars(i)))
          );
      }
  }
</pre>
                  يمكن لعبارات `تمهيد` أن تكون متداخلة، أي يمكن لمتن عبارة تمهيد أن يحتوي على عبارة تمهيد أخرى. في هذه الحالة ينفذ المترجم
                  عبارة التمهيد الداخلية والتي بدورها تحشر شفرة داخل متن عبارة التمهيد الخارجية. بعد الانتهاء من تنفيذ العبارة الداخلية تُترجم
                  عبارة التمهيد الخارجية ثم تنفذ، وهكذا.
                </div>

                <!-- ********************************************************************** -->
                <h3 id="Merge">دمج التعريفات</h3>
                <hr>
                <div>
                    بعض التعريفات يمكن تجزئتها إلى عدة أجزاء تدمج لاحقاً عند البناء في تعريف واحد. تمكن هذه الخاصية المستخدم من توزيع التعريفات الكبيرة مثل الوحدات إلى عدة ملفات كما تمكن أيضاً من إلحاق إضافات إلى تعريفات مسبقة. يتم الدمج باستخدام المبدل `@دمج` (@merge) كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرف نـقطة: صنف {
    عرف س: صـحيح؛
  }؛
  .
  .
  @دمج عرف نـقطة: صنف {
    عرف ص: صحيح؛
  }؛
  .
  .
  عرف ابدأ: دالة {
    عرف ن: نـطقة؛
    ن.س = 10؛
    ن.ص = 12؛
    .
    .
  }؛
</pre>
<pre class="samplecode" dir=ltr>
  def Point: class {
    def x: Int;
  };
  .
  .
  @merge def Point: class {
    def y: Int;
  };
  .
  .
  def start: function {
    def p: Point;
    p.x = 10;
    p.y = 12;
    .
    .
  };
</pre>
                    من الممكن استخدام هذا المبدل لإلحاق إضافة على طبعة من قالب صنف، لكنك تحتاج أولاً لتعريف لقب لتلك الطبعة كي تتمكن من الدمج معها، كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  صنف نـقطة [الـصنف: صنف] {
    عرف س: الـصنف؛
    عرف ص: الـصنف؛
  }

  عرف نـقطة_صحيح: لقب نـقطة[صحيح]؛

  @دمج صنف نـقطة_صحيح {
    دالة اطبع { ... } // ستضاف هذه الدالة إلى نـقطة[صحيح] دون بقية طبعات القالب.
  }
</pre>
<pre class="samplecode" dir=ltr>
  class Point [T: type] {
    def x: T;
    def y: T;
  }

  def IntPoint: alias Point[Int];

  @merge class IntPoint {
    func print { ... } // This function will be added to Point[Int] only, not all template instances.
  }
</pre>
                </div>

                <!-- ********************************************************************** -->
                <h3 id="Import">شمل مكتبات أو ملفات مصدرية</h3>
                <hr>
                <div>
                    الأمر "اشمل" (import) يستخدم لتحميل ملف مصدري أو مكتبة واستخدامها في البرنامج. الأمر يميز تلقائياً بين الملف المصدري والمكتبة. في الوقت الحالي يدعم هذا الأمر ثلاث أنواع من الملفات: ملفات مصدرية ومكتبات متحركة (dynamic) عامة ومكتبات بناء مثل libalusus_spp.
                    يمكن تحميل أي مكتبة متحركة مهما كانت اللغة التي كتبت بها وعند تحميلها تكون كل دالّاتها العمومية متوفرة للاستخدام من داخل برنامج الأسُس، لكن ستحتاج لتعريف تلك الدوال يدوياً باستخدام الأمر `دالة` مع إضافة المبدل `@تصدير` (@expname) كما
                    هو مبين في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  اشمل "libmath.so"؛
  عرف جا: @تصدير[sin] دالة (ر: عـائم) => عـائم؛
  .
  .
  ج = جا(ز)؛
</pre>
<pre class="samplecode" dir=ltr>
  import "libmath.so";
  def sin: @expname[sin] function (f: Float) => Float;
  .
  .
  s = sin(r);
</pre>
                    يمكن اختصار الامتداد في عبارة اشمل، حيث أن الـقلب سيضيف الامتداد تلقائيًا. على سبيل المثال، يمكن اختصار:
<pre class="samplecode" dir=rtl style="text-align:right;">
  اشمل "مـتم/نـص.أسس"؛
</pre>
<pre class="samplecode" dir=ltr>
  import "Srl/String.alusus";
</pre>
                    إلى:
<pre class="samplecode" dir=rtl style="text-align:right;">
  اشمل "مـتم/نـص"؛
</pre>
<pre class="samplecode" dir=ltr>
  import "Srl/String";
</pre>
                    ويمكن أيضًا اختصار الامتداد والبادئة في أسماء المكتبات. فمثلا يمكن اختصار التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  اشمل "libmath.so"؛
</pre>
<pre class="samplecode" dir=ltr>
  import "libmath.so";
</pre>
                    إلى:
<pre class="samplecode" dir=rtl style="text-align:right;">
  اشمل "math"؛
</pre>
<pre class="samplecode" dir=ltr>
  import "math";
</pre>
                    في الحالة أعلاه فإن القلب سيحاول تحميل الملف "math.alusus" فإن لم يجد فسيحاول تحميل "libmath.so" إن كان على نظام لينكس، وإن كان على نظام ماك أو إس فسيحاول بدلاً من ذلك تحميل "libmath.dylib".<br>
                    في بعض الحالات قد تحتاج لإعطاء عدة خيارات لاسم الملف وتترك للقلب انتقاء أول خيار ينجح في تحميله. توفير عدة خيارات مفيد لدعم عدة أنظمة تشغيل بنفس الشفرة المصدرية. توفير خيارات متعددة يتم باستخدام `أو` ضمن عبارة `اشمل` كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  اشمل "libmath.so" أو "libmath.so.0"؛
</pre>
<pre class="samplecode" dir=ltr>
  import "libmath.so" or "libmath.so.0";
</pre>
                    يمكن أيضًا استخدام المؤثر `||` بدلا من `أو` في المثال أعلاه.
                </div>

                <!-- ********************************************************************** -->
                <h3 id="Process">الوحدة: الـعملية (Process)</h3>
                <hr>
                <div>
                  عند تشغيل الأسس وأثناء تنفيذ المباشر للبرنامج (أي دون بناء مسبق) فإن الأسس تعرف وحدة `الـعملية` (Process) التي تحتوي على المتغيرات العمومية التالية:
                  <p><ul>
                    <li><b>عدد_المعطيات (argCount): صحيح</b><br/>
                    عدد المعطيات الممرة لمترجم الأسس في سطر الأوامر.
                    </li>
                    <br>

                    <li><b>المعطيات (args): مؤشر[مصفوفة[مؤشر[مصفوفة[محرف]]]]</b><br/>
                    قائمة المعطيات الممرة لمترجم الأسس في سطر الأوامر.
                    </li>
                    <br>

                    <li><b>اللغة (language): مؤشر[مصفوفة[محرف]]</b><br/>
                    سلسلة محارف لوصف لغة لنظام الحالية. على سبيل المثال ar إذا كانت لغة النظام هي العربية.
                    </li>
                    <br>

                    <li><b>النظام (platform): مؤشر[مصفوفة[محرف]]</b><br/>
                    سلسلة محارف لوصف نظام التشغيل الحالي. قيمته إما أن تكون linux أو windows أو macos.
                    </li>
                    <br>
                  </ul></p>
                </div>
            </div>
        </div>
        <!--content-separator-->
        <footer class="footer">
            <hr>
            <div class="container-fluid">
                <div class="row">
                    <div class="col-sm-8 pull-left1">
                        <ul class="nav nav-pills.nav">
                            <li><strong>جميع الحقوق محفوظة لشركة الأسس للبرمجيات 2021م \ 1443هـ.</strong></li>
                        </ul>
                    </div>
                </div>
            </div>
        </footer>
    </div>
    <script src="Resources/highlight.pack.js"></script>
    <script src="Resources/index.js"></script>

</body>

</html>

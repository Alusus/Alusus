<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="rtl" lang="ar" style="height: 100%;">
<head profile="http://gmpg.org/xfn/11">
 <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

 <title>تصميم اللغة - لغة الأسُس البرمجية</title>

 <link rel="stylesheet" href="Resources/main.css">
 <link rel="stylesheet" href="Resources/highlight.default.css">

 <script src="Resources/jquery-1.10.2.min.js"></script>
 <script src="Resources/highlight.pack.js"></script>
 <script src="Resources/main.js"></script>
 <script language="javascript">
 $(document).ready(function() {
   addNumbering($('#rootdiv'), ".foldable");
 });
 </script>
</head>

<body style="background: grey; text-align:center; height:100%; padding-left: 10px; padding-right:10px;" alink="#00FFFF" link="#FFFFFF" text="#FFFFFF" vlink="#CCCCCC">
<div style="border-left: solid 1px; border-right: solid 1px; background: white; min-width: 840px; max-width:1200px; width: 100%; min-height:100%; text-align: right; margin-left:auto; margin-right:auto;">
 <div style="width: 100%; height: 100px; padding-top:10px; text-align:center;">
  <div style="float:right;"><img src="Resources/logo.gif" style="border:0;"/></div>
  <img src="Resources/title.gif" style="border:0;"/>
  <div style="padding: 10px 15px; width:120px; float:left; text-align:left;"><a style="text-decoration:none; color:black;" href="design.en.html"><b>English</b></a></div>
 </div>
 <div class="menu">
  <span class="menuItem"><a href="http://alusus.net?lang=ar">لغة الأسُس</a> &#x276f; <a href="http://alusus.net/documentation?lang=ar">الوثائق</a></span>
 </div>
 <div id='rootdiv' style="padding-top:5px; padding-left:20px; padding-right:20px; padding-bottom:35px;">
 <h1>تصميم لغة الأسُس البرمجية</h1>
 <a href='#' onclick='openAllFolds()'>إفتح الكل</a>&nbsp;&nbsp;&nbsp;<a href='#' onclick='closeAllFolds()'>أغلق الكل</a>

 <!-- ********************************************************************** -->
 <h2 class="foldable">المقدمة</h2>
 <div>
  صُممت لغة الأسُس لتكون لغة شاملة يمكن استخدامها لبناء أي برنامج كان مهما كان اختصاصه أو بيئة عمله أو طريقة تنفيذه، وهذه الشمولية تتطلب تصميم قواعد اللغة بناءاً على معايير فلسفية بدل المعايير العملية المبنية على بيئة عمل أو مجال محدد، وجعلها لغة قابلة للتطوير من قبل المستخدم أو المجتمع بدلاً من حصر عملية التطوير في فريق محدد، إضافة إلى تمكين المبرمج من الوصول إلى المترجم نفسه والتحكم فيه. كذلك فإن عملية التطوير يجب أن تكون ممكنة دون الحاجة لإعادة بناء المترجم. تصميم اللغة يعتمد على المفاهيم التالية:
  
  <h3>مفهوم لغة الأسُس لبرمجيات الحاسوب</h3>
  لغة الأسُس تعرّف برنامج الحاسوب تعريفاً لا يرتبط بطبيعة عمل البرنامج أو بيئته التنفيذية، وإنما تعرفه على أنه مجموعة من الجمل تتكون كل منها من حدّ أو مجموعة من الحدود وكل حدّ عبارة عن قيمة ثابتة أو اسم متغير أو تركيب أو أمر أو جملة أخرى أو مجموعة من الجمل. بُنيت على هذا التعريف وبصورته الشمولية قواعد أساسية للغة الأسُس وجُعلت هذه القواعد ديناميكية وأضيفت للغة الأسُس إمكانية إنشاء قواعد مشتقة منها وهو ما يجعل قواعد اللغة قابلة للتوسيع دون الإضرار بالشكل العام لقواعدها ودون التسبب بغموض الإعراب.
  
  <h3>نظام ترجمة مفتوح ومرن ولامركزي</h3>
  بدل إنتاج مترجم مغلق يفهم أنماط البرمجة المرجوّة وكيفية إنشاء الشفرة التنفيذية، استبدلت لغة الأسُس هذا التصميم بتصميم مختلف يجعل الترجمة تتم بنظام مفتوح متعدد الأجزاء مع وجود جزء مركزي يعمل عملاً إدارياً ويوفّر الأسُس التي تُبنى عليها الأجزاء الأخرى. يتيح هذا الأسلوب توسيع اللغة وتطوير عملية الترجمة عن طريق استبدال أجزاء بأخرى أو إضافة أجزاء جديدة. هذا النظام صُمم بأسلوب مفتوح يتيح لأي مبرمج الوصول إلى الوحدات والبيانات الداخلية لنظام الترجمة لتطوير وحدات ترجمة جديدة وهو ما يجعل اللغة قابلة للتطوير من قبل مجتمع المبرمجين بدل أن تكون عملية التطوير حصراً على مجموعة محددة. يتيح هذا التصميم أيضاً إمكانية تطوير اللغة آنياً على عدة جبهات من قبل فرق مختلفة. الشكل التالي يوضح الفرق بين أسلوب الترجمة التقليدي وأسلوب الترجمة في لغة الأسُس:
  <p align="middle"><img src="design.resources/compilation_method_comparison.ar.gif"/></p>
 </div>

 <!-- ********************************************************************** -->
 <h2 class="foldable">التصميم العام</h2>
 <div>
  <h3>نظام الترجمة</h3>
  بدل الاعتماد على مترجم أحادي (monolithic) تعتمد الترجمة في لغة الأسُس على نظام ترجمة مركّب ولا مركزي ينقسم إلى:
  <ul>
   <li><b>القلب:</b> وهو الجزء المركزي في لغة الأسُس. يُعرّف القلب القواعدَ الأساسية ويعمل على تحليل الشفرة المصدرية وتنسيق عمل مكتبات البناء.</li>
   <li><b>مكتبات البناء:</b> تعمل مكتبات البناء على تعريف القواعد المخصصة وتحويل بيانات التحليل إلى شفرة تنفيذية. هذه المكتبات تُربط بالقلب ديناميكياً ويُمكن للقلب تحميل عدد غير محدد من هذه المكتبات. تحميل هذه المكتبات يتم عبر أوامر في الشفرة المصدرية المراد ترجمتها.</li>
  </ul>
  الشكل التالي يوضح سيل البيانات من الشفرة المصدرية حتى الشفرة التنفيذية:
  <p align="middle"><img src="design.resources/compilation_flow.ar.gif"/></p>
  مكتبات البناء ليست سوى مكتبات ديناميكية تحتوي على أصناف وتعريفات متعلقة بالقواعد وعملية الترجمة ويتم تحميلها بنفس الطريقة التي يتم فيها تحميل مكتبات أخرى، أي باستخدام الأمر import داخل الشفرة المصدرية نفسها التي يُراد ترجمتها، وبذلك يكون كل مشروع قادراً على اختيار الصفات اللغوية التي يحتاجها.<br/>
  يحتوي القلب على مستودع ديناميكي للتعريفات القواعدية يمكن لأي مكتبة بناء أن تضيف أو تعدل في محتواه لإضافة قواعدها الخاصة أو معالجات بنائها الخاصة. يحتوي القلب أيضاً على مستودع عام ومركزي للتعريفات يستخدم من قبل مكتبات البناء لتخزين ما ينتج من عملية البناء حسب حاجتها ما يجعل هذه التعريفات متوفرة بشكل عمومي لجميع المكتبات ومتوفرة أيضاً للشفرة المصدرية نفسها أيضاً.<br/>
   الشكل التالي يوضح العلاقة بين الأجزاء المختلفة في عملية الترجمة:
  <p align="middle"><img src="design.resources/class_diagram.ar.gif"/></p>
  يمكن أيضاً تعريف قواعد إضافية ومعالجات بناء داخل الشفرة المصدرية نفسها التي يتم ترجمتها، أي يستطيع البرنامج أن يعرف قواعده الخاصة شرط أن تسبق هذه التعريفات استخدامَها داخل الشفرة المصدرية.

  <h3>قواعد لغة الأسُس</h3>
  قواعد لغة الأسُس تتصف بما يلي:
  <ul>
   <li>قواعد مبنية على البيانات (data driven): أي أن بالإمكان التحكم بالتعريفات القواعدية عن طريق متغيرات.</li>
   <li>قواعد متحركة (ديناميكية): قواعد لغة الأسُس متحركة وليست ثابتة، بمعنى أن قواعد اللغة قابلة للإضافة أو التعديل أثناء الترجمة.</li>
   <li>الإشتقاق القواعدي: يمكن في لغة الأسُس اشتقاق قواعد من قواعد أخرى باستخدام التوريث القواعدي الذي يسمح للقاعدة الوارثة أن ترث صفات القاعدة المورِّثة وتعدل ما تشاء منها. تمكّن هذه الخاصية المبرمجين من إنشاء قواعد جديدة مبنية على غيرها وتمكّن أيضا من إنشاء قوالب قواعدية.</li>
   <li>القوالب (templates): تحتوي قواعد اللغة على قوالب جاهزة يمكن للمبرمجين استخدامها لإضافة قواعدهم الخاصة. وجود هذه القوالب ضروري لضمان تناسق القواعد.</li>
   <li>التصميم الحزمي للقواعد (modular): تحتوي قواعد لغة الأسُس إمكانية إنشاء حزم من القواعد لتجميع القواعد المترابطة في حزمة واحدة وتسهيل الإشتقاق. على سبيل المثال، كل القواعد المرتبطة بالتراكيب مجموعة في حزمة واحدة يسهل الإشتقاق منها لإنشاء تراكيب مخصصة.</li>
  </ul>
  توفر هذه الخواص في قواعد لغة الأسُس الإمكانية لإنشاء قواعد أساسية شمولية تُبنى عليها قواعد اللغة الأخرى بما يَضمن تناسق القواعد المُنشأة من قبل الفرق المستقلة العاملة على تطوير اللغة. <b>القواعد الأساسية</b> في لغة الأسُس مُبسّطة وشمولية وهي تطابق التعريف الشامل لبرنامج الحاسوب كما يلي:
  <ul>
   <li><b>البرنامج:</b> هو مجموعة من الجمل.</li>
   <li><b>الجملة:</b> تتكون من حد أو مجموعة متتالية من الحدود.</li>
   <li><b>الحد:</b> أما قيمة ثابتة أو اسم متغير أو تركيب أو أمر أو جملة أو مجموعة من الجمل.</li>
   <li><b>الأمر:</b> يتكون من كلمة متبوعة اختياريا بحد أو مجموعة متتالية من الحدود.</li>
   <li><b>التركيب:</b> يتكون من حد واحد، أو ترابط هرمي من الحدود والمؤثرات.</li>
  </ul>
بالإضافة إلى الترتيب الهرمي أعلاه، تحتوي قواعد لغة الأسُس على <b>مبدّلات</b> وهي إضافات يمكن أن تطبّق على أي جزء من الأجزاء المذكورة أعلاه. تستخدم المبدّلات لإضافة بيانات وصفية (metadata) لأي جزء من أجزاء البرنامج.
  <p>
تلاحظ من التعريف أعلاه أن القواعد الأساسية لا علاقة لها بطبيعة البرنامج أو البيئة التي يعمل بها، فهي لا تربط اللغة بمجال محدد بل تتركها مفتوحة على كل المجالات البرمجية. القلب لا يفهم إلا مجموعة بسيطة من القواعد المخصصة، منها أوامر تحميل المكتبات (import). عند تحميل مكتبات البناء تغذي هذه المكتبات القلب بقواعدها المشتقة من القواعد الأساسية وتبقى مسؤولة عن معالجة البيانات المُعربة الناتجة عن تلك القواعد. وتلقائيا يقوم القلب بربط القواعد الجديدة بتلك المكتبات ويقوم باستدعائها أثناء الإعراب كلما صادف تلك القواعد. ويستطيع القلب تحميل عدد غير محدد من تلك المكتبات ويقوم بمهمة التنسيق بينها.
  </p>
 </div>

 <!-- ********************************************************************** -->
 <h2 class="foldable">تقنيات القواعد والتحليل</h2>
 <div>
  تعتمد قواعد لغة الأسُس، بالإضافة إلى الأساليب التقليدية في كتابة القواعد وإنشاء المعرِبات، على التقنيات التالية:
  <h3>اعتماد البيانات في التعريفات القواعدية</h3>
  يمكن للتعريفات القواعدية أن تعتمد على البيانات عن طريق متغيرات يتم استقبالها كمعطيات في التعريف القواعدي أو متغيرات عامة (global). المثال التالي يبيّن تعريف أمر مع ترك الكلمة التمييزية (keyword) متغيرة:
<pre dir=ltr class="code">
SubCmd (kwd:string) : kwd Expression.
IfCommand : SubCmd("if") Statement.
WhileCommand : SubCmd("while") Statement.
</pre>
  في المثال التوضيحي أعلاه، تجد أن تعريف SubCmd يستقبل سلسلة محارف كمعطى ويستعملها كثابت في التعريف، وتم استخدام هذا التعريف لتعريف أمري if و while.
  الأمر لا يقتصر على استخدام المتغيرات كثوابت في التعريف القواعدي، بل يتعداها إلى امكانية استخدام المصفوفات وتطبيق العمليات القواعدية على عناصر تلك المصفوفات. على سبيل المثال:
<pre dir=ltr class="code">
BinaryOperation (kwds:list[string]) : Operand (kwds[0] | kwds[1] | ...) Operand.
LogicalOperation : BinaryOperation(["and", "or", "xor"]).
MathOperation : BinaryOperation(["+", "-", "*", "/"]).
</pre>
  طريقة استخدام البيانات غير محددة، بل مفتوحة على كل الاحتمالات كما في استخدام البيانات في لغات البرمجة. على سبيل المثال يمكن تطبيق عناصر المصفوفة على قالب معين وتطبيق العمليات القواعدية عليها كما في المثال:
<pre dir=ltr class="code">
BinaryOperation (kwds:list[string]) : Operand (Command(kwds[0]) Command(kwds[1]) ...).
</pre>

  <h3>التصميم الحزمي للقواعد</h3>
  بالأمكان تجميع التعريفات القواعدية في حزم بطريقة مشابهة للبرمجة كائنية المنحى. في المثال التالي نقوم بجمع التعريفات المتعلقة بالتراكيب في حزمة واحدة:
<pre dir=ltr class="code">
Expression : {
  Add (kwds:=["+","-"]) : Multiply [(kwds[0] | kwds[1] | ...) Add].
  Multiply (kwds:=["*","/"]) : Operand [(kwds[0] | kwds[1] | ...) Multiply].
  Operand : Identifier | Literal.
}.
</pre>
  بالإمكان تعريف حزم داخل أخرى وبالإمكان لقواعد داخل حزمة معينة الإشارة إلى قواعد خارجها والعكس جائز أيضاً.

  <h3>التوريث القواعدي</h3>
  يمكن في قواعد لغة الأسُس استخدام التوريث لاشتقاق قاعدة من قاعدة أخرى. كما هو حال التوريث في البرمجة كائنية المنحى، فإن التوريث في قواعد الأسُس ينسخ صفات القاعدة المورِّثة إلى القاعدة الوارثة والتي بدورها تستطيع استبدال بعض هذه الصفات. على سبيل المثال، لو كان عندنا القاعدة التالية:
<pre dir=ltr class="code">
LogicalOperation (kwds:=["and", "or"]) : Operand (kwds[0] | kwds[1] | ...) Operand.
</pre>
  فيمكن اشتقاق قاعدة أخرى منها تعرف مزيداً من الكلمات التمييزية، كما يلي:
<pre dir=ltr class="code">
MyLogicalOperation -&gt; LogicalOperation (
  kwds := ["and", "or", "&&", "||"]
).
</pre>
  الاشتقاق جائز أيضاً مع الحزم، أي يمكن اشتقاق حزمة من حزمة أخرى. في حالة الحزم فإن عناصر الحزمة المورِّثة ستنتقل كاملة إلى الحزمة الوارثة التي ستستطيع استبدال بعض العناصر أو إضافة عناصر أخرى. في المثال التالي نقوم بتعريف حزمة تشتق من حزمة أخرى وتغيّر أحدى القواعد فيها:
<pre dir=ltr class="code">
MyExpression -&gt; Expression {
  Operand : Identifier | Literal | "(" Add ")".
}.
</pre>
  
  <h3>الإعراب متعدد الأبعاد</h3>
  الإعراب متعدّد الأبعاد يعني إمكانية تعريف قواعد معينة وتمييزها ليتم إعرابها بشكل موازٍ لعملية الإعراب الرئيسية. بمعنى آخر، يمكن للمُعرِب عند كل خطوة من خطوات الإعراب الرئيسي الخروج منه لإعراب القاعدة الموازية ومن ثم العودة إلى النقطة التي كان فيها من الإعراب الرئيسي. الشكل التالي يوضح هذه العملية.
  <p align="middle"><img src="design.resources/multidimensional_parsing.ar.gif" /></p>
  يُستخدم هذا الأسلوب لتيسير تعريف القواعد التي قد تظهر في أي نقطة من البرنامج مثل المبدّلات على سبيل المثال. المثال التالي يوضّح الفائدة من هذا الأسلوب:
<pre dir=ltr class="code">
DefStatement : "def" Identifier ":" Identifier.
ParallelStatement : "@" Identifier.
</pre>
  بتعريف ParallelStatement كقاعدة موازية تكون التعريفات التالية كلها جائزة:
<pre dir=ltr class="code">
@myattribute def myvar : mytype;
def @myattribute myvar : mytype;
def myvar : @myattribute mytype;
</pre>
  بدون خاصية الإعراب متعدّد الأبعاد سنحتاج لتعريف DefStatement كما يلي:
<pre dir=ltr class="code">
DefStatement : [ParallelStatement] "def" [ParallelStatement] Identifier ":" [ParallelStatement] Identifier.
</pre>
 </div>

 <!-- ********************************************************************** -->
 <h2 class="foldable">مبادئ تصميمية</h2>
 <div>
  هناك مبادئ عامة وضعت بعين الإعتبار في تصميم وتنفيذ لغة الأسُس، ويُطلب من مطوري مكتبات لغة الأسُس مراعاتها. في هذه القائمة كلمة مبرمج تشير إلى مستخدم اللغة، وليس إلى مطورها.
  <ul>
    <li>إستقلال القواعد عن السياق: يجب على قواعد اللغة أن تكون مستقلة عن سياق البرنامج، بمعنى آخر يجب على المعرِب (parser) أن يتمكن من إعراب الشفرة المصدرية دون الحاجة لمعرفة ما تعنيه تلك الشفرة أو بعض مفرداتها.</li>
    <li>التعبير المباشر عن الهدف: يجب على قواعد اللغة أن تمكن المبرمج من سلوك طريق مباشر للوصول لغايته، بمعنى آخر يجب تمكين المبرمج من كتابة برنامجه تبعا لوظيفته وليس تبعا للطريقة التي سيُترجم بها.</li>
    <li>تجنب الزوائد القواعدية: على سبيل المثال لا حاجة لفرض استخدام الأقواس إن كان بالإمكان تحليل الشفرة دون أقواس.</li>
    <li>تناسق القواعد والتصميم: يجب الحفاظ على التناسق في القواعد وفي تصميم المكتبات.</li>
    <li>منطقية القواعد على حساب الجمالية أو العرف السائد: لسنا بحاجة للإلتزام بما هو شائع بين لغات البرمجة، فالحفاظ على منطقية القواعد أهم من جماليتها أو عادات المبرمجين.</li>
    <li>ليس هناك معايير قياسية في تصميم لغات البرمجة، لكن هناك معايير قياسية في كتابة الرياضيات سائدة منذ مئات السنين، لذا فمشابهة المعايير الرياضية أولى شرط عدم الإخلال بمنطقية القواعد. على سبيل المثال الدوال في الرياضيات تكتب باستخدام الأقواس الاعتيادية وبالتالي فالدوال في لغة الأسُس تكتب أيضاً باستخدام الاقواس الاعتيادية.</li>
    <li>تقليص الإعتماد على قواعد جديدة: كلما كان تصميم القواعد أكثر شمولية، قلت الحاجة لتصميم قواعد جديدة.</li>
    <li>تعامد الخصائص والتصميم الحزمي: الحفاظ قدر الإمكان على تعامد الخصائص (orthogonality) والتصميم الحزمي (modular design).</li>
    <li>تمكين المبرمج من العمل على كافة المستويات بدءاً من التحكم المباشر بالعتاد وانتهاءاً بأعلى مستويات البرمجة.</li>
    <li>الحفاظ على مستوى واحد داخل المكتبة الواحدة: عند تصميم المكتبات المعيارية يجب تجنب الخلط بين المستويات داخل المكتبة الواحدة.</li>
    <li>دعم الخواص بأخفض مستوى ممكن: كلما كانت الخاصية متوفرة بمستوى منخفض أكثر كلما توسع نطاق توفرها.</li>
    <li>تمكين التحكم المركزي بأمن الخواص: انفتاح اللغة على كل شيء يولد الحاجة للتحكم مركزيا بما يُسمح للفريق باستخدامه. على سبيل المثال يستطيع مدير الفريق أن يمنع استخدام المؤشرات في مجال محدد أو يحصر مجالاً معيناً على استخدام مكتبات معينة دون غيرها.</li>  
   <li>تجنب اتخاذ خطوات وقرارات نيابة عن المبرمج: يجب أن يعلم المبرمج كيف سيتم التعامل مع برنامجه من قبل نظام الترجمة. على سبيل المثال، من غير الملائم أن تقرر مكتبة البناء أسلوب إدارة الذاكرة دون إعطاء المبرمج القدرة على التحكم بذلك القرار.</li>
   <li>تجنب الحدود المصطنعة: على سبيل المثال، لا تحرم المبرمج إمكانية استخدام المؤشرات المباشرة في سياق معين إذا كان استخدامها ممكناً في ذلك السياق. حرمان المبرمج من خاصية معينة فقط لأن هذه الخاصية قد يُساء استخدامها عذر غير مقبول.</li>
  </ul>
 </div>

 <!-- ********************************************************************** -->
 <h2 class="foldable">المكتبات المعيارية</h2>
 <div>
  تنقسم المكتبات المعيارية إلى قسمين:
  <ul>
   <li>مكتبات البناء: وهي مجموعة من مكتبات البناء لدعم أنماط أساسية من البرمجة.</li>
   <li>مكتبات تنفيذية: وهي المكتبات التي تحتوي على مجموعة دالات وأصناف أساسية يستعملها البرنامج أثناء التنفيذ مثل مكتبات الدالات الرياضية أو مكتبات التعامل مع سلاسل المحارف.</li>
  </ul>
  تركّز المكتبات المعيارية على دعم مجموعة أساسية من الخواص البرمجية الأكثر شيوعاً في التطبيقات البرمجية المختلفة، ويُترك للمجتمع إنشاء مكتبات للخواص الأقل شيوعاً أو الإستثنائية. الخواص التي ستدعمها المكتبات المعيارية:
  <ul>
   <li>أنماط البرمجة
    <ul>
     <li>البرمجة كائنية المنحى (object-oriented programming) بكافة خواصها المعهودة.</li>
     <li>البرمجة الإجرائية (procedural programming).</li>
     <li>البرمجة الوظيفية (functional programming).</li>
     <li>البرمجة جانبية المنحى (aspect-oriented programming).</li>
     <li>تعدد الأنماط البرمجية داخل البرنامج الواحد.</li>
    </ul>
   </li>
   <li>مستويات البرمجة. توفر المكتبات المعيارية ثلاثة مستويات من البرمجة:
    <ul>
     <li>المستوى الأول، وهو أكثرها انخفاضا. يوفر هذا المستوى الخاصيات الأساسية للغة مثل إيعازات الحلقات والجمل الشرطية والتعريفات وغيرها.</li>
     <li>المستوى الثاني. يوفر هذا المستوى مكتبات التعامل منخفض المستوى مثل التعامل مع سلاسل المحارف والمكتبات الرياضية والتعامل مع النظام وغيرها.</li>
     <li>المستوى الثالث. يوفر هذا المستوى مكتبات التعامل عالي المستوى مثل التعامل المُيسًَر مع الذاكرة والتنفيذ المتوازي ومكتبات التعامل مع قواعد البيانات وغيرها.</li>
    </ul>
   </li>
   <li>كل الأصناف من المعلومات تعامَل معاملة الكائنات. على سبيل المثال، يمكن اشتقاق كائنات جديدة من الأعداد الصحيحة (int).</li>
   <li>الدالّات متعددة المخارج والمداخل.</li>
   <li>توزيع العمليات. أيْ تنفيذ عملية معينة على أكثر من كائن دون تكرار كتابة تلك العملية، أو تنفيذ أكثر من عملية على كائن معين دون تكرار كتابة ذلك الكائن.</li>
   <li>القوالب (templates).</li>
   <li>التنفيذ المتوازي: ستوفر المكتبات المعيارية خواصاً تيسر التنفيذ المتوازي.
    <ul>
     <li>أوامر تسهل التفرع داخل الدالة الواحدة أو استدعاء دالات أخرى بشكل متوازي.</li>
     <li>التفرع التلقائي عند الحلقات المعلّمة للتنفيذ المتوازي.</li>
     <li>التفرع التلقائي عند الدالّات المعلمة للتنفيذ المتوازي.</li>
     <li>التحكم التلقائي بعدد السلاسل التنفيذية لضمان سرعة التنفيذ القصوى.</li>
     <li>المزامنة التلقائية للموارد المعلّمة بتلك الخاصية.</li>
     <li>أوامر للتراسل بين السلاسل التنفيذية.</li>
    </ul>
   </li>
   <li>العمليات متعددة البيانات (single instruction multiple data).</li>
   <li>التعامل مع الإستثناءات (exception handling).</li>
   <li>المبدّلات: إمكانية تعريف وحدات برمجية يمكن تطبيقها أو إضافتها على وحدات برمجية أخرى لتغير من خواصّها. هذه الخاصية تمكن البرمجة جانبية المنحى إلى جانب إمكانيات أخرى.</li>
   <li>الكائنات المتحركة (الدينامية). وتوفر المكتبات امكانية استخدام الكائنات الدينامية جنباً إلى جنب مع الكائنات الساكنة.</li>
   <li>برمجة الزبون والخادم (client-server development).</li>
   <li>التنفيذ أثناء الترجمة: تمكن هذه الخاصية تنفيذ الأوامر أثناء الترجمة للتحكم بالترجمة نفسها وماتنتجها.</li>
   <li>توفير معلومات التعريفات أثناء التنفيذ اختياريا.</li>
   <li>حرية الإختيار بين التنفيذ التلقائي (interpretation)، أو الترجمة إلى شفرة وسطية أو الترجمة مباشرة إلى لغة الآلة، مع حرية الدمج بين هذه الخيارات وحرية اختيار الآلة التي يُترجم لها البرنامج.</li>
  </ul>
 </div>
 
 <!-- ********************************************************************** -->
 <h2 class="foldable">نظرة على القواعد</h2>
 <div>
 فيما يلي نماذج لقواعد اللغة المُضمّنة في المكتبات المعيارية. هذه النماذج تمثل نبذة مختصرة ولا تتضمن كل تفاصيل القواعد.
 <h3>التراكيب</h3>
 تتكون التراكيب من حدود تربطها مؤثرات (operators) بشكل مشابه للّغات الشائعة الأخرى. وفيما يلي قائمة بأهم المؤثرات المتوفرة:<br/>
 مؤثر النفي: ^<br/>
 مؤثر أو: |<br/>
 مؤثر أو حصرية (xor): !<br/>
 مؤثر و: &<br/>
 العمليات الحسابية: +، -، *، /<br/>
 العمليات البِتّية (bitwise): &، |، !، ^<br/>
 العمليات المنطقية: &&، ||، !!، ^^<br/>
 المقارنات: <، >، =>، =<، =<br/>
 التعيين: =:<br/>
 العمليات التعيينية: =+، =-، =*، =/، =|، =&، =!، =^<br/>
 القوائم تُفصل بالفاصلة. على سبيل المثال: a,b,c<br/>
 تجميع الحدود يتم باستخدام الأقواس الإعتيادية: ()<br/>

 <h3>الحلقات</h3>
<pre dir=ltr class="code">
 For: "for" Initial_Expression "," Condition_Expression "," Update_Expression (Statement|Block).
 While: "while" Expression (Statement|Block).
 Do-While: "do" (Statement|Block) "while" Expression.
</pre>

 <h3>الجمل الشرطية</h3>
<pre dir=ltr class="code">
 "if" Expression (Statement|Block) ["else" (Statement|Block)].
</pre>

 <h3>التعريفات</h3>
 كل التعريفات في اللغة تتم باستخدام أمر def بما في ذلك تعريف متغيرات أو ثوابت أو دالّات أو أصناف أو غيرها. والصيغة العامة كالتالي:
 <pre dir=ltr class="code">"def" name ":" body.</pre>
 قيمة body يمكن أن تكون دالّة أو صنفا أو مجالا أو أسم صنف أو غيرها وذلك موضح فيما يلي:<br/>
 تعريف متغير:
 <pre dir=ltr class="code">"def" name ":" type.</pre>
 تعريف ثابت:
 <pre dir=ltr class="code">"def" name ":" @const type.</pre>
 تعريف دالة:
 <pre dir=ltr class="code">"def" name ":" "function" "(" Input_List ")" "=>" "(" Output_List ")" Block.</pre>
 تعريف صنف:
 <pre dir=ltr class="code">"def" name ":" "class" [Inheritance_Specifier] Block.</pre>
 تعريف مجال:
 <pre dir=ltr class="code">"def" name ":" "namespace" Block.</pre>
 ويستخدم إيعاز def أيضا لكافة التعريفات الأخرى ومن بينها المصفوفات والمؤشرات المبينة أدناه.

 <h3>المصفوفات</h3>
 تعرّف المصفوفات باستخدام أمر def وبالشكل التالي:
 <pre dir=ltr class="code">"def" name ":" "array" "[" type, number "]".</pre>
 ولتحديد حجم المصفوفة ديناميكياً تستخدم الصيغة التالية:
<pre dir=ltr class="code">
 "def" name ":" "array" "[" type "]" "(" number ")".
 "def" name ":=" "array" "[" type "]" "~new" "(" number ")".
</pre>
 استخدام المصفوفات:
 <pre dir=ltr class="code">name "(" number ")".</pre>

 <h3>المؤشرات</h3>
 تعّرف المؤشرات باستخدام أمر def أيضا وبالشكل التالي:
 <pre dir=ltr class="code">"def" name ":" "ptr" "[" type "]".</pre>
 وللدخول إلى الموقع الموُشَّر يستخدم مؤثر cnt~ بعد اسم المؤشر:
 <pre dir=ltr class="code">name "~cnt".</pre>
 وللحصول على موقع متغير معين يستخدم مؤثر ptr~ بعد اسم المتغير:
 <pre dir=ltr class="code">name "~ptr".</pre>

 <h3>الدمج في التعريفات</h3>
 يمكن أيضا الدمج بين التعريفات باستخدام def. مثلا يمكن تعريف مؤشر على مصفوفة، أو مؤشر على دالة, أو مصفوفة من المؤشرات، إلى أخره. مثلا تعريف مصفوفة من مؤشرات الدالّات يتم بالشكل التالي:
 <pre dir=ltr class="code">"def" name ":" "array" "[" "ptr" "[" "function" "(" Params ")" "]" "]".</pre>

 <h3>المبدّلات</h3>
 يمكن للمبدّلات أن تظهر في أي مكان في البرنامج وليس بالضرورة في بداية الجملة. وتعرّف المبدّلات بهذا الشكل:
 <pre dir=ltr class="code">"@" name [ Expression ].</pre>

 <h3>الأقواس الهلالية والأقواس المعقوفة</h3>
 تستخدم الأقواس الهلالية في الأمور التي تُعالج أثناء تنفيذ البرنامج مثل جمع الحدود داخل التراكيب أو إرسال المدخلات إلى الدالّات، بينما تستخدم الأقواس المعقوفة في الأمور التي تُعالج أثناء الترجمة مثل تحديد نوع المؤشر أو المصفوفة. بمعنى آخر، إن كانت المعلومة مرسلةً إلى المترجم نفسه تُسخدم الأقواس المعقوفة، وإلا فالأقواس الهلالية.

 <h3>الأقواس الحاصرة {}</h3>
 تستخدم الأقواس الحاصرة لحصر مجموعة من الجمل في كتلة واحدة. وتستخدم هذه الكتل في جواب الجمل الشرطية على سبيل المثال أو في متن الدالّات أو الأصناف أو المجالات.
<pre dir=ltr class="code">
 Block: "{" [ Statement_List ] "}".
 Statement_List: Statement { ";" [Statement] }.
</pre>

 <h3>الفصل بين الجمل</h3>
 تستخدم الفاصلة المنقوطة للفصل بين الجمل بطريقة مشابهة للفاصلة الإعتيادية التي تفصل بين الحدود داخل القوائم. بمعنى آخر فإن الفاصلة المنقوطة ليست جزءاً من الجملة ويُمكن إهمالها إن لم يأت بعدها جملة أخرى.
 
 <h3>المنظق في بعض الخيارات النحوية</h3>
 <ul>
  <li>أقواس الدالّات:أُستخدمت الأقواس الاعتيادية مع الدالّات في الرياضيات منذ القدم، لذا تم الالتزام بذات الاسلوب مع دالّات لغة الأسُس.</li>
  <li>معطيات الأوامر: معطيات الأوامر (مثل فعل الشرط في الجمل الشرطية) تخلوا من الأقواس ببساطة لأنها لا حاجة لها من منظور إعرابي لذا فإن إضافتها لا معنى له.</li>
  <li>علامة التعيين: أُستخدم لتعيين قيمة جديدة في متغير الرمز := وذلك لأن الرمز = رياضياً أقرب في معناه إلى المقارنة منه إلى التعيين. كذلك فإن الرمز := ينسجم مع += و -= وغيرها من رموز التعيين بينما ينسجم الرمز = مع رموز المقارنة الأخرى مثل >= و <= وغيرها.</li>
  <li>يُفضل البعض البرامج بدون علامة الفصل بين الجمل (;) ولكن إن كان الأمر صحيحاً فلماذا لدينا تنقيط في اللغات البشرية؟</li>
  <li>رمز النفي ^ أستخدم بدل ! لأن الأخير يُستخدم لتمثيل العملية xor لقربه من رمز | الذي يمثل or.</li>
  <li>عوملت الكلمات الترميزية public و private وما شابههما كمبدّلات (أي ببدئهم بالرمز @) لأنهم ببساطة ليسوا أكثر من معلومات وصفية يستخدمها نظام الترجمة لكنها ليست عمليات تؤثر على طريقة تنفيذ البرنامج.</li>
  <li>استخدمت الكلمة الترميزية def لتعريف الدالّات والفئات كي نتمكن من حصر كامل التعريف في الجهة التي تلي النقطتين بدل أن يكون اسم الدالة أو الفئة في وسط التعريف. يساعد هذا الأمر على تيسير فهم التعريفات خصوصاً مع التعريفات المركبة مثل تعريف مؤشر إلى دالّة أو مصفوفة مؤشرات إلى دالّات.</li>
  <li>استخدمت الأقواس الهلالية للولوج إلى عناصر المصفوفة بدل الأقواس المعقوفة لأن الأخيرة تستخدم لمعطيات الترجمة. ولنفس السبب استخدمت الأقواس الاعتيادية لتحديد حجم المصفوفة ديناميكياً بينما استخدمت الأقواس المعقوفة لتحديد نوع المصفوفة وهو ما يندرج ضمن معطيات الترجمة.</li>
 </ul>
 </div>
 
 <!-- ********************************************************************** -->
 <h2 class="foldable">أمثلة</h2>
 <div>
  بعض هذه الأمثلة مُنجزٌ فعلاً مثل برنامج الترحيب وبرنامج حساب المضروب، والبعض الآخر سيُنجز في إصدارات لاحقة مثل تعريف الفئات.
<pre dir=ltr class="samplecode">
import "System";

def HelloWorld : namespace
{
  def main : function
  {
    print("Hello World!");
    return 0
  }
}
</pre>
<br/>
<pre dir=ltr class="samplecode">
import "System";

def Factorial : namespace
{
  def factorial : function (i:int)=>(int)
  {
    if i = 0 return 1 else return i * factorial(i-1)
  };
  
  def main : function
  {
    print("Factorial of %d is %d", 5, factorial(5));
    return 0
  }
}
</pre>
<br/>
<pre dir=ltr class="samplecode">
import "System";

def While : namespace
{
  def main : function
  {
    def i : int := 1;
    while i < 10 {
      print("%d\n", i);
      ++i;
    };
    return 0
  }
}
</pre>
<br/>
<pre dir=ltr class="samplecode">
import "System";

def Arrays : namespace
{
  def main : function
  {
    def a : array[int](10);
    for i:int:=0, i<10, ++i a(i) := i;
    for i:int:=0, i<10, ++i print("%d\n", a(i));
    return 0
  }
}
</pre>
<br/>
<pre dir=ltr class="samplecode">
import "System";

def Pointers : namespace
{
  def main : function
  {
    def p : ptr[int], i : int;
    i := 10;
    p := i~ptr;
    print("%d\n", p);     // prints the address of i.
    print("%d\n", p~cnt); // prints the value of i.
    return 0
  }
}
</pre>
<br/>
<pre dir=ltr class="samplecode">
import "System";

def Casting : namespace
{
  def main : function
  {
    def i : int, f : float;
    i := 10;
    // Treat the bits of i as a floating point number by doing this:
    // Get the pointer of i,
    // then cast the pointer to a pointer of float,
    // then take the contents of that float pointer.
    f = i~ptr~cast[ptr[float]]~cnt;
    print("%f\n", f);
    return 0
  }
}
</pre>
<br/>
<pre dir=ltr class="samplecode">
import "System";

def ClassDefinition : namespace
{
  def BaseClass : class
  {
    @private def i : int;
    @private def j : int;
    @public def constructor : function (a:int, b:int)
    {
      this.i := a;
      this.j := b;
    };
    @public def getI : function ()=>(int) { return this.i };
    @public def getJ : function ()=>(int) { return this.j }
  };
  
  def ChildClass : class inherits BaseClass
  {
    @private def k : int;
    @public def constructor : function (a:int, b:int, c:int)
    {
      parent.constructor(a, b);
      this.k := c
    };
    @public def getK : function ()=>(int) { return this.j }
  }
}
</pre>
 </div>

 </div>
 <div style="border-top: solid 1px; text-align: right; font-size:90%; padding-left:20px; padding-right:20px; padding-bottom:10px;">
  <p>جميع الحقوق محفوظة لـ <a href="http://sarmad-khalid.info/" style="color:black;" target="__blank">سرمد خالد عبداللّه</a> 2014م \ 1435هـ.<br/>
نُشر هذا الملف برخصة الأسُس العامة (Alusus Public License)، الإصدار 1.0، والمضمّنة مع هذا الملف
والمتوفرة أيضاً على الرابط <a style="white-space:nowrap;" href="http://alusus.net/alusus_license_1_0">http://alusus.net/alusus_license_1_0</a>. يرجى قراءة الرخصة للتعرف على شروط الاستخدام والنسخ.</p>
 </div>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="rtl" lang="ar" style="height: 100%;">
<head>
 <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

 <title>معايير اللغة - لغة الأسُس البرمجية</title>

 <link rel="stylesheet" href="Resources/highlight.default.css">
 <link rel="stylesheet" href="Resources/main.css">
 <style>
  .kwd { color:blue; }
  .dict { border:0; }
  .dict tr td:first-child { font-weight:bold; padding-left:20px; padding-right:20px; }
  .dict tr th:first-child { font-weight:bold; padding-left:20px; padding-right:20px; }
  .dict tr td+td+td { padding-right:20px; }
  .dict tr th+th+th { padding-right:20px; }
  .dict2 { border:0; }
  .dict2 tr td:first-child { padding-left:20px; padding-right:20px; }
  .dict2 tr td+td { font-weight:bold; }
  .bilingual tr td+td { text-align:left; }
 </style>

 <script src="Resources/jquery-1.10.2.min.js"></script>
 <script src="Resources/highlight.pack.js"></script>
 <script src="Resources/main.js"></script>
 <script language="javascript">
 $(document).ready(function() {
   addNumbering($('#rootdiv'), ".numbering");
 });
 </script>
</head>
<body style="background: grey; text-align:center; height:100%; padding-left: 10px; padding-right:10px;" alink="#00FFFF" link="#FFFFFF" text="#FFFFFF" vlink="#CCCCCC">
<div style="border-left: solid 1px; border-right: solid 1px; background: white; min-width: 840px; max-width:1200px; width: 100%; min-height:100%; text-align: right; margin-left:auto; margin-right:auto;">
 <div style="width: 100%; height: 100px; padding-top:10px; text-align:center;">
  <div style="float:right;"><img src="Resources/logo.gif" style="border:0;"/></div>
  <img src="Resources/title.gif" style="border:0;"/>
  <div style="padding: 10px 15px; width:120px; float:left; text-align:left;"></div>
 </div>
 <div class="menu">
  <span class="menuItem"><a href="http://alusus.net?lang=ar">لغة الأسُس</a> &#x276f; <a href="http://alusus.net/documentation?lang=ar">الوثائق</a></span>
 </div>
 <div id='rootdiv' style="padding-top:5px; padding-left:20px; padding-right:20px; padding-bottom:35px;">
 <h1>معايير لغة الأسُس البرمجية</h1>
 <a href='#' onclick='openAllFolds()'>إفتح الكل</a>&nbsp;&nbsp;&nbsp;<a href='#' onclick='closeAllFolds()'>أغلق الكل</a>
 
 <!-- ********************************************************************** -->
 <h2 class="foldable numbering">معايير القلب القواعدية</h2>
 <div>
  <h3 class="foldable numbering">الخطوط العريضة للتركيب النحوي</h3>
  <div>
   فيما يلي بعض الخطوط العريضة التي يتميز بها التركيب النحوي للغة الأسُس:
   <ul>
    <li>قواعد اللغة حساسة لحالة الأحرف، أي أن a لا يساوي A.</li>
    <li>تُفصَل الجمل بالفارزة المنقوطة ويمكن لجملة واحدة أن تمتد إلى أكثر من سطر واحد. الفارزة المنقوطة ليست جزءاً من الجملة أي أنها غير ضرورية بعد آخر جملة من مجموعة جمل.</li>
    <li>تستخدم الأقواس الحاصرة {} لإنشاء مجموعات من الجمل.</li>
    <li>تمرر المعطيات باستخدام الأقواس وهناك نوعين من هذه الأقواس، الهلالية () والمعقوفة []. القلب لا يفرض أي قيود حول طريقة استخدام هذه الأقواس لكن الأقواس المعقوفة خُصصت لمعطيات الترجمة، أي المعطيات التي تُعالج أثناء الترجمة، بينما خصصت الأقواس الأخرى لمعطيات التنفيذ، أي المعطيات  التي تُرسل بين أجزاء البرنامج أثناء التنفيذ.</li>
    <li>تُفصل المعطيات باستخدام الفارزة.</li>
    <li>الملاحظات تُعلَّم باستخدام  الرمزين /* و */ ويُمكن لهذه الملاحظات الامتداد على أكثر من سطر واحد، بينما ملاحظات السطر الواحد تُعلَّم بالرمز //.</li>
    <li>تُعلَّم المحارف بعلامة الاقتباس المفردة، بينما تُعلَّم سلاسل الحارف باستخدام علامة الاقتباس المزدوجة.</li>
    <li>تُستخدم الأقواس الهلالية لتجميع العمليات لغرض فرض الأسبقيات وتجنب الغموض الإعرابي.</li>
    <li>تعامل النقطة معاملة المؤثر الثنائي فلا تختلف عند القلب عن غيرها من المؤثرات الثنائية سوى بالأسبقية، لكنها خُصصت للإشارة إلى العناصر الداخلية.</li>
   </ul>
  </div>

  <h3 class="foldable numbering">تعريفات قواعدية مساعدة</h3>
  <div>
   <p><span class="kwd">keywords</span><br/>
   تعريف لصنف يُستخدم لحمل مجموعة من الكلمات التعريفية.
<pre dir=ltr class="code">
keywords : type list[string]
</pre>
   </p>
    
   <p><span class="kwd">filter</span><br/>
   تعريف لصنف يُستخدم لحمل قيمة المرشّحات في متن القواعد. يمكن للقيمة أما أن تكون عدداً صحيحاً، أو مصفوفة من الأعداد الصحيحة.
<pre dir=ltr class="code">
filter : type integer || list[integer]
</pre>
   </p>
       
   <p><span class="kwd">valid_subject</span><br/>
   تعريف لصنف المؤشرات المسموح بها كحد من حدود التركيب أو الأمر أو الجملة.
<pre dir=ltr class="code">
valid_subject : type prule[Subject||Subject.Parameter||Command||Expression||Main.Statement||Set]
</pre>
   </p>
   
   <p><span class="kwd">Keyword</span><br/>
   القاعدة الإعرابية للكلمة التعريفية. تستخدم هذه الكلمات التعريفية في تعريف الأوامر.
<pre dir=ltr class="code">
Keyword : prule as (@unique kwd:string)=>{ lexer.Identifier(kwd) }
</pre>
   </p>
   
   <p><span class="kwd">KeywordGroup</span><br/>
   القاعدة الإعرابية لمجموعة من الكلمات التعريفية. تستخدم هذه القاعدة لتمكين الأمر الواحد من التبديل بين أكثر من كلمة تعريفية واحدة. على سبيل المثال يمكن للأمر أن يستخدم ترجمات مختلفة لنفس الكلمة التعريفية.
<pre dir=ltr class="code">
KeywordGroup : prule as (kwds:keywords)=>{ alternate (kwds:k)->( Keyword(k) ) }
</pre>
   </p>
   
   <p><span class="kwd">Constants</span><br/>
   قاعدة إعرابية لعملية تبادل بين مجموعة من الثوابت. تستخدم هذه القاعدة من قبل القواعد التي تسمح بأكثر من ثابت واحد في موضع معين. على سبيل المثال العمليات الرياضية تسمح بأكثر من مؤثر واحد بين الحدّين.
<pre dir=ltr class="code">
Constants : prule as (kwds:keywords)=>{ alternate (kwds:k)->( lexer.Constant(k) ) }
</pre>
   </p>
  </div>

  <h3 class="foldable numbering">المعايير الترميزية</h3>
  <div>
   <h3 class="foldable numbering">ترميز المحارف</h3>
   <div>
    تُكتب البرامج المصدرية بالترميز الموحد (unicode) باستخدام صيغة UTF-8.  والمرمز حساس لحالة الأحرف (case sensitive) لذلك فإن كلمة command تختلف عن المرمز عن Command. وبصورة عالمة، فإن المرمز يميز المحارف باستخدام قيمتها الترميزية وبالتالي فإن حرفين بقيمتين مختلفتين يعاملان كحرفين مختلفين حتى وإن رُسما بنفس الشكل.
   </div>
   
   <h3 class="foldable numbering">عملية الترميز</h3>
   <div>
    <h3>اختيار الترميز الملائم</h3>
    عندما تُطابق المحارف المدخلة أكثر من قاعدة ترميزية واحدة يتم اختيار أكثرها ملائمة حسب المعايير التالية وبنفس الأسبقية:
    <ul>
     <li>إذا كانت أطوال الرموز مختلفة يؤخذ أطولها. على سبيل المثال إذا طابقت المحارف المدخلة الرمزين "int" و "int32" يؤخذ الأخير.</li>
     <li>إذا كان أحد الرموز من الثوابت يؤخذ على حساب الرموز غير الثابتة. على سبيل المثال القاعدة int لها أسبقية على القاعدة identifierفي المثال التالي:
<pre dir=ltr class="samplecode">
int: "int".
identifier: letter {letter}.
</pre>
     </li>
     <li>إذا لم ينطبق المعياران أعلاه على القواعد الترميزية المعنية فيتم اختيار القاعدة المذكورة أولاً في مكتبة القواعد داخل القلب.</li>
    </ul>

    <h3>نهاية الرموز</h3>
    يتم استبيان نهاية الرمز عند استلام أي حرف لا يطابق قاعدة الرمز.

    <h3>المحارف المهملة</h3>
     تعرف المحارف المهملة بنفس طريقة تعريف القواعد الترميزية ويقوم المرمّز بمعالجتها بنفس الطريقة أيضاً. الفرق الوحيد بينهما أن المرمّز لا يُرسل الرموز المهملة إلى المعرب. يمكن تعريف عدد غير محدد من القواعد المهملة.

    <h3>المحارف اليتيمة</h3>
     عندما يستلم المرمّز محارفاً لا تطابق أي قاعدة ترميزية أو أي قاعدة محارف مهملة فإنه يصدر إشعار خطأ للمستخدم.
   </div>

   <h3 class="foldable numbering">مجموعات المحارف</h3>
   <div>
    يستخدم مرمّز لغة الأسُس مجموعات المحارف التالية:
<pre dir=ltr class="code">
BinDigit : char '0'..'1';
OctDigit : char '0'..'7';
DecDigit : char '0'..'9';
HexDigit : char '0'..'9', 'a'..'f', 'A'..'F';
Letter : char 'a'..'z', 'A'..'Z', '_';
AnyCharNoEs : char ^('\\');
AnyCharNoEsOrSingleQuote : char ^("\\'");
AnyCharNoEsOrDoubleQuote : char ^("\\\"");
Spacing : char " \n\r\t";
</pre>
    <b>ملاحظة</b><br/>
    سيتم تعديل تعريف <span class="kwd">Letter</span> مستقبلاً لتمكين استخدام لغات غير الإنجليزية في كتابة الشفرة المصدرية.
   </div>

   <h3 class="foldable numbering">المحارف المهملة</h3>
   <div>
    يُهمل المرمّز المحارف الغير مرئية كمحارف المسافة ونهاية السطر، وهي المحارف التي تحتويها مجموعة المحارف Spacing وحسب القاعدة التالية:
<pre dir=ltr class="code">
Spacing : char " \n\r\t";
ignore { Spacing * (1,endless) };
</pre>
   </div>

   <h3 class="foldable numbering">المحارف المركبة</h3>
   <div>
     يدعم مرمّز لغة الأسُس المجموعات التالية من المحارف المركبة (escape sequences):
     <p><b>المحارف اللامرئية</b><br/>
     <table class="dict">
      <tr><td dir=ltr>\n</td><td>سطر جديد (linefeed)</td></tr>
      <tr><td dir=ltr>\r</td><td>رجوع إلى بداية السطر (carriage return)</td></tr>
      <tr><td dir=ltr>\t</td><td>علامة التبويب (tab)</td></tr>
      <tr><td dir=ltr>\b</td><td>مسح للخلف (backspace)</td></tr>
      <tr><td dir=ltr>\0</td><td>نهاية سلسلة محارف (string terminator)</td></tr>
     </table>
     </p>

     <p><b>المحارف الاستثنائية</b><br/>
     <table class="dict">
      <tr><td dir=ltr>\'</td><td>علامة اقتباس مفردة (single quote)</td></tr>
      <tr><td dir=ltr>\"</td><td>علامة اقتباس مزدوجة (double quote)</td></tr>
      <tr><td dir=ltr>\\</td><td>شارحة مائلة (backslash)</td></tr>
      <tr><td dir=ltr>\!</td><td>الرمز !. يستخدم في الرموز الحرفية (literals) الشخصية حيث يستخدم الرمز ! لتحديد نهاية الرمز</td></tr>
     </table>
     </p>

     <p><b>محارف التعبيرات النمطية</b><br/>
     <table>
      <tr><td dir=ltr>\[</td></tr>
      <tr><td dir=ltr>\]</td></tr>
      <tr><td dir=ltr>\(</td></tr>
      <tr><td dir=ltr>\)</td></tr>
      <tr><td dir=ltr>\*</td></tr>
      <tr><td dir=ltr>\+</td></tr>
      <tr><td dir=ltr>\.</td></tr>
      <tr><td dir=ltr>\?</td></tr>
      <tr><td dir=ltr>\|</td></tr>
      <tr><td dir=ltr>\^</td></tr>
      <tr><td dir=ltr>\$</td></tr>
     </table>
     </p>

     <p><b>إدخال شفرة المحرف يدوياً</b><br/>
     <table class="dict">
      <tr><td dir=ltr>\cDD</td><td>لإدخال شفرة بحجم بايت، أي 8 بتّات</td>
      <tr><td dir=ltr>\uDDDD</td><td>لإدخال شفرة بحجم بايتين، أي16 بتّاً</td>
      <tr><td dir=ltr>\wDDDDDDDD</td><td>لإدخال شفرة بحجم 4 بايتات، أي 32 بتّاً</td>
     </table>
     </p>
    </p>

    <h3>التعريف القواعدي</h3>
<pre dir=ltr class="code">
escapeSequences : keywords = (
  // invisible characters:
  "\\n", "\\r", "\\t", "\\b", "\\f", "\\0",
  // special characters:
  "\\\'", "\\\"", "\\\\", "\\!",
  // regular expressions characters:
  "\\[", "\\]", "\\(", "\\)", "\\*", "\\+",
  "\\.", "\\?", "\\|", "\\^", "\\$");

AnyCharNoEs : char ^('\\');
AnyCharNoEsOrSingleQuote : char ^("\\'");
AnyCharNoEsOrDoubleQuote : char ^("\\\"");

@inner EsCharWithSingleQuote : token as {
  AnyCharNoEsOrDoubleQuote || EsSequence ||
  alternate (escapeSequences:es)->( es )
};
@inner EsCharWithDoubleQuote : token as {
  AnyCharNoEsOrSingleQuote || EsSequence ||
  alternate (escapeSequences:es)->( es )
};
@inner EsCharWithQuotes : token as {
  AnyCharNoEs || EsSequence || alternate (escapeSequences:es)->( es )
};
@inner EsSequence : token as {
  '\\' + ('c' + HexDigit*(2,2) ||
          'u' + HexDigit*(4,4) ||
          'w' + HexDigit*(8,8) ||
          'n' || 't' || 'r')
};
</pre>
   </div>

   <h3 class="foldable numbering">الرموز مسبقة التعريف</h3>
   <div>
    يمكن تقسيم الرموز المسبقة التعريف إلى ثلاثة أنواع: معرِّفات وثوابت وحرفيات (literals).

    <h3 class="foldable numbering">المعرِّفات (identifiers)</h3>
    <div>
    المعرِّفات تبدأ بحرف أبجدي أو بشارحة سفلية وتحتوي على عدد غير محدد من المحارف. يمكن للمعرِّفات احتواء الأرقام أيضاً.
     <h3>التركيب النحوي</h3>
<pre dir=ltr class="code">
identifier : letter { letter | decDigit }.
letter : 'a'..'z' | 'A' .. 'Z' | '_'.
decDigit : '0'..'9'.
</pre>

     <h3>التعريف القواعدي</h3>
<pre dir=ltr class="code">
Identifier : trule as { Letter + (Letter || DecDigit)*(0,endless) };
Letter : char 'a'..'z', 'A'..'Z', '_';
DecDigit : char '0'..'9';
</pre>
    </div>

    <h3 class="foldable numbering">الثوابت</h3>
    <div>
     الثوابت تُعرّف بقالب قواعدي بسيط ويتم إنشاء طبعة من هذا القالب لكل من ثوابت اللغة. كل ثابت من هذه الثواب يمثل بسلسلة محارف تُمرر للقالب القواعدي كمدخلات.
     <h3>التعريف القواعدي</h3>
<pre dir=ltr class="code">
Constant : token as (@unique cnst:string)=>{ cnst };
</pre>

     <h3>مجموعات الثوابت</h3>
     يمكن تقسيم ثوابت اللغة إلى المجموعات التالية:
     <table class="dict bilingual">
      <tr><td>مؤثرات التعيين</td><td dir=ltr style="word-spacing:20px;">=  +=  -=  *=  /=  %=  &=  |=  $=  &lt;&lt;=  &gt;&gt;=</td></tr>
      <tr><td>مؤثرات المقارنة</td><td dir=ltr style="word-spacing:20px;">==  !=  &lt;  &gt;  &lt;=  &gt;=</td></tr>
      <tr><td>مؤثرات الجمع والطرح</td><td dir=ltr style="word-spacing:20px;">+  -</td></tr>
      <tr><td>مؤثرات القسمة والضرب</td><td dir=ltr style="word-spacing:20px;">*  /  %</td></tr>
      <tr><td>مؤثرات التعاملات البتّية</td><td dir=ltr style="word-spacing:20px;">|  $  &  &lt;&lt;  &gt;&gt;</td></tr>
      <tr><td>مؤثرات التعاملات المنطقية</td><td dir=ltr style="word-spacing:20px;">||  $$  &&  or  nor  xor  xnor  and  nand</td></tr>
      <tr><td>مؤثرات التعاملات الأحادية المسبقة</td><td dir=ltr style="word-spacing:20px;">++  --  +  -  !  !!  not</td></tr>
      <tr><td>مؤثرات التعاملات الأحادية المؤخرة</td><td dir=ltr style="word-spacing:20px;">++  --</td></tr>
      <tr><td>مؤثرات الربط العليا</td><td dir=ltr style="word-spacing:20px;">.  -&gt;  .&gt; &lt;.</td></tr>
      <tr><td>مؤثرات الربط الثانية</td><td dir=ltr style="word-spacing:20px;">=&gt;  ..  ..&gt;  &lt;..</td></tr>
      <tr><td>مؤثرات الربط الثالثة</td><td dir=ltr style="word-spacing:20px;">:  :&gt;  &lt;:</td></tr>
      <tr><td>مؤثرات الربط السفلى</td><td dir=ltr style="word-spacing:20px;">::  ::&gt;  &lt;::  in</td></tr>
      <tr><td>مؤثر الشرط</td><td>?</td></tr>
      <tr><td>ثوابت التنقيط (punctuators)</td><td dir=ltr style="word-spacing:20px;">(  )  {  }  [  ]  @  ~  \ ;</td></tr>
     </table>
     <p><b>ملاحظة</b><br/>
     الثوابت الظاهرة في أكثر من مجموعة من المجموعات السابقة تُعامل من قبل المرمّز كثابت واحد. على سبيل المثال، يوجد في المرمّز تعريف واحد للرمز ++ وليس تعريفين رغم ظهوره مرتين أعلاه.
    </div>

    <h3 class="foldable numbering">الرموز الحرفيّة</h3>
    <div>
     <h3 class="foldable numbering">الأعداد الصحيحة</h3>
     <div>
      يمكن للأعداد الصحيحة أن تكون عشرية أو ثنائية أو ثمانية أو ستة عشرية ويميز نوع العدد بما يسبقه من بادئة كما يلي:
      <table class="dict bilingual">
       <tr><td>الأعداد الثنائية</td><td>0b</td></tr>
       <tr><td>الأعداد الثمانية</td><td>0o</td></tr>
       <tr><td>الأعداد الستة عشرية</td><td>0h</td></tr>
      </table>
      في حال خلو العدد من بادئة فإن العدد عشري. يتم تحديد ما إذا كان العدد طبيعياً (عدد صحيح موجب) بتذييله ب u وإلا فإن العدد صحيح (موجب أو سالب). آخر جزء من العدد، وهو جزء اختياري أيضاً، يحدد الوحدة التخزينية للعدد، أي يحدد عدد البتّات لذلك العدد، ويحدد ذلك بكتابة الحرف i يتبعه عدد بتّات ذلك العدد.
      <h3>التركيب النحوي</h3>
<pre dir=ltr class="code">
[prefix] digit {digit} ["u"] ["i" num].
</pre>

      <h3>التعريف القواعدي</h3>
<pre dir=ltr class="code">
BinDigit : char '0'..'1';
OctDigit : char '0'..'7';
DecDigit : char '0'..'9';
HexDigit : char '0'..'9', 'a'..'f', 'A'..'F';

IntLiteral : trule as {
  (DecIntLiteral || BinIntLiteral || OctIntLiteral || HexIntLiteral) +
  ("u" || "U")*(0,1) + (("i" || "I") + DecIntLiteral)*(0,1)
};
@inner DecIntLiteral : trule as { DecDigit*(1,endless) };
@inner BinIntLiteral : trule as { ("0b" || "0B") + BinDigit*(1,endless) };
@inner OctIntLiteral : trule as { ("0o" || "0O") + OctDigit*(1,endless) };
@inner HexIntLiteral : trule as { ("0h" || "0H") + HexDigit*(1,endless) };
</pre>
     </div>

     <h3 class="foldable numbering">الاعداد الحقيقية</h3>
     <div>
      تكتب الأعداد الحقيقية بالطريقة العشرية فقط، وتكتب بعدد صحيح يحتوي الفاصلة العشرية متبوعاً اختيارياً بالحرف e تليه قيمة الرفع، متبوعاً اختيارياً بالحرف f يليه حجم الوحدة التخزينية للعدد.
      <h3>التركيب النحوي</h3>
<pre dir=ltr class="code">
num "." num ["e" ["+"|"-"] num] ["f" num]
</pre>

      <h3>التعريف القواعدي</h3>
<pre dir=ltr class="code">
DecDigit : char '0'..'9';

FloatLiteral : trule as {
  DecDigit*(1,endless) + FloatPostfix ||
  DecDigit*(1,endless) + FloatExponent + FloatPostfix*(0,1) ||
  DecDigit*(1,endless) + "." + DecDigit*(1,endless) +
    FloatExponent*(0,1) + FloatPostfix*(1,1)
};
@inner FloatExponent : token as { ("e" || "E") + ("+" || "-")*(0,1) + DecDigit*(1,endless) };
@inner FloatPostfix : token as { ("f" || "F") + DecDigit*(0,endless) };
</pre>
     </div>

     <h3 class="foldable numbering">المحارف</h3>
     <div>
      يكتب ثابت المحرف كمحرف واحد أو محرف مركب محاط بعلامتي اقتباس فردية. يُمكن تذييل الثابت بما يحدد الصيغة الترميزية للمحرف. إن لم تحدد صيغة الترميز فإن الصيغة الإفتراضية ستكون UTF-8. تحديد الترميز يكون كما يلي:
      <table class="dict">
       <tr><td dir=ltr>u</td><td dir=ltr>UTF-8 LE</td></tr>
       <tr><td dir=ltr>u8</td><td dir=ltr>UTF-8 LE</td></tr>
       <tr><td dir=ltr>u16</td><td dir=ltr>UTF-16 LE</td></tr>
       <tr><td dir=ltr>u32</td><td dir=ltr>UTF-32 LE</td></tr>
       <tr><td dir=ltr>a</td><td dir=ltr>ASCII</td></tr>
      </table>
      <h3>التركيب النحوي</h3>
<pre dir=ltr class="code">
"'" esCharWithDoubleQuote "'" [charCodePostfix].
</pre>

      <h3>التعريف القواعدي</h3>
<pre dir=ltr class="code">
charCodes : list[string] = ("u", "u8", "u16", "u32", "a");
escapeSequences : keywords = (
  // invisible characters:
  "\\n", "\\r", "\\t", "\\b", "\\f", "\\0",
  // special characters:
  "\\\'", "\\\"", "\\\\", "\\!",
  // regular expressions characters:
  "\\[", "\\]", "\\(", "\\)", "\\*", "\\+",
  "\\.", "\\?", "\\|", "\\^", "\\$");

AnyCharNoEsOrSingleQuote : char ^("\\'");

CharLiteral : trule as { "'" + EsCharWithDoubleQuote + "'" + CharCodePostfix*(0,1) };
@inner CharCodePostfix : trule as { alternate (charCodes:cc)->( cc ) };
@inner EsCharWithDoubleQuote : trule as {
  AnyCharNoEsOrSingleQuote || EsSequence || alternate (escapeSequences:es)->( es )
};
@inner EsSequence : trule as {
  '\\' + ('c' + HexDigit*(2,2) ||
          'u' + HexDigit*(4,4) ||
          'w' + HexDigit*(8,8) ||
          'n' || 't' || 'r')
};
</pre>
     </div>

     <h3 class="foldable numbering">سلاسل المحارف</h3>
     <div>
      يكتب ثابت سلاسل المحارف كسلسلة محارف محاطة بعلامتي اقتباس مزدوج. يمكن تذييل الثابت بما يحدد الصيغة الترميزية للمحارف. إن لم تحدد صيغة الترميز فإن الصيغة الإفتراضية ستكون UTF-8. تحديد الترميز يكون كما يلي:
      <table class="dict">
       <tr><td dir=ltr>u</td><td dir=ltr>UTF-8 LE</td></tr>
       <tr><td dir=ltr>u8</td><td dir=ltr>UTF-8 LE</td></tr>
       <tr><td dir=ltr>u16</td><td dir=ltr>UTF-16 LE</td></tr>
       <tr><td dir=ltr>u32</td><td dir=ltr>UTF-32 LE</td></tr>
       <tr><td dir=ltr>a</td><td dir=ltr>ASCII</td></tr>
      </table>
      <h3>التركيب النحوي</h3>
<pre dir=ltr class="code">
"\"" {esCharWithSingleQuote} "\"" [charCodePostfix].
</pre>

      <h3>التعريف القواعدي</h3>
<pre dir=ltr class="code">
charCodes : list[string] = ("u", "u8", "u16", "u32", "a");
escapeSequences : keywords = (
  // invisible characters:
  "\\n", "\\r", "\\t", "\\b", "\\f", "\\0",
  // special characters:
  "\\\'", "\\\"", "\\\\", "\\!",
  // regular expressions characters:
  "\\[", "\\]", "\\(", "\\)", "\\*", "\\+",
  "\\.", "\\?", "\\|", "\\^", "\\$");

AnyCharNoEsOrDoubleQuote : char ^("\\\"");

StringLiteral : trule as {
  StringLiteralPart + (Spacing*(0,endless) + StringLiteralPart)*(0,endless) +
  CharCodePostfix*(0,1)
};
@inner StringLiteralPart : trule as { "\"" + EsCharWithSingleQuote*(0,endless) + "\"" };
@inner CharCodePostfix : trule as { alternate (charCodes:cc)->( cc ) };
@inner EsCharWithSingleQuote : trule as {
  AnyCharNoEsOrDoubleQuote || EsSequence || alternate (escapeSequences:es)->( es )
};
@inner EsSequence : trule as {
  '\\' + ('c' + HexDigit*(2,2) ||
          'u' + HexDigit*(4,4) ||
          'w' + HexDigit*(8,8) ||
          'n' || 't' || 'r')
};
</pre>
     </div>

     <h3 class="foldable numbering">الرموز الشخصية</h3>
     <div>
      الرموز الشخصية صممت لتمكين المستخدم من إضافة أنواع رموز جديدة بشكل فعّال (ديناميكي). على سبيل المثال، يمكن للمستخدم إضافة نوع جديد من الرموز الحرفية لتحمل معلومات بصيغة XML. يبدأ الرمز الشخصي بشعار البداية، تليه سلسلة محارف تليها شعار النهاية. شعار البداية يبدأ بعلامة ! تليها كلمة تعريفية تحدد نوع الثابت الحرفي يليها الرمز &lt;. أما شعار النهاية فيبدأ بالرمز &gt; يليه اختيارياً سلسلة محارف لتحديد مواصفات إضافية يليها الرمز !. كما هو الحال مع سلاسل المحارف، يمكن استخدام المحارف المركبة في الرموز الشخصية ما بين شعاري البداية والنهاية.
      <h3>التركيب النحوي</h3>
<pre dir=ltr class="code">
"!" prefix "<" {esChar} ">" [postfix] "!".
</pre>

      <h3>التعريف القواعدي</h3>
<pre dir=ltr class="code">
escapeSequences : keywords = (
  // invisible characters:
  "\\n", "\\r", "\\t", "\\b", "\\f", "\\0",
  // special characters:
  "\\\'", "\\\"", "\\\\", "\\!",
  // regular expressions characters:
  "\\[", "\\]", "\\(", "\\)", "\\*", "\\+",
  "\\.", "\\?", "\\|", "\\^", "\\$");

AnyCharNoEs : char ^('\\');

CustomLiteral : trule as (@unique prefix:keywords,postfix:keywords)=>{
  "!" + alternate (prefix:p)->( p ) + "<" + EsCharWithQuotes*(0,endless) +
  (">!" + Spacing*(0,endless) + "!<" + EsCharWithQuotes*(0,endless))*(0,endless) +
  ">" + (alternate (postfix:p)->( p ))*(0,1) + "!"
};
@inner EsCharWithQuotes : trule as {
  AnyCharNoEs || EsSequence || alternate (escapeSequences:es)->( es )
};
@inner EsSequence : trule as {
  '\\' + ('c' + HexDigit*(2,2) ||
          'u' + HexDigit*(4,4) ||
          'w' + HexDigit*(8,8) ||
          'n' || 't' || 'r')
};
</pre>
     </div>
    </div>
   </div>
  </div>
  
  <h3 class="foldable numbering">المعايير الإعرابية</h3>
  <div>
   <h3 class="foldable numbering">البرامج والجمل</h3>
   <div>
    البرنامج في لغة الأسُس يتكون من مجموعة من الجمل (statement). كل جملة تتكون من حدّ (subject) واحد أو سلسلة من الحدود. تتقبل الجملة صيغاً مختلفة من سلاسل الحدود، كل صيغة من هذه الصيغ تسمى عبارة (phrase).<br/>
    يتم الفصل بين الجمل باستخدام الفارزة المنقوطة ولا تكون الفارزة المنقوطة جزءاً من الجملة ولذلك لا يُشترط أن ينتهي البرنامج (أو أي مجموعة من الجمل) بالفارزة المنقوطة.<br/>
    تم جمع تعريفات الجمل والعبارات في حزمة واحدة باسم Main والغرض من هذه الأسلوب تسهيل اشتقاق أنواع أخرى من الجمل ومجموعات الجمل.<br/>
    يعرّف القلب ثلاثة عبارات افتراضية:
    <ul>
     <li><b>ExpPhrase:</b> تبدأ هذه العبارة بتركيب تليه سلسلة غير محددة من الأوامر الذيلية وهي مجموعة الأوامر التي لا تظهر في بداية الجملة.</li>
     <li><b>CmdPhrase:</b> تبدأ هذه العبارة بأمر افتتاحي تليه سلسلة غير محددة من الأوامر الذيلية. الأوامر الافتتاحية هي مجموعة الأوامر التي تظهر في بداية الجملة ولا تظهر في مكان آخر.</li>
     <li><b>SoloCmdPhrase:</b> تحتوي هذه العبارة على أمر منفرد واحد. الأوامر المنفردة هي التي تظهر فقط وحيدة في الجملة.</li>
    </ul>
    
    <h3>التركيب النحوي</h3>
<pre dir=ltr class="code">
Program : StatementList.
StatementList : Statement { ";" Statement }.
Statement : (Phrase | Phrase | ...).
Phrase : { Subject }.
</pre>

    <h3>التعريف القواعدي</h3>
<pre dir=ltr class="code">
Program : prule as { root.Main };

Main : module {
  start StatementList;

  StatementList : prule as {
    Statement*(0, 1) + (lexer.Constant(";") + Statement*(0, 1))*(0, endless)
  };

  Statement : @limit[user.parent==self,child.terms==self] prule
    prefix self.id, DefaultModifier
    as (phrases:list[prule[Phrase]]=(CmdPhrase, SoloCmdPhrase, ExpPhrase)=>{
      alternate (phrases:phrase)->( phrase )
  };

  Phrase : prule as (subjects:list[map[prd:valid_subject, min:integer, max:integer, pty:integer]])=>{
      concat (subjects:s)->( @priority(s.pty,0) s.prd*(s.min,s.max) )
  };

  // Default phrases.
  CmdPhrase : prule ref Phrase(subjects=((prd=LeadingCmdGroup,min=1,max=1),
                                         (prd=TrailingCmdGroup,min=0,max=endless)));
  SoloCmdPhrase : prule ref Phrase(sections=((prd=SoloCmdGroup,min=1,max=1)));
  ExpPhrase : prule ref Phrase(subjects=((prd=root.Expression,min=1,max=1),
                                         (prd=TrailingCmdGroup,min=0,max=endless)));
}
</pre>
   </div>
   
   <h3 class="foldable numbering">التراكيب</h3>
   <div>
   التركيب هو مجموعة من الحدود مرتبطة هرمياً بمؤثرات. هناك نوعين من المؤثرات: أحادية وثنائية. المؤثرات الأحادية تُطبَّق على حد واحد بينما تربط المؤثرات الثنائية بين حدين. المؤثرات الأحادية تسبق أو تلي الحد بينما تقع المؤثرات الثنائية وسط حدين. أغلب هذه المؤثرات لها معنى مسبق التعريف، لكن ليس هناك من الناحية التقنية ما يمنع استخدامها بشكل مختلف في القواعد المشتقة أو عند إنشاء الشفرة التنفيذية، أي أن القلب يتعامل مع كل هذه المؤثرات بشكل مشابه وهي لا تختلف عنده عن بعضها إلا بشفرتها.<br/>
   جُمعت القواعد الإعرابية المتعلقة بالتراكيب في حزمة واحدة لتسهيل الإشتقاق القواعدي لإنشاء أنواع جديدة ومخصصة من المؤثرات.
   
   <h3>التركيب النحوي</h3>
   للمؤثرات التراكيب النحوية التالية:
<pre dir=ltr class="code">
[unaryOp] operand.
operand [unaryOp].
operand1 {binaryOp operand2}.
</pre>
   
   <h3>المؤثرات</h3>
     كل المؤثرات لها نفس التركيب النحوي المذكور أعلاه لكنها تختلف في أسبقياتها التي تحدد كيفية إعراب التركيب وتحويله إلى شجرة بيانية. على سبيل المثال المؤثر * له الأسبقية دائماً على المؤثر + وبالتالي يكون ظهوره في شجرة البيانات أعمق من المؤثر +. الأسبقيات بين المؤثرات ثابتة في لغة الأسُس التي تفرض هذه الأسبقية على من يشتق تراكيبه الخاصة. فيما يلي قائمة المؤثرات مرتبة تصاعدياً حسب الأسبقية:
    <ul>
      <li><b>مؤثرات الربط السفلى</b><br/>
       تُستخدم للربط بين حدّين مختلفين بأسبقية سفلى دون أن تقدم معنى محدداً لهذا الربط، بل يترك الأمر لمطوري القواعد المخصصة لتحديد المعنى.
       <table class="dict">
        <tr><td dir=ltr>::</td></tr>
        <tr><td dir=ltr>::></td></tr>
        <tr><td dir=ltr><::</td></tr>
        <tr><td dir=ltr>in</td><td>تستخدم لتحديد جزء من كل كما هو الحال في أمر foreach.</td></tr>
       </table>
      </li>
      <li><b>المؤثر الشرطي '?'</b><br/>
      يستخدم المؤثر الشرطي <b>?</b> لإنشاء تركيب شرطي فيسبقه شرط ويليه جواب الشرط.
      </li>
      <li><b>مؤثر القوائم ','</b><br/>
       يستخدم لجمع عدد غير محدد من الحدود في قائمة واحدة.
      </li>
      <li><b>مؤثرات الربط الثالثة</b><br/>
      تُستخدم للربط بين حدّين مختلفين بأسبقية أعلى من مؤثرات الربط السفلى لكنها أدنى من مؤثرات الربط الثانية والعليا. يترك لمطوري القواعد المخصصة تحديد معنى هذه المؤثرات.
       <table class="dict">
        <tr><td dir=ltr>:</td></tr>
        <tr><td dir=ltr>:&gt;</td></tr>
        <tr><td dir=ltr>&lt;:</td></tr>
       </table>
      </li>
      <li><b>مؤثرات التعيين</b><br/>
      تستخدم لتعيين قيمة جديدة لحدّ.
       <table class="dict">
        <tr><td dir=ltr>=</td><td>تحديد قيمة جديدة</tr>
        <tr><td dir=ltr>+=</td><td>إضافة قيمة للقيمة الحالية</td></tr>
        <tr><td dir=ltr>-=</td><td>طرح قيمة من القيمة الحالية</td></tr>
        <tr><td dir=ltr>*=</td><td>ضرب القيمة الحالية بقيمة أخرى</td></tr>
        <tr><td dir=ltr>/=</td><td>تقسيم القيمة الحالية على قيمة أخرى</td></tr>
        <tr><td dir=ltr>%=</td><td>تقسيم القيمة الحالية على قيمة أخرى والاحتفاظ بالباقي بدل نتيجة القسمة</td></tr>
        <tr><td dir=ltr>&=</td><td>تطبيق عملية 'و' المنطقية على القيمة الحالية</td></tr>
        <tr><td dir=ltr>|=</td><td>تطبيق عملية 'أو' المنطقية على القيمة الحالية</td></tr>
        <tr><td dir=ltr>$=</td><td>تطبيق عملية xor المنطقية على القيمة الحالية</td></tr>
        <tr><td dir=ltr>&lt;&lt;=</td><td>تزحيف جميع البتّات يساراً مراتباَ بتعداد القيمة المعطاة</td></tr>
        <tr><td dir=ltr>=&gt;&gt;</td><td>تزحيف جميع البتّات يميناً مراتباً بتعداد القيمة المعطاة</td></tr>
       </table>
      </li>
      <li><b>مؤثرات العمليات المنطقية</b><br/>
       <table class="dict">
        <tr><td dir=ltr>or</td><td>عملية 'أو'</td></tr>
        <tr><td dir=ltr>||</td><td>صيغة رمزية ل or</td></tr>
        <tr><td dir=ltr>nor</td><td>عملية 'أو' معكوسة</td></tr>
        <tr><td dir=ltr>xor</td><td>عملية xor</td></tr>
        <tr><td dir=ltr>$$</td><td>صيغة رمزية ل xor</td></tr>
        <tr><td dir=ltr>xnor</td><td>عملية xor معكوسة</td></tr>
        <tr><td dir=ltr>and</td><td>عملية 'و'</td></tr>
        <tr><td dir=ltr>&&</td><td>صيغة رمزية ل and</td></tr>
        <tr><td dir=ltr>nand</td><td>عملية 'و' معكوسة</td></tr>
       </table>
      </li>
      <li><b>مؤثرات المقارنة</b><br/>
       <table class="dict">
        <tr><td dir=ltr>==</td><td>فحص مساواة</td></tr>
        <tr><td dir=ltr>!=</td><td>فحص عدم المساواة</td></tr>
        <tr><td dir=ltr>&lt;</td><td>فحص أصغر</td></tr>
        <tr><td dir=ltr>&gt;</td><td>فحص أكبر</td></tr>
        <tr><td dir=ltr>&lt;=</td><td>فحص أصغر أو يساوي</td></tr>
        <tr><td dir=ltr>&gt;=</td><td>فحص أكبر أو يساوي</td></tr>
       </table>
      </li>
      <li><b>مؤثرات الربط الثانية</b><br/>
      تُستخدم للربط بين حدّين مختلفين بأسبقية أعلى من مؤثرات الربط الثالثة لكنها أدنى من مؤثرات الربط العليا. يترك لمطوري القواعد المخصصة تحديد معنى هذه المؤثرات.
       <table class="dict">
        <tr><td dir=ltr>=&gt;</td></tr>
        <tr><td dir=ltr>..</td></tr>
        <tr><td dir=ltr>..&gt;</td></tr>
        <tr><td dir=ltr>&lt;..</td></tr>
       </table>
      </li>
      <li><b>مؤثرات الجمع والطرح</b><br/>
       <table class="dict">
        <tr><td dir=ltr>+</td></tr>
        <tr><td dir=ltr>-</td></tr>
       </table>
      </li>
      <li><b>مؤثرات الضرب والقسمة</b><br/>
       <table class="dict">
        <tr><td dir=ltr>*</td></tr>
        <tr><td dir=ltr>/</td></tr>
        <tr><td dir=ltr>%</td><td>تحصيل باقي القسمة</td></tr>
       </table>
      </li>
      <li><b>مؤثرات العمليات البتّية</b><br/>
       هذه المؤثرات لتطبيق عمليات منطقية على مستوى البتّات، أي تطبيق العمليات على كل بت وما يقابله، بالإضافة إلى عمليات تزحيف البتّات.
       <table class="dict">
        <tr><td dir=ltr>|</td><td>عملية 'أو'</td></tr>
        <tr><td dir=ltr>$</td><td>عملية xor</td></tr>
        <tr><td dir=ltr>&</td><td>عملية 'و'</td></tr>
        <tr><td dir=ltr>&lt;&lt;</td><td>تزحيف البتّات يميناً مراتباً بتعداد القيمة المعطاة</td></tr>
        <tr><td dir=ltr>&gt;&gt;</td><td>تزحيف البتّات يساراً مراتباً بتعداد القيمة المعطاة</td></tr>
       </table>
      </li>
      <li><b>المؤثرات الأحادية السابقة</b>
       <table class="dict">
        <tr><td>++</td><td>زيادة بواحد</td></tr>
        <tr><td>--</td><td>إنقاص بواحد</td></tr>
        <tr><td>+</td><td>إشارة الرقم الموجب</td></tr>
        <tr><td>-</td><td>إشارة الرقم السالب</td></tr>
        <tr><td>!</td><td>علامة النفي البتّية (عكس قيمة البتّات)</td></tr>
        <tr><td>!!</td><td>علامة النفي المنطقية</td></tr>
       </table>
      </li>
      <li><b>المؤثرات الأحادية اللاحقة</b>
       <table class="dict">
        <tr><td>++</td><td>زيادة بواحد</td></tr>
        <tr><td>--</td><td>إنقاص بواحد</td></tr>
       </table>
      </li>
      <li><b>مؤثرات تمرير المعطيات</b><br/>
       تشمل الأقواس الإعتيادية والأقواس المعقوفة (المربعة). تأتي الأقواس بعد الحد المعني وتُستخدم لتمرير معطيات معينة إلى ذلك الحد. ليس هناك تحديد لنوع الحد المعني أو نوع المعطيات الممررة أو ماتعنيه. أدرجت هذه المؤثرات ضمن قائمة المؤثرات الأحادية لإمكانية افتقارها لأي معطى حيث يمكن إلحاق حدّ معين بقوسين فارغين.
<pre dir=ltr class="code">
operand "(" [expression] ")"
operand "[" [expression] ")"
</pre>
      </li>
      <li><b>مؤثرات الربط العليا</b><br/>
      تُستخدم للربط بين حدّين مختلفين بأسبقية عليا. يترك لمطوري القواعد المخصصة تحديد معنى بعض هذه المؤثرات.
       <table class="dict">
        <tr><td dir=ltr>.</td><td>يُستخدم للربط بين حاوية وعنصر ينتمي لها، كما هو الحال عند الإشارة إلى أحد عناصر كائن ما في البرمجة كائنية المنحى.</td></tr>
        <tr><td dir=ltr>-&gt;</td><td>يستخدم كأسلوب آخر للربط بين حاوية وعنصر ينتمي لها.</td></tr>
        <tr><td dir=ltr>.&gt;</td></tr>
        <tr><td dir=ltr>&lt;.</td></tr>
       </table>
      </li>
      <li><b>مؤثر التلدة '~'</b><br/>
      يُستخدم لتطبيق عمليات مختلفة على الحد الذي يسبقه. هذا المؤثر لا يليه إلا أمر من مجموعة محددة من الأوامر تُضاف بشكل فعّال (ديناميكي) لأغراض شتّى. على سبيل المثال يمكن تعريف أمر ptr للحصول على موقع متغير معين في الذاكرة فيصبح الحصول على موقع ذلك العنصر يتم بكتابة: <span dir=ltr>a~ptr</span><br/>
       في المثال أعلاه a هو المتغير بينما ptr أمر معرّف من قبل مكتبة البناء للحصول على موقع المتغير في الذاكرة.
      </li>
    </ul>
   <b>ملاحظة:</b> مؤثرات تمرير المعطيات والتلدة ومؤثرات الربط العليا لها جميعاً نفس الأسبقية. المثال التالي يوضح هذه المسألة:
<pre dir=ltr class="samplecode">
1) myvar.mysubvar(params)
2) myvar(params).mysubvar
</pre>
   في المثال الأول أعلاه الجزء '(params)' يُطبق على ناتج 'myvar.mysubvar' بينما في المثال الثاني الجزء '<span dir=ltr>.mysubvar</span>' يُطبق على ناتج '<span dir=ltr>myvar(params)</span>'.
   
   <h3>رمز نهاية التركيب</h3>
       الرمز \ اختياري ويستخدم لتحديد نهاية التركيب. الغرض منه إزالة الغموض إن وجد حول النقطة التي ينتهي عندها التركيب. المثال التالي يوضح حالة غموض تتطلب استخدام هذا الرمز:
<pre dir=ltr class="samplecode">
if a (b,c,d)-e
if a\ (b,c,d)-e  // prevents (b,c,d)-e from being part of the condition.
if a(b,c,d)\ -e  // makes (a,b,c) part of the condition and leaves -e out.
</pre>

   <h3>فرض أسبقيات مختلفة</h3>
   يمكن استخدام الأقواس لوضع تركيب كامل كحدً في تركيب آخر وذلك لفرض أسبقيات مختلفة عن الأسبقية الإفتراضية. على سبيل المثال:
<pre dir=ltr class="samplecode">
a = b + c * d;
a = (b + c) * d;
</pre>
   في المثال الأول تجمع b مع ناتج ضرب c و d بينما في المثال الثاني تُضرب d بناتج جمع c و b.

   <h3>التعريفات القواعدية</h3>
<pre dir=ltr class="code">
TokenData : module {
  // Predefined Operator Lists
  assignmentOpList : keywords = ("=", "+=", "-=", "*=", "/=", "%=", "&=", "|=", "$=",
                                  "&lt;&lt;=", "&gt;&gt;=");
  comparisonOpList : keywords = ("==", "!=", "&lt;", "&gt;", "&lt;=", "&gt;=");
  addOpList : keywords = ("+", "-");
  mulOpList : keywords = ("*", "/", "%");
  bitwiseOpList : keywords = ("|", "$", "&", "&lt;&lt;", "&gt;&gt;");
  logOpList : keywords = ("||", "$$", "&&", "or", "nor", "xor", "xnor", "and", "nand");
  prefixOpList : keywords = ("++", "--", "+", "-", "!", "!!", "not");
  postfixOpList : keywords = ("++", "--");
  linkOpList : keywords = ("-&gt;", ".", ".&gt;", "&lt;.");
  lowLinkOpList : keywords = ("=&gt;", "..", "..&gt;", "&lt;..");
  lowerLinkOpList : keywords = (":", ":&gt;", "&lt;:");
  lowestLinkOpList : keywords = ("::", "::&gt;", "&lt;::", "in")
};

// Expression :
// operand {binaryOp operand}.
// [unaryOp] operand.
// operand [unaryOp].
// operand {FunctionalOp}.
Expression : module {
  prefix self.id, DefaultModifier;
  start Exp;

  Exp : prule as { LowestLinkExp + (@priority(in,0) lexer.Constant("\\")*(0,1)) };
  LowestLinkExp : prule prefix self.id as (enable:integer=endless)=&gt;{
      ConditionalExp + (@priority(in,0) (LowestLinkOp + ConditionalExp)*(0,enable))
    };
  ConditionalExp : prule prefix self.id  as (enable:integer[0&lt;=n&lt;=1]=1)=&gt;{
      ListExp + (@priority(in,0) (lexer.Constant("?") + ListExp)*(0,enable))
    };
  ListExp : prule prefix self.id as (enable:integer=endless)=&gt;{
      (@priority(in,0) lexer.Constant(",")*(0,enable)) + LowerLinkExp +
      (@priority(in,0) (lexer.Constant(",") + LowerLinkExp*(0,1))*(0,enable))
    };
  LowerLinkExp : prule prefix self.id as (enable:integer=endless)=&gt;{
      AssignmentExp + (@priority(in,0) (LowerLinkOp + AssignmentExp)*(0,enable))
    };
  AssignmentExp : prule prefix self.id as (enable:integer=endless)=&gt;{
      LogExp + (@priority(in,0) (AssignmentOp + LogExp)*(0,enable))
    };
  LogExp : prule prefix self.id as (enable:integer=endless)=&gt;{
      ComparisonExp + (@priority(in,0) (LogOp + ComparisonExp)*(0,enable))
    };
  ComparisonExp : prule prefix self.id as (enable:integer=endless)=&gt;{
      LowLinkExp + (@priority(in,0) (ComparisonOp + LowLinkExp)*(0,enable))
    };
  LowLinkExp : prule prefix self.id as (enable:integer=endless)=&gt;{
      AddExp + (@priority(in,0) (LowLinkOp + AddExp)*(0,enable))
    };
  AddExp : prule prefix self.id as (enable:integer=endless)=&gt;{
      MulExp + (@priority(in,0) (AddOp + MulExp)*(0,enable))
    };
  MulExp : prule prefix self.id as (enable:integer=endless)=&gt;{
      BitwiseExp + (@priority(in,0) (MulOp + BitwiseExp)*(0,enable))
    };
  BitwiseExp : prule prefix self.id as (enable:integer=endless)=&gt;{
      UnaryExp + (@priority(in,0) (BitwiseOp + UnaryExp)*(0,enable))
    };
  UnaryExp : prule prefix self.id as (enable1:integer[0&lt;=n&lt;=1]=1,
                                      enable2:integer[0&lt;=n&lt;=1]=1)=&gt;{
      (@priority(in,0) PrefixOp*(0,enable1)) + FunctionalExp +
      (@priority(in,0) PostfixOp*(0,enable2))
    };
  FunctionalExp : prule prefix self.id
    as (operand:valid_subject=root.Subject, fltr:filter=null, dup:integer=endless,
        pty:integer=in)=&gt;{
      operand + (@priority(pty,0) (@filter(fltr) ParamPassExp ||
                                                 TildeExp ||
                                                 LinkExp(operand))*(0,dup))
    };

  // ParamPassExp : "(" [Expression] ")" | "[" [Expression] "]".
  ParamPassExp : prule as (expr:prule[Expression||Statement]=root.Expression,
                           fltr:filter=null)=&gt;{
    @filter(fltr) lexer.Constant("(") + expr*(0,1) + lexer.Constant(")") ||
                  lexer.Constant("[") + expr*(0,1) + lexer.Constant("]")
  };

  // TildeExp : "~" Subject.
  TildeExp : prule as (operand:valid_subject=root.TildeSubject)=&gt;{
      lexer.Constant("~") + operand
    };

  // LinkExp : LinkOp operand.
  LinkExp : prule as (operand:valid_subject=root.Subject)=&gt;{ LinkOp + operand };

  // Operators :
  AssignmentOp : prule as { root.Constants(root.TokenData.assignmentOpList) };
  ComparisonOp : prule as { root.Constants(root.TokenData.comparisonOpList) };
  AddOp : prule as { root.Constants(root.TokenData.addOpList) };
  MulOp : prule as { root.Constants(root.TokenData.mulOpList) };
  BitwiseOp : prule as { root.Constants(root.TokenData.bitwiseOpList) };
  LogOp : prule as { root.Constants(root.TokenData.logOpList) };
  PrefixOp : prule as { root.Constants(root.TokenData.prefixOpList) };
  PostfixOp : prule as { root.Constants(root.TokenData.postfixOpList) };
  LinkOp : prule as { root.Constants(root.TokenData.linkOpList) };
  LowLinkOp : prule as { root.Constants(root.TokenData.lowLinkOpList) };
  LowerLinkOp : prule as { root.Constants(root.TokenData.lowerLinkOpList) };
  LowestLinkOp : prule as { root.Constants(root.TokenData.lowestLinkOpList) }
};
</pre>
   
    <h3>تعريفات تراكيب مخصصة</h3>
    القلب يعرّف أيضاً مجموعة من التراكيب المخصصة لبعض الأغراض العامة والمتاحة لمطوري مكتبات البناء:
<pre dir=ltr class="code">
// An expression that blocks sets.
NoSetExpression : module inherits Expression {
  FunctionalExp.operand = root.NoSetSubject;
  LinkExp.operand = root.NoSetSubject;
};

// An expression that doesn't allow brackets.
NoBracketExpression : module inherits Expression {
  FunctionalExp.{operand=root.NoBracketSubject; fltr=(0,1,1); dup=endless; pty=in};
  LinkExp.operand = root.NoBracketSubject;
};

// An expression that allows only identifiers with link operators.
FullIdExpression : module inherits Expression {
  start FunctionalExp;
  FunctionalExp.{operand=IdSubject; fltr=2; dup=endless; pty=in};
  LinkExp.operand = root.IdSubject;
};
</pre>

   <h3>أمثلة</h3>
   الأمثلة التالية توضح بعض التراكيب وكيفية إعرابيها:
<pre dir=ltr class="samplecode">
statement:        a = b + c * d
translates into:  store(a, add(b, multiply(c, d)))

statement:        a > b ? c, d
translates into:  decide(greaterThan(a, b), list(c, d))

statement:        a:int, b:float, c:char
translates into:  list(link(a,int), link(b,float), link(c,char))

statement:        a = myclass.myfunction(5, 2)
translates into:  store(a, bracketOp(dot(myclass, myfunction), list(5, 2)))
</pre>
   </div>
   
   <h3 class="foldable numbering">الأوامر</h3>
   <div>
    الأوامر تبدأ بكلمة تعريفية تُستخدم لتمييز الأوامر عن بعضها، تليها إختيارياً معطياتٌ. الأوامر تُشتق من أحد قالبين معرفين مسبقاً في القلب، ويُترك لكاتب مكتبة البناء اختيار القالب الأنسب.
    
    <h3>التركيب النحوي</h3>
<pre dir=ltr class="code">
Cmd : keyword {Subject}.
MultiCmd : {keyword {Subject}}.
</pre>
    القالب Cmd يبدأ بكلمة تعريفية يليها عدد غير محدد من الحدود. يمكن التحكم عن طريق معطيات القالب بخيارات التكرار لكل حد من هذه الحدود. القالب MultiCmd عبارة عن سلسلة مقاطع كل منها مشابه للقالب Cmd ويمكن التحكم بخيارات التكرار لكل مقطع من هذه المقاطع، بالإضافة لإمكانية التحكم لكل حد في كل من هذه المقاطع. في حقيقة الأمر، القالب Cmd عبارة عن نسخة مبسطة من القالب MultiCmd، أي أن بالإمكان الاستعاضة عن Cmd ب MultiCmd.
    
    <p><b>ملاحظة:</b> تجنب الغموض الإعرابي من مسؤولية كاتب مكتبة البناء. الغموض قد ينتج من استخدام نفس الكلمة التعريفية في أكثر من أمر وقد ينتج أيضاً بسبب الحدود الاختيارية. على سبيل المثال، قد ينتج الغموض من حدّي تراكيب متتاليين أولهما اختياري.
    </p>
    
    <h3>التعريفات القواعدية</h3>
<pre dir=ltr class="code">
// Root Command
Command : @limit[child.terms==(Cmd||MultiCmd)] prule
  prefix self.id, DefaultModifier;

// Cmd : keyword {Subject}.
Cmd : @limit[user.parent==root.Command] prule
  as (kwd:keywords, args:list[map[prd:valid_subject, min:integer, max:integer, pty:integer]])=>{
    root.KeywordGroup(kwd) + concat (args:a)->( @priority(a.pty,0) a.prd*(a.min,a.max) )
  };

// MultiCmd : {keyword {Subject}}.
MultiCmd : @limit[user.parent==root.Command] prule
  as (sections:list[map[kwd:keywords, min:integer, max:integer, pty:integer,
                        args:list[map[prd:valid_subject, min:integer, max:integer, pty:integer]]
                       ]])=>{
    concat (sections:s)->(
      @priority(s.pty,0) (root.KeywordGroup(s.kwd) + concat (s.args:a)->(
        @priority(a.pty,0) a.arg*(a.min, a.max)
      ))*(s.min, s.max)
    )
  };
</pre>
    التعريف Command هو جذر كل الأوامر وكل أمر يجب أن يُشتق منه بشكل مباشر أو غير مباشر. فيما يلي قائمة المعطيات الداخلة في تعريف القالبين:
    <ul>
     <li><b>kwd:</b> الكلمة التعريفية للأمر، أو قائمة بتلك الكلمة التعريفية مع مرادفاتها.</li>
     <li><b>min:</b> الحد الأدنى من التكرار. قيمة 0 تجعل الظهور اختياري.</li>
     <li><b>max:</b> الحد الأعلى للتكرار. قيمة endless تعني غياب الحد الأعلى.</li>
     <li><b>pty:</b> الأسبقية في عملية التكرار. قيمة 1 تعني أن الأسبقية للتكرار بينما قيمة 0 تعطي الأسبقية للإهمال.</li>
     <li><b>prd:</b> مؤشر للتعريف القواعدي للحد.</li>
    </ul>
    
    <h3>أمثلة</h3>
    <p><b>1</b><br/>
<pre dir=ltr class="samplecode">
Cmd:      keyword {Subject}.
gotoCmd:  "goto" Expression.
          goto mystart;
</pre>
    </p>
    <p><b>2</b><br/>
<pre dir=ltr class="samplecode">
MultiCmd:  {keyword {Subject}}.
ifCmd:     "if" Expression Statement "else" Statement.
           if i==5 DoSomething() else DoSomethingElse();
</pre>
     المثال أعلاه يُعرب إلى:
<pre dir=ltr class="samplecode">
ifCmd
  Expression: i==5
  Statement:  DoSomething()
  Statement:  DoSomethingElse()
</pre>
    </p>
   </div>

   <h3 class="foldable numbering">الحدود</h3>
   <div>
   الحدّ يمكن أن يكون قيمة ثابتة أو اسم متغير أو تركيب أو أمر أو جملة أو مجموعة من الجمل. يمكن للحد أن يُحصر بين أقواس اعتيادية أو أقواس معقوفة. جُمعت التعريفات القواعدية للحدّ في حزمة واحدة يمكن الاشتقاق منها للتحكم فيما يُسمح به من أصناف في ذلك الحد والتحكم فيما إن كانت الأقواس مسموحة أو مفروضة أو ممنوعة. 
    <h3>التركيب النحوي</h3>
<pre dir=ltr class="code">
Subject : (Parameter | Command | Expression | Statement | Set) |
          "(" (Parameter | Command | Expression | Statement | Set) ")" |
          "[" (Parameter | Command | Expression | Statement | Set) "]".
Parameter : Identifier | Literal.
Literal : IntLiteral | FloatLiteral | CharLiteral | StringLiteral | CustomLiteral.
</pre>

    <h3>التعريفات القواعدية</h3>
<pre dir=ltr class="code">
Subject : module {
  prefix self.id, DefaultModifier;
  start Subject1;

  Subject1 : prule as (sbj1:list[prule[Parameter||root.Command||root.Expression||
                                       root.Main.Statement||root.Set]]
                           =(Parameter, SubjectCommandGroup, root.Set),
                       sbj2:list[prule[Parameter||root.Command||root.Expression||
                                       root.Main.Statement||root.Set]]
                           =(root.Expression),
                       sbj3:list[prule[Parameter||root.Command||root.Expression||
                                       root.Main.Statement||root.Set]]
                           =(root.Expression),
                      fltr:filter, frc2:integer=0, frc3:integer=0)=>{
    @filter(fltr)
      alternate (sbj1:s)->( s ) ||
      lexer.Constant("(") + (alternate (sbj2:s)->( s ))*(frc2,1) + lexer.Constant(")") ||
      lexer.Constant("[") + (alternate (sbj3:s)->( s ))*(frc3,1) + lexer.Constant("]")
  };
  Subject2 : @limit[user.owner==Subject] prule
    as (sbj:prule[Parameter||root.Command||root.Expression||root.Main.Statement||root.Set],
        fltr:filter, frc:integer)=>{
        @filter(fltr) sbj ||
                      lexer.Constant("(") + sbj*(frc,1) + lexer.Constant(")") ||
                      lexer.Constant("[") + sbj*(frc,1) + lexer.Constant("]")
    };

  // Commands
  SubjectCommand : prule inherits root.Command prefix self.id;
  SubjectCommandGroup : prule_group[SubjectCommand];

  // Parameter
  Parameter : prule prefix self.id
    as (fltr:filter=null, cnsts:keywords=null)=>{
      @filter(fltr) lexer.Identifier || Literal || root.Constants(cnsts)
    };

  // Literal
  Literal : prule as (fltr:filter=null)=>{
    @filter(fltr) lexer.IntLiteral || lexer.FloatLiteral || lexer.CharLiteral ||
                  lexer.StringLiteral || lexer.CustomLiteral
  }
}
</pre>
    الفرق بين Subject1 و Subject2 هو أن الأول يسمح بأكثر من صنف واحد بينما يقتصر الأخير على صنف واحد يُسمح به في هذا الحد. التعريف SubjectCommandGroup حاوية لمجموعة الأوامر المسموح ظهورها كحد. فيما يلي قائمة المعطيات:
    <ul>
     <li><b>sbj, sbj1, sbj2, sbj3:</b> مؤشر أو مصفوفة من المؤشرات للأصناف الجائزة في الحد.</li>
     <li><b>frc, frc2, frc3:</b> تحديد ما إذا كان الصنف الذي داخل الأقواس اختيارياً. يُسمح بالقيم 0 و 1 في هذا المتغير. قيمة 1 تعني أن ما بين الأقواس ليس اختيارياً.</li>
     <li><b>fltr:</b> مرشّح لنوع الأقواس المسموح، وفي حالة Parameter و Literal فمرشح للأصناف المسموح بها.</li>
    </ul>
    
    <h3>تعريفات حدود مخصصة</h3>
    القلب يعرّف أيضاً مجموعة من الحدود المخصصة لبعض الأغراض العامة والمتاحة لمطوري مكتبات البناء:
<pre dir=ltr class="code">
// The default Tilde subject.
TildeSubject : module inherits Subject {
  Subject1.{sbj1=(SubjectCommandGroup);
            sbj2=(root.Expression); frc2=0;
            sbj3=(root.Expression); frc3=0};
  SubjectCommandGroup = ();
};

// A subject that doesn't allow sets.
NoSetSubject : module inherits Subject {
  Subject1.{sbj1=(Parameter, SubjectCommandGroup);
            sbj2=(root.Expression); frc2=0;
            sbj3=(root.Expression); frc3=0}
};

// A subject that doesn't allow brackets.
NoBracketSubject : module inherits Subject {
  Subject1.{sbj1=(Parameter, SubjectCommandGroup, root.Set);
            sbj2=(); frc2=0;
            sbj3=(); frc3=0}
};

// A subject that allows only identifiers.
IdSubject : module inherits Subject {
  start Parameter;
  Parameter.{fltr=0; cnsts=null}
};

// A subject that allows full identifiers (with . or -> operators).
FullIdSubject : module inherits Subject {
  start Subject2;
  Subject2.{obj=root.FullIdExpression; fltr=0; frc=0}
};

ModifierSubject : module inherits Subject {
  Subject1.{sbj1=(SubjectCommandGroup);
            sbj2=(root.Expression); frc2=0;
            sbj3=(root.Expression); frc3=0};
  SubjectCommandGroup = (UseModifierCmd);

  // @use modifier.
  UseModifierCmd : prule ref root.Cmd(kwd=("use"),
                                       args=((UseModifierSubject)));
  UseModifierSubject : module inherits root.FullIdSubject {
    Subject2.{fltr=2, frc=1}
  }
};
</pre>
   </div>

   <h3 class="foldable numbering">المجموعات</h3>
   <div>
    المجموعة، أو مجموعة الجمل، هي مجموعة من عدد غير محدد من الجمل محاطة بقوسين حاصرين. الجمل مفصولة عن بعضها بفارزة منقوطة. يمكن للمجموعة أن لا تحتوي على أي جملة فتكون عبارة عن قوسين حاصرين فارغين. المجموعة تستقبل مُعطى يشير إلى الجملة أو قائمة الجمل المضمنة وبالتالي يمكن إنشاء أنواع مختلفة من المجموعات للتعامل مع أنواع مختلفة من الجمل.
    
    <h3>التركيب النحوي</h3>
<pre dir=ltr class="code">
Set : "{" StatementList "}".
</pre>

    <h3>التعريف القواعدي</h3>
<pre dir=ltr class="code">
Set : @limit[child.terms==self,user.parent==self] prule
  prefix DefaultModifier
  as (stmt:prule[StatementList]=root.Main)=>{ lexer.Constant("{") + stmt + lexer.Constant("}") };
</pre>
   </div>
   
   <h3 class="foldable numbering">المبدّلات</h3>
   <div>
    المبدّلات عناصر قواعدية تحمل معلومات وصفية تُضاف إلى ما يأتي بعدها وتستخدم من قبل مكتبات البناء لأغراض مختلفة. عرّفت المبدلات كقواعد موازية وبالتالي فقد عُرفت بشكل منفصل عن القواعد التي تستخدمها. المبدّلات عبارة عن الرمز @ يليه حدّ واحد (ModifierSubject). يشير هذا الحدّ إلى:
    <ul>
     <li>مجموعة من الأوامر التي تستخدم لتعريف المعلومات الوصفية. يُمكن لمكتبات البناء تعريف أوامرها الخاصة وإضافتها لهذه المجموعة.</li>
     <li>قوسين اعتياديين أو مربعين يحتويان على تركيب.</li>
    </ul>
    تم تعريف البعد الإعرابي الخاص بالمبدّلات ليتفرع عن بداية أي قاعدة إعرابية، أي يفحص قاعدة المبدلات عن مدخل كل قاعدة إعرابية. عند الإنتهاء من إعراب المبدل يتم تنفيذ دالّة تعمل على إضافة المعلومات الوصفية إلى طابور المعلومات الوصفية مع تحديد قيمة targets وهي القيمة التي تستخدم لمزاوجة المعلومات الوصفية مع القواعد الإعرابية المعنية بها. تُقرأ قيمة targets من معلومات وصفية مرتبطة بالتعريف الإعرابي لأمر المبدّل وفي حالة المبدلات ذات التراكيب فتُستخدم القيمة DefaultModifier. تحدد الحزم والقواعد الإعرابية المعلومات الوصفية المرغوب استلامها باستخدام الأمر prefix والذي يظهر في الكثير من التعريفات القواعدية. التعريفات التي لا تحتوي على الأمر prefix لا تستلم أي معلومات وصفية. في القواعد المسبقة التعريف يُستخدم الاسم التعريفي للقاعدة الإعرابية كقيمة للأمر prefix.
    
    <h3>التركيب النحوي</h3>
<pre dir=ltr class="code">
Modifier : "@" Subject |
           "@>" Subject |
           "@<" Subject.
</pre>
    هناك ثلاث صيغ لكتابة المبدّل. الصيغتان الأولى والثانية متطابقتان وتعنيان أن الأسبقية في مزاوجة المعلومات الوصفية مع قاعدة إعرابية تكون للقاعدة الإعرابية الداخلية بينما تعطي الصيغة الثالثة الأسبقية للقاعدة الخارجية. على سبيل المثال، لو كانت القاعدة Subject تشير إلى القاعدة Parameter وكلتا القاعدتين تقبلان مبدّلاً معيناً فإن استخدام الصيغتين الأولى والثانية يُعطي المبدّل للقاعدة Parameter بينما تعطي الصيغة الثالثة المبدّل للقاعدة Subject.
    
    <h3>التعريفات القواعدية</h3>
<pre dir=ltr class="code">
Modifiers : module {
  start Modifier;

  // Modifier :
  // "@" Subject.
  // "@>" Subject.
  // "@<" Subject.
  Modifier : prule as { InnerModifier || OuterModifier };

  InnerModifier : prule as (operand:valid_subject=root.ModifierSubject)=>{
    root.Constants(("@", "@>")) + operand
  };

  OuterModifier : prule as (operand:valid_subject=root.ModifierSubject)=>{
    lexer.Constant("@<") + operand
  }
};

dimension {
  start : Modifiers;
  diverge : atRuleEntry;
  onExit : function (dt:ParsingData) {
    if dt.data.data.id == root.ModifierSubject.UseModifierCmd
      // Grammar overriding modifier.
      override dt.data.data.data
    else if dt.data.data.route == 0
      // Command based modifiers (specifies their own targets).
      addPrefix data=dt.data.data.data, type=dt.data.data.id,
                targets=prule(dt.data.data.id).targets, priority=(dt.route==0?inner,outer)
    else
      // Expression based modifiers (uses a default target).
      addPrefix data=dt.data.data.data, type=dt.data.data.id,
                targets=DefaultModifier, priority=(dt.route==0?inner,outer)
  }
}
</pre>
   </div>
  </div>
  
  <h3 class="foldable numbering">الأوامر الأساسية</h3>
  <div>
   <h3 class="foldable numbering">import</h3>
   <div>
    يستخدم هذا الأمر لكل أنواع الاستيراد سواء استيراد ملف شفرة مصدرية أو مكتبة ساكنة أو مكتبة فعّالة. يسمح القلب بإضافة سوائس جديدة لعملية الاستيراد تسمح باستيراد أنواع أخرى من الملفات.
    
    <h3>التركيب النحوي</h3>
<pre dir=ltr class="code">
Import : "import" Expression.
</pre>

    <h3>التعريف القواعدي</h3>
<pre dir=ltr class="code">
ImportCmd : prule inherits SoloCommand
  ref root.Cmd(kwd=("use"), args=((prd=root.Expression, min=1, max=1, pty=in)));
</pre>
   </div>
   
   <h3 class="foldable numbering">use</h3>
   <div>
    يستخدم هذا الأمر لتفعيل مجموعة من القواعد في المجال الذي يظهر فيه. بمعنى آخر، يمكن تحميل مجموعة من القواعد دون المباشرة بتفعيلها حتى يصادف المترجم هذا الأمر. يتوفر هذا الأمر أيضاً بصيغة مبدّل يسمح بتفعيل مجموعة القواعد فقط على الجملة التي يطبَّق عليها المبدّل.
    
    <h3>التركيب النحوي</h3>
<pre dir=ltr class="code">
UseCmd : "use" FullIdSubject [IdSubject].
UseModifierCmd : "use" "[" FullIdSubject "]".
</pre>

    <h3>التعريف القواعدي</h3>
<pre dir=ltr class="code">
UseCmd : prule inherits SoloCommand
  ref root.Cmd(kwd=("use"), args=((prd=root.FullIdSubject, min=1, max=1, pty=in),
                                  (prd=root.IdSubject, min=0, max=1, pty=in)))
  handle onProductionEnd : function (dt:ParsingData) {
    if dt.data(1) == null
      override dt.data(0)
    else
      defGrammar dt.data(1), dt.data(0)
  };
UseModifierCmd : prule ref root.Cmd(kwd=("use"),
                                    args=((UseModifierSubject)));
UseModifierSubject : module inherits root.FullIdSubject {
  Subject2.{fltr=2, frc=1}
}
</pre>

    <h3>أمثلة</h3>
    استخدام مبدّل use لتفعيل مجموعة قواعد ضمن جملة واحدة:
<pre dir=ltr class="samplecode">
@use[myGrammar] myGrammarCmd "...";
</pre>
    استخدام الأمر use لتفعيل مجموعة قواعد ضمن المجال الحالي:
<pre dir=ltr class="samplecode">
use myGrammar;
myGrammarCmd "...";
</pre>
    استخدام الأمر use لإنشاء اختصار لمجموعة القواعد يمكن استخدامه لاحقاً في مبدّل use:
<pre dir=ltr class="samplecode">
use myGrammar g;
@use[g] myGrammarCmd "...";
</pre>
   </div>
  </div>
  
  <h3 class="foldable numbering">الإشعارات</h3>
  <div>
   يُطلق القلب إشعارات مختلفة للإشعار عن أخطاء أو ماشابه. يحتوي الإشعار على المعلومات التالية:
   <ul>
    <li><b>Code:</b> شفرة لتمييز الإشعار بشكل فريد.</li>
    <li><b>Severity:</b> حدة أو درجة خطورة الإشعار. القيم المحتملة لهذه المعلومة هي:
     <ul>
      <li>0: أشد الإشعارات حدّة. تشير إلى خطأ لا يستطيع معه القلب من الاستمرار.</li>
      <li>1: تشير إلى خطأ يستطيع القلب معه الاستمرار بعد إهمال الجزء الذي يحتوي الخطأ.</li>
      <li>2: تحذير مهم يجب على المستخدم الانتباه إليه، لكن لم يُهمل أي جزء من البرنامج الخاضع للترجمة.</li>
      <li>3: تحذير يمكن للمستخدم إهماله.</li>
      <li>4: إسترعاء انتباه المستخدم، لكن المستخدم لا يحتاج لاتخاذ أي إجراء.</li>
     </ul>
    </li>
    <li><b>Description:</b> شرح لمعنى الإشعار.</li>
    <li><b>Filename:</b> إسم الملفِّ مصدرِ الإشعار.</li>
    <li><b>Line:</b> رقم السطرِ مصدرِ الإشار.</li>
    <li><b>Column:</b> رقم العمودِ مصدرِ الإشعار.</li>
   </ul>
   
   فيما يلي قائمة بالإشعارات التي يطلقها القلب أثناء عملية الترجمة:
   <table class="dict">
    <tr>
     <th>الشفرة (code)</th>
     <th>الشدة (severity)</th>
     <th>الوصف</th>
    </tr>
    <tr>
     <td>L1001</td>
     <td>1</td>
     <td>يطلق هذا الإشعار عند مصادفة المرمّز لمحارف لا تنتمي لأي قاعدة ترميزية.</td>
    </tr>
    <tr>
     <td>L1002</td>
     <td>1</td>
     <td>صوان المحارف المدخلة ممتلئ. الرمز أطول من سعة الصوان وقد يتم تقسيم الرمز إلى عدة رموز.</td>
    </tr>
    <tr>
     <td>L2001</td>
     <td>2</td>
     <td>صوان المحارف المدخلة ممتلئ. الرمز أطول من سعة الصوان ما يؤدي إلى إقتطاع بعض المحارف من الرمز.</td>
    </tr>
    <tr>
     <td>P1001</td>
     <td>1</td>
     <td>خطأ إعرابي. سيتم تجاوز الجملة الخاطئة إلى التي تليها.</td>
    </tr>
    <tr>
     <td>P1002</td>
     <td>1</td>
     <td>المعرب أنهى عملية الإعراب قبل إكمال القاعدة الإعرابية الجذرية.</td>
    </tr>
    <tr>
     <td>P1003</td>
     <td>1</td>
     <td>المعرب استلم رمزاً بعد أن أنهى عملية الإعراب بإكمال القاعدة الإعرابية الجذرية.</td>
    </tr>
    <tr>
     <td>P2001</td>
     <td>2</td>
     <td>الغموض الإعرابي يتسبب في تشعب المعرب إلى وضعيات متعددة.</td>
    </tr>
    <tr>
     <td>S1001</td>
     <td>1</td>
     <td>تعريف مكرر. الشفرة المصدرية تحتوي تعريفين بنفس الإسم. التعريف الثاني سيهمَل.</td>
    </tr>
    <tr>
     <td>IMP1001</td>
     <td>1</td>
     <td>فشل الاستيراد. فشل تحميل الملف المعني.</td>
    </tr>
    <tr>
     <td>G1001</td>
     <td>1</td>
     <td>خطأ مجهول.</td>
    </tr>
   </table>
  </div>
  
  <h3 class="foldable numbering">المتن القواعدي الكامل</h3>
  <div>
<pre dir=ltr class="code">
////////////////////////////////////////////////////////////////////////////
// Type Definitions

// A list of keywords.
keywords : type list[string];

// A value for the filter modifier.
filter : type integer || list[integer];

// A list of productions that can be used as subjects.
valid_subject : type prule[Subject||Subject.Parameter||Command||Expression||Main.Statement||Set];


////////////////////////////////////////////////////////////////////////////
// Token Data Definitions

TokenData : module {
  // The set of postfixes used to specify character coding (ascii, unicode, etc.).
  charCodes : list[string] = ("u", "u8", "u16", "u32", "a");

  // Escape Sequences
  escapeSequences : keywords = (
    // invisible characters:
    "\\n", "\\r", "\\t", "\\b", "\\f", "\\0",
    // special characters:
    "\\\'", "\\\"", "\\\\", "\\!",
    // regular expressions characters:
    "\\[", "\\]", "\\(", "\\)", "\\*", "\\+",
    "\\.", "\\?", "\\|", "\\^", "\\$");

  // Predefined Operator Lists
  assignmentOpList : keywords = ("=", "+=", "-=", "*=", "/=", "%=", "&=", "|=", "$=",
                                  "<<=", ">>=");
  comparisonOpList : keywords = ("==", "!=", "<", ">", "<=", ">=");
  addOpList : keywords = ("+", "-");
  mulOpList : keywords = ("*", "/", "%");
  bitwiseOpList : keywords = ("|", "$", "&", "<<", ">>");
  logOpList : keywords = ("||", "$$", "&&", "or", "nor", "xor", "xnor", "and", "nand");
  prefixOpList : keywords = ("++", "--", "+", "-", "!", "!!", "not");
  postfixOpList : keywords = ("++", "--");
  linkOpList : keywords = ("->", ".", ".>", "<.");
  lowLinkOpList : keywords = ("=>", "..", "..>", "<..");
  lowerLinkOpList : keywords = (":", ":>", "<:");
  lowestLinkOpList : keywords = ("::", "::>", "<::", "in")
};


////////////////////////////////////////////////////////////////////////////
// Lexer Definitions

lexer LexerDefs;

LexerDefs : module {
  ////////////////////////////////////////////////////////////////////////
  // Character Group Definitions

  BinDigit : char '0'..'1';
  OctDigit : char '0'..'7';
  DecDigit : char '0'..'9';
  HexDigit : char '0'..'9', 'a'..'f', 'A'..'F';
  Letter : char 'a'..'z', 'A'..'Z', '_';
  AnyCharNoEs : char ^('\\');
  AnyCharNoEsOrSingleQuote : char ^("\\'");
  AnyCharNoEsOrDoubleQuote : char ^("\\\"");
  Spacing : char " \n\r\t";

  ////////////////////////////////////////////////////////////////////////
  // Token Definitions

  // Identifiers
  // letter {letter|decDigit}.
  Identifier : trule as { Letter + (Letter || DecDigit)*(0,endless) };

  // Integer Literals
  // [prefix] digit {digit} ["u"] ["i" num].
  IntLiteral : trule as {
    (DecIntLiteral || BinIntLiteral || OctIntLiteral || HexIntLiteral) +
    ("u" || "U")*(0,1) + (("i" || "I") + DecIntLiteral)*(0,1)
  };
  @inner DecIntLiteral : trule as { DecDigit*(1,endless) };
  @inner BinIntLiteral : trule as { ("0b" || "0B") + BinDigit*(1,endless) };
  @inner OctIntLiteral : trule as { ("0o" || "0O") + OctDigit*(1,endless) };
  @inner HexIntLiteral : trule as { ("0h" || "0H") + HexDigit*(1,endless) };

  // Float Literals
  // num "." num ["e" ["+"|"-"] num] ["f" num].
  FloatLiteral : trule as {
    DecDigit*(1,endless) + FloatPostfix ||
    DecDigit*(1,endless) + FloatExponent + FloatPostfix*(0,1) ||
    DecDigit*(1,endless) + "." + DecDigit*(1,endless) +
      FloatExponent*(0,1) + FloatPostfix*(1,1)
  };
  @inner FloatExponent : trule as { ("e" || "E") + ("+" || "-")*(0,1) + DecDigit*(1,endless) };
  @inner FloatPostfix : trule as { ("f" || "F") + DecDigit*(0,endless) };

  // Character And String Literals
  // charLiteral: "'" esCharWithDoubleQuote "'" [charCodePostfix].
  // stringLiteral: "\"" {esCharWithSingleQuote} "\"" [charCodePostfix].
  CharLiteral : trule as { "'" + EsCharWithDoubleQuote + "'" + CharCodePostfix*(0,1) };
  StringLiteral : trule as {
    StringLiteralPart + (Spacing*(0,endless) + StringLiteralPart)*(0,endless) +
    CharCodePostfix*(0,1)
  };
  @inner StringLiteralPart : trule as { "\"" + EsCharWithSingleQuote*(0,endless) + "\"" };
  @inner CharCodePostfix : trule as { alternate (root.TokenData.charCodes:cc)->( cc ) };

  // Custom Literals
  // "!" prefix "<" {esCharWithQuotes} ">" [postfix] "!".
  CustomLiteral : trule as (@unique prefix:keywords,postfix:keywords)=>{
    "!" + alternate (prefix:p)->( p ) + "<" + EsCharWithQuotes*(0,endless) +
    (">!" + Spacing*(0,endless) + "!<" + EsCharWithQuotes*(0,endless))*(0,endless) +
    ">" + (alternate (postfix:p)->( p ))*(0,1) + "!"
  };

  // String Characters
  @inner EsCharWithSingleQuote : trule as {
    AnyCharNoEsOrDoubleQuote || EsSequence ||
    alternate (root.TokenData.escapeSequences:es)->( es )
  };
  @inner EsCharWithDoubleQuote : trule as {
    AnyCharNoEsOrSingleQuote || EsSequence ||
    alternate (root.TokenData.escapeSequences:es)->( es )
  };
  @inner EsCharWithQuotes : trule as {
    AnyCharNoEs || EsSequence || alternate (root.TokenData.escapeSequences:es)->( es )
  };
  @inner EsSequence : trule as {
    '\\' + ('c' + HexDigit*(2,2) ||
            'u' + HexDigit*(4,4) ||
            'w' + HexDigit*(8,8) ||
            'n' || 't' || 'r')
  };

  // Constants
  Constant : trule as (@unique cnst:string)=>{ cnst };

  ////////////////////////////////////////////////////////////////////////
  // Ignore spacing (' ', '\n', '\r', '\t') when they don't belong to any token

  ignore { Spacing*(1,endless) };
  @minimum ignore { "/*" + any*(0,endless) + "*/" };
  @minimum ignore { "//" + any*(0,endless) + "\n" }
};


////////////////////////////////////////////////////////////////////////////
// Parser Productions
// NOTE:
//  The syntax written in comments is just an approximation of the actual syntax.
//  This commented syntax is written just to give the reader a simplified outline
//  of the actual syntax of the element.

start Program;

//////****** Main ******//////

// Program : StatementList.
Program : prule as { root.Main };

// Keywords and Constants
KeywordGroup : prule as (kwds:keywords)=>{ alternate (kwds:k)->( Keyword(k) ) };
Keyword : prule as (@unique kwd:string)=>{ lexer.Identifier(kwd) };
Constants : prule as (kwds:keywords)=>{ alternate (kwds:k)->( lexer.Constant(k) ) };

Main : module {
  start StatementList;

  // StatementList : Statement { ";" Statement }.
  StatementList : prule as {
    Statement*(0, 1) + (lexer.Constant(";") + Statement*(0, 1))*(0, endless)
  };

  // Statement : (Phrase | Phrase | ...).
  Statement : @limit[user.parent==self,child.terms==self] prule
    prefix self.id, DefaultModifier
    as (phrases:list[prule[Phrase]]=(CmdPhrase, SoloCmdPhrase, ExpPhrase)=>{
      alternate (phrases:phrase)->( phrase )
    };

  // Phrase : { Subject }.
  Phrase : prule as (subjects:list[map[prd:valid_subject, min:integer, max:integer,
                                       pty:integer]])=>{
    concat (subjects:s)->( @priority(s.pty,0) s.prd*(s.min,s.max) )
  };

  // Default phrases.
  CmdPhrase : prule ref Phrase(subjects=((prd=LeadingCmdGroup,min=1,max=1),
                                         (prd=TrailingCmdGroup,min=0,max=endless)));
  SoloCmdPhrase : prule ref Phrase(subjects=((prd=SoloCmdGroup,min=1,max=1)));
  ExpPhrase : prule ref Phrase(subjects=((prd=root.Expression,min=1,max=1),
                                         (prd=TrailingCmdGroup,min=0,max=endless)));

  // Default Command Types
  LeadingCommand : prule inherits root.Command prefix self.id;
  TrailingCommand : prule inherits root.Command prefix self.id;
  SoloCommand : prule inherits root.Command prefix self.id;

  // Default Command Groups
  LeadingCmdGroup : prule_group[LeadingCommand];
  TrailingCmdGroup : prule_group[TrailingCommand];
  SoloCmdGroup : prule_group[SoloCommand] = (ImportCmd, UseCmd);

  // 'import' command.
  ImportCmd : prule inherits SoloCommand
    ref root.Cmd(kwd=("use"), args=((prd=root.Expression, min=1, max=1, pty=in)));

  // 'use' command.
  UseCmd : prule inherits SoloCommand
    ref root.Cmd(kwd=("use"), args=((prd=root.FullIdSubject, min=1, max=1, pty=in),
                                    (prd=root.IdSubject, min=0, max=1, pty=in)))
    handle onProductionEnd : function (dt:ParsingData) {
      if dt.data(1) == null
        override dt.data(0)
      else
        defGrammar dt.data(1), dt.data(0)
    };
};

//////****** Commands ******//////

// Root Command
Command : @limit[child.terms==(Cmd||MultiCmd)] prule
  prefix self.id, DefaultModifier;

// Cmd : keyword {Subject}.
Cmd : @limit[user.parent==root.Command] prule
  as (kwd:keywords, args:list[map[prd:valid_subject, min:integer, max:integer, pty:integer]])=>{
    root.KeywordGroup(kwd) + concat (args:a)->( @priority(a.pty,0) a.prd*(a.min,a.max) )
  };

// MultiCmd : {keyword {Subject}}.
MultiCmd : @limit[user.parent==root.Command] prule
  as (sections:list[map[kwd:keywords, min:integer, max:integer, pty:integer,
                        args:list[map[prd:valid_subject, min:integer, max:integer, pty:integer]]
                       ]])=>{
    concat (sections:s)->(
      @priority(s.pty,0) (root.KeywordGroup(s.kwd) + concat (s.args:a)->(
        @priority(a.pty,0) a.arg*(a.min, a.max)
      ))*(s.min, s.max)
    )
  };

//////****** Expressions ******//////

// Expression :
// operand {binaryOp operand}.
// [unaryOp] operand.
// operand [unaryOp].
// operand {FunctionalOp}.
Expression : module {
  prefix self.id, DefaultModifier;
  start Exp;

  Exp : prule as { LowestLinkExp + (@priority(in,0) lexer.Constant("\\")*(0,1)) };
  LowestLinkExp : prule prefix self.id as (enable:integer=endless)=>{
    ConditionalExp + (@priority(in,0) (LowestLinkOp + ConditionalExp)*(0,enable))
  };
  ConditionalExp : prule prefix self.id  as (enable:integer[0<=n<=1]=1)=>{
    ListExp + (@priority(in,0) (lexer.Constant("?") + ListExp)*(0,enable))
  };
  ListExp : prule prefix self.id as (enable:integer=endless)=>{
    (@priority(in,0) lexer.Constant(",")*(0,enable)) + LowerLinkExp +
    (@priority(in,0) (lexer.Constant(",") + LowerLinkExp*(0,1))*(0,enable))
  };
  LowerLinkExp : prule prefix self.id as (enable:integer=endless)=>{
    AssignmentExp + (@priority(in,0) (LowerLinkOp + AssignmentExp)*(0,enable))
  };
  AssignmentExp : prule prefix self.id as (enable:integer=endless)=>{
    LogExp + (@priority(in,0) (AssignmentOp + LogExp)*(0,enable))
  };
  LogExp : prule prefix self.id as (enable:integer=endless)=>{
    ComparisonExp + (@priority(in,0) (LogOp + ComparisonExp)*(0,enable))
  };
  ComparisonExp : prule prefix self.id as (enable:integer=endless)=>{
    LowLinkExp + (@priority(in,0) (ComparisonOp + LowLinkExp)*(0,enable))
  };
  LowLinkExp : prule prefix self.id as (enable:integer=endless)=>{
    AddExp + (@priority(in,0) (LowLinkOp + AddExp)*(0,enable))
  };
  AddExp : prule prefix self.id as (enable:integer=endless)=>{
    MulExp + (@priority(in,0) (AddOp + MulExp)*(0,enable))
  };
  MulExp : prule prefix self.id as (enable:integer=endless)=>{
    BitwiseExp + (@priority(in,0) (MulOp + BitwiseExp)*(0,enable))
  };
  BitwiseExp : prule prefix self.id as (enable:integer=endless)=>{
    UnaryExp + (@priority(in,0) (BitwiseOp + UnaryExp)*(0,enable))
  };
  UnaryExp : prule prefix self.id as (enable1:integer[0<=n<=1]=1, enable2:integer[0<=n<=1]=1)=>{
    (@priority(in,0) PrefixOp*(0,enable1)) + FunctionalExp +
    (@priority(in,0) PostfixOp*(0,enable2))
  };
  FunctionalExp : prule prefix self.id
    as (operand:valid_subject=root.Subject, fltr:filter=null, dup:integer=endless,
        pty:integer=in)=>{
      operand + (@priority(pty,0) (@filter(fltr) ParamPassExp ||
                                                 TildeExp ||
                                                 LinkExp(operand))*(0,dup))
    };

  // ParamPassExp : "(" [Expression] ")" | "[" [Expression] "]".
  ParamPassExp : prule as (expr:prule[Expression||Statement]=root.Expression, fltr:filter=null)=>{
    @filter(fltr) lexer.Constant("(") + expr*(0,1) + lexer.Constant(")") ||
                  lexer.Constant("[") + expr*(0,1) + lexer.Constant("]")
  };

  // TildeExp : "~" Subject.
  TildeExp : prule as (operand:valid_subject=root.TildeSubject)=>{ lexer.Constant("~") + operand };

  // LinkExp : LinkOp operand.
  LinkExp : prule as (operand:valid_subject=root.Subject)=>{ LinkOp + operand };

  // Operators :
  AssignmentOp : prule as { root.Constants(root.TokenData.assignmentOpList) };
  ComparisonOp : prule as { root.Constants(root.TokenData.comparisonOpList) };
  AddOp : prule as { root.Constants(root.TokenData.addOpList) };
  MulOp : prule as { root.Constants(root.TokenData.mulOpList) };
  BitwiseOp : prule as { root.Constants(root.TokenData.bitwiseOpList) };
  LogOp : prule as { root.Constants(root.TokenData.logOpList) };
  PrefixOp : prule as { root.Constants(root.TokenData.prefixOpList) };
  PostfixOp : prule as { root.Constants(root.TokenData.postfixOpList) };
  LinkOp : prule as { root.Constants(root.TokenData.linkOpList) };
  LowLinkOp : prule as { root.Constants(root.TokenData.lowLinkOpList) };
  LowerLinkOp : prule as { root.Constants(root.TokenData.lowerLinkOpList) };
  LowestLinkOp : prule as { root.Constants(root.TokenData.lowestLinkOpList) }
};

// An expression that blocks sets.
NoSetExpression : module inherits Expression {
  FunctionalExp.operand = root.NoSetSubject;
  LinkExp.operand = root.NoSetSubject;
};

// An expression that doesn't allow brackets.
NoBracketExpression : module inherits Expression {
  FunctionalExp.{operand=root.NoBracketSubject; fltr=(0,1,1); dup=endless; pty=in};
  LinkExp.operand = root.NoBracketSubject;
};

// An expression that allows only identifiers with link operators.
FullIdExpression : module inherits Expression {
  start FunctionalExp;
  FunctionalExp.{operand=IdSubject; fltr=2; dup=endless; pty=in};
  LinkExp.operand = root.IdSubject;
};

//////****** Subjects ******//////

// Subject : (Parameter | Command | Expression | Statement | Set) |
//           "(" (Parameter | Command | Expression | Statement | Set) ")" |
//           "[" (Parameter | Command | Expression | Statement | Set) "]".
Subject : module {
  prefix self.id, DefaultModifier;
  start Subject1;

  Subject1 : prule as (sbj1:list[prule[Parameter||root.Command||root.Expression||
                                       root.Main.Statement||root.Set]]
                           =(Parameter, SubjectCommandGroup, root.Set),
                       sbj2:list[prule[Parameter||root.Command||root.Expression||
                                       root.Main.Statement||root.Set]]
                           =(root.Expression),
                       sbj3:list[prule[Parameter||root.Command||root.Expression||
                                       root.Main.Statement||root.Set]]
                           =(root.Expression),
                       fltr:filter=null, frc2:integer=0, frc3:integer=0)=>{
    @filter(fltr)
      alternate (sbj1:s)->( s ) ||
      lexer.Constant("(") + (alternate (sbj2:s)->( s ))*(frc2,1) + lexer.Constant(")") ||
      lexer.Constant("[") + (alternate (sbj3:s)->( s ))*(frc3,1) + lexer.Constant("]")
  };
  Subject2 : @limit[user.owner==Subject] prule
    as (sbj:prule[Parameter||root.Command||root.Expression||root.Main.Statement||root.Set],
        fltr:filter, frc:integer)=>{
        @filter(fltr) sbj ||
                      lexer.Constant("(") + sbj*(frc,1) + lexer.Constant(")") ||
                      lexer.Constant("[") + sbj*(frc,1) + lexer.Constant("]")
    };

  // Commands
  SubjectCommand : prule inherits root.Command prefix self.id;
  SubjectCommandGroup : prule_group[SubjectCommand];

  // Parameter: Identifier | Literal.
  Parameter : prule prefix self.id
    as (fltr:filter=null, cnsts:keywords=null)=>{
      @filter(fltr) lexer.Identifier || Literal || root.Constants(cnsts)
    };

  // Literal: IntLiteral | FloatLiteral | CharLiteral | StringLiteral | CustomLiteral.
  Literal : prule as (fltr:filter=null)=>{
    @filter(fltr) lexer.IntLiteral || lexer.FloatLiteral || lexer.CharLiteral ||
                  lexer.StringLiteral || lexer.CustomLiteral
  }
};

// The default Tilde subject.
TildeSubject : module inherits Subject {
  Subject1.{sbj1=(SubjectCommandGroup);
            sbj2=(root.Expression); frc2=0;
            sbj3=(root.Expression); frc3=0};
  SubjectCommandGroup = ();
};

// A subject that doesn't allow sets.
NoSetSubject : module inherits Subject {
  Subject1.{sbj1=(Parameter, SubjectCommandGroup);
            sbj2=(root.Expression); frc2=0;
            sbj3=(root.Expression); frc3=0}
};

// A subject that doesn't allow brackets.
NoBracketSubject : module inherits Subject {
  Subject1.{sbj1=(Parameter, SubjectCommandGroup, root.Set);
            sbj2=(); frc2=0;
            sbj3=(); frc3=0}
};

// A subject that allows only identifiers.
IdSubject : module inherits Subject {
  start Parameter;
  Parameter.{fltr=0; cnsts=null}
};

// A subject that allows full identifiers (with . or -> operators).
FullIdSubject : module inherits Subject {
  start Subject2;
  Subject2.{obj=root.FullIdExpression; fltr=0; frc=0}
};

ModifierSubject : module inherits Subject {
  Subject1.{sbj1=(SubjectCommandGroup);
            sbj2=(root.Expression); frc2=0;
            sbj3=(root.Expression); frc3=0};
  SubjectCommandGroup = (UseModifierCmd);

  // @use modifier.
  UseModifierCmd : prule ref root.Cmd(kwd=("use"),
                                      args=((UseModifierSubject)));
  UseModifierSubject : module inherits root.FullIdSubject {
    Subject2.{fltr=2, frc=1}
  }
};

//////****** Sets ******//////

// Set : "{" StatementList "}".
Set : @limit[child.terms==self,user.parent==self] prule
  prefix DefaultModifier
  as (stmt:prule[StatementList]=root.Main)=>{ lexer.Constant("{") + stmt + lexer.Constant("}") };

//////****** Modifiers ******//////

Modifiers : module {
  start Modifier;

  // Modifier :
  // "@" Subject.
  // "@>" Subject.
  // "@<" Subject.
  Modifier : prule as { InnerModifier || OuterModifier };

  InnerModifier : prule as (operand:valid_subject=root.ModifierSubject)=>{
    root.Constants(("@", "@>")) + operand
  };

  OuterModifier : prule as (operand:valid_subject=root.ModifierSubject)=>{
    lexer.Constant("@<") + operand
  }
};

dimension {
  start : Modifiers;
  diverge : atRuleEntry;
  onExit : function (dt:ParsingData) {
    if dt.data.data.id == root.ModifierSubject.UseModifierCmd
      // Grammar overriding modifier.
      override dt.data.data.data
    else if dt.data.data.route == 0
      // Command based modifiers (specifies their own targets).
      addPrefix data=dt.data.data.data, type=dt.data.data.id,
                targets=prule(dt.data.data.id).targets, priority=(dt.route==0?inner,outer)
    else
      // Expression based modifiers (uses a default target).
      addPrefix data=dt.data.data.data, type=dt.data.data.id,
                targets=DefaultModifier, priority=(dt.route==0?inner,outer)
  }
}
</pre>
  </div>
 </div>

 <!-- ********************************************************************** -->
 <h2 class="foldable numbering">معايير القلب التطبيقية</h2>
 <div>
 <span style="color:red;">قيد الإنشاء</span>
 </div>
 
 <!-- ********************************************************************** -->
 <h2 class="foldable">ملحق: صيغ التدوين</h2>
 <div>
  هذا الفصل يحتوي على شرح لصيغ التدوين في هذه الوثيقة.
  
  <h3 class="foldable">أقسام ورموز الوثيقة</h3>
  <div>
  <p><b>الكلمات التمييزية: </b>تكتب <span class="kwd">الكلمات التمييزية</span> باللون الأزرق.</p>
 
  <p><b>الشفرات المصدرية: </b>تكتب الشفرات المصدرية داخل مستطيل بخلفية غامقة اللون.</p>
 
  <p><b>الأمثلة: </b>تكتب الأمثلة داخل مستطيل مشابه للشفرات المصدرية ولكنه بخلفية بيضاء.</p>
 
  <h3>فصول شرح المعايير</h3>
  تقسم فصول شرح معايير اللغة إلى عدة أقسام:
  <p><b>مقدمة: </b>يحتوي على شرح مبسّط وسريع للعنصر المعني.</p>
  <p><b>التعريف القواعدي: </b>يحتوي على شرح القاعدة الإعرابية (parsing rule) أو القاعدة الترميزية (tokenizing rule) للعنصر المعني بشكل مفصّل. تفسّر هذه القاعدة كيفية تحليل العنصر وتمثيله رقميّاً.</p>
  <p><b>التركيب النحوي (syntax): </b>يحتوي على شرح مبسّط لتركيب هذا العنصر وكيفية استخدامه من قبل المبرمج. الغرض من هذا القسم تبسيط فهم القاعدة ولكنه لا يكفي لفهم كيفية تحليل العنصر وتمثيله رقميّاً.</p>
  <p><b>الشروط: </b> يحتوي الشروط اللازم توفرها كي يُقبل العنصر المعني من قبل المترجم. </p>
  <p><b>النتيجة: </b> يحتوي على نتيجة العملية، إن كان للعملية نتيجة. يُعلّم المتغير بعلامة ' للإشارة إلى قيمته بعد العملية. على سبيل المثال:
<pre class="samplecode">
var' = var + 1
</pre>
  </p>
  <p><b>العملية: </b> يحتوي على التفاصيل المعنية بطريقة التنفيذ وخطواتها، أي أسلوب عمل المترجم أثناء ترجمة أو تنفيذ العنصر المعني. </p>
  <p><b>الردود: </b> يحتوي على كافة الردود الممكنة من قبل المترجم أو المعرِب لكل حالة من الحالات.</p>
  لا يحتوي كل فصل على كل هذه الأقسام بالضرورة، بل قد يحتوي على بعضها فقط حسب الحاجة.
  </div>
  
  <h3 class="foldable">تدوين التراكيب النحوية</h3>
  <div>
  التراكيب في هذه الوثيقة تتبع صيغة EBNF وكما يلي:
  <p><table class="dict">
  <tr><td>العناصر غير الطرفية (non-terminals)</td><td>تُكتب بكلمات مفصولة بشارحة سفلية، مع تكبير (capitalize) الحرف الأول من كلّ كلمة.</td></tr>
  <tr><td>العناصر الطرفية (terminals)</td><td>تُكتب بكلمات مفصولة بشارحة سفلية وباستخدام الأحرف الصغيرة.</td></tr>
  <tr><td>سلسلة محارف فارغة </td><td> تكتب "".</td></tr>
  <tr><td>الفراغات</td><td>الفراغات غير مؤثرة.</td></tr>
  <tr><td>|</td><td>يُمثّل التبادل (عملية أو).</td></tr>
  <tr><td>التسلسل</td><td>التسلسل يمثَّل بوضع العناصر المتسلسلة بعد بعضها دون فاصل.</td></tr>
  <tr><td>( )</td><td>يُستخدم لتجميع العناصر.</td></tr>
  <tr><td>[ ]</td><td>يُستخدم لتمثيل العناصر أو المجموعات الإختيارية.</td></tr>
  <tr><td>{ }</td><td>يُمثّل التكرار مع إمكانية الغياب.</td></tr>
  <tr><td>:</td><td>يُستخدم لفصل اسم العنصر عن تركيبه النحوي.</td></tr>
  <tr><td>.</td><td>يوضع في نهاية التعريف.</td></tr>
  </table></p>
  للتسلسل أسبقية على التبادل. على سبيل المثال، التركيبان التاليان متساويان:
<pre class="samplecode" dir=ltr>
a b c | d
(a b c) | d
</pre>
  </div>
  
  <h3 class="foldable">تدوين القواعد</h3>
  <div>
   تقنيات القواعد والتحليل المتبعة في لغة الأسُس لا تُغطّيها صيغ تعريف القواعد الشائعة مثل EBNF ولذلك فإن هذه الوثيقة تتبع صيغة تدوين خاصّة تستطيع شرح هذه القواعد بدقّة، فبينما يبين التدوين المذكور في الفصل السابق الشكل العام للجملة، فإن التدوين في هذا الفصل يشرح بدقة كيفية تمثيل هذه القواعد في الهياكل البيانية للقلب.
   هذا التدوين في الحقيقة يستخدم القوالب القواعدية للغة الأسُس نفسها، ما يثبت أن اللغة قادرة على تمثيل أي شفرة كانت.
  
   <h3>التدوين</h3>
   <table class="dict">
   <tr><td>العناصر</td><td>تُكتب بكلمات مفصولة بشارحة سفلية، مع تكبير (capitalize) الحرف الأول من كلّ كلمة. يُستخدم هذا التدوين لتمثيل العناصر النهائية وغير النهائية بالإضافة إلى مجموعات المحارف.</td></tr>
   <tr><td>الثوابت</td><td>تُحصر الثوابت بين علامتي اقتباس ويشمل هذا العناصر النهائية الثابتة بالإضافة إلى مجموعات المحارف.</td></tr>
   <tr><td>سلسلة محارف فارغة </td><td> تكتب "".</td></tr>
   <tr><td>المتغيّرات</td><td>المتغيرات تمثل بكلمات مفصولة بشارحة سفلية وباستخدام الأحرف الصغيرة.</td></tr>
   <tr><td>الفراغات</td><td>الفراغات غير مؤثرة.</td></tr>
   <tr><td>||</td><td>يُمثّل التبادل (عملية أو). أي أن المُعرب يقبل أيّاً من العناصر المفصولة بهذا الرمز.</td></tr>
   <tr><td>+</td><td>تمثّل التسلسل. أي أن العناصر المفصولة بهذا الرمز يجب أن تأتي متسلسلة في الشفرة المصدرية.</td></tr>
   <tr><td>*</td><td>تمثّل التكرار. يُتبع بقائمة من عنصرين مفصولين بفارزة يمثّل الأول منهما الحد الأدنى للتكرار بينما يمثّل الآخر الحد الأعلى. لتمثيل تكرار مفتوح (دون حد أعلى) تُستخدم الكلمة 'endless'. يمكن للحذ الأعلى أن يكون صفراً ما يعني تعطيل العنصر المعني. يمكن استخدام قيمة ضمنية للحدين الأعلى والأدنى ويمكن أيضاً تمثيلهما بمتغيرات.</td></tr>
   <tr><td>( )</td><td>يُستخدم لتجميع العناصر، أو لتعريف متغيرات القوالب.</td></tr>
   <tr><td>:</td><td>يُستخدم لفصل اسم العنصر عن قاعدته النحوية.</td></tr>
   <tr><td>;</td><td>يُستخدم لفصل التعريفات عن بعضها.</td></tr>
   <tr><td>@</td><td>يُستخدم لتمييز المبدلات القواعدية.</td></tr>
   <tr><td>/* */</td><td>يُستخدم لكتابة التعليقات والملاحظات المتعددة الأسطر.</td></tr>
   <tr><td>//</td><td>يستخدم لكتابة الملاحظات المفردة السطر.</td></tr>
   </table>
   <p>
   للتسلسل أسبقية على التبادل. على سبيل المثال، التركيبان التاليان متساويان:
<pre class="samplecode" dir=ltr>
a + b + c || d
(a + b + c) || d
</pre>
   </p>
   
   <h3>التعريفات</h3>
   قواعد لغة الأسُس تتكون من سلسلة من التعريفات مفصولة بفارزة منقوطة. كل تعريف من هذه التعريفات يأخذ الصيغة التالية:
<pre dir=ltr class="code">
Identifier ":" DefinitionCommand
</pre>
   الأمر التعريفي (definition command) يختلف بتركيبه حسب نوع التعريف، ولكنّه يبدأ دائماً بكلمة تمييزية تحدد نوع هذا التعريف. اسم التعريف لا يُمكن تكراره ضمن مجال واحد. فيما يلي قائمة بالأوامر التعريفية الممكنة:
   <p><span class="kwd">type</span><br/>
   يعرّف صنف بيانات جديد. على سبيل المثال، التعريف التالي يعرّف صنف بيانات يتكون من مصفوفة من سلاسل المحارف:
<pre dir=ltr class="samplecode">
keywords : type list[string];
</pre>
   يمكن للصنف أن يكون اختياراً بين مجموعة من الأصناف. على سبيل المثال:
<pre dir=ltr class="samplecode">
keyword : type string || list[string];
</pre>
   المثال أعلاه يعرّف الصنف ليكون أما سلسلة محارف أو مصفوفة من سلاسل المحارف. راجع قسم القواعد ذات المعطيات أدناه لمزيد من المعلومات عن الأصناف الجائزة.
   </p>
   
   <p><span class="kwd">integer, string, list, map</span><br/>
   هذه الأوامر التعريفية تقوم بتعريف بيانات من نوع رقم صحيح (integer) أو سلسلة محارف (string) أو مصفوفة (list) أو قاموس (map).<br/>
   تحديد صنف عناصر المصفوفة يتم بين قوسين مربّعين. ويُمكن أيضاً التخيير بين أكثر من صنف باستخدام ||. فيما يلي مثالان توضيحيان:
<pre dir=ltr class="samplecode">
list[string]
list[string || integer]
</pre>
   ويتم تحديد عناصر القاموس بشكل مشابه، أي بكتابة قائمة عناصر القاموس مفصولة بفارزة ومحصورة بقوسين مربّعين. كل عنصر من عناصر القاموس يتكون من اسم وصنف مفصولين بنقطتان متعامدتان (:). كما هو الحال مع المصفوفة، يُمكن هنا التخيير بين أكثر من صنف. فيما يلي مثالان توضيحيان:
<pre dir=ltr class="samplecode">
map[kwd:string, count:integer]
map[kwd:string||list[string], count:integer]
</pre>
   راجع قسم القواعد ذات المعطيات أدناه لمزيد من المعلومات حول الأصناف الجائزة للمصفوفة والقاموس.
   </p>
   
   <p><span class="kwd">char</span><br/>
   يعرّف هذا الأمر مجموعة محارف ويُتبع الأمر char بتعريف لمجموعة المحارف المشمولة بهذا التعريف وبكون بأحد الصيغ التالية:
<pre dir=ltr class="code">
1. "&lt;characters of the group&gt;"
2. &lt;from code&gt; .. &lt;to code&gt;
3. 'f' .. 't'
4. &lt;code&gt;, &lt;code&gt;, ...
5. &lt;character group&gt;, &lt;character group&gt;, ...
6. ^(&lt;character group&gt;)
</pre>
   وفيما يلي شرح لهذه الصيغ:<br/>
   1. تُكتب كل المحارف المشمولة بهذه المجموعة بين علامتي الإقتباس.<br/>
   2. تشمل المجموعة كل المحارف التي تنحصر شفرتها بين قيمتين.<br/>
   3. مثل سابقتها، لكن تكتب المحارف نفسها كقيمتي البداية والنهاية، بدل كتابة شفرتيها.<br/>
   4. تكتب كل شفرات المحارف المشمولة مفصولة بفارزة.<br/>
   5. لجمع أكثر من مجموعة من المحارف في مجموعة واحدة.<br/>
   6. تُستخدم للإستثناء، أي تعريف مجموعة تشمل كل المحارف باستثناء المجموعة المحددة بين القوسين.<br/>
   يمكن استخدام الأمر char كصنف لمعطى يجعل هذا المعطى مؤشراً على قاعدة مجموعة محارف.
   </p>
   
   <p><span class="kwd">trule</span><br/>
   يُستخدم لتعريف قاعدة ترميزية (tokenizing rule) وهو ما يُستخدم من قبل المعرِب. يُمكن للرمز أن يرث رمزا آخراً ما يجعله يحمل نفس المعرّف للمورّث، أي عندما يُطابق المرمز المدخلات مع قاعدة الرمز الوارث فإنه يُعطي الناتج قيمة المورث التعريفية بدل قيمة الوارث. لتعريف رمز يُستخدم التدوين التالي:
<pre dir=ltr class="code">
Id ":" "trule" ["inherits" ParentId] "as" ["(" ParamList ")" "=&gt;"] "{" RuleBody "}".
</pre>
   لتعريف قاعدة تستخدم متن قاعدة أخرى (أي تستخدم المتن من قالب) يُستخدم التدوين التالي:
<pre dir=ltr class="code">
Id ":" "trule" ["inherits" ParentId] "ref" RuleReference ["(" ParamList ")"].
</pre>
   قائمة المعطيات اختيارية وسيأتي شرحها لاحقاً.<br/>
   المثال التالي يعرّف رمزاً يتكون من حرف واحد أو أكثر:
<pre dir=ltr class="samplecode">
Identifier : trule as { ( Letter )*(1,endless) };
</pre>
   يُمكن أيضاً استخدام تعريف رمزي فارغ كمظلة لمجموعة تعريفات أخرى ترث منها نفس القيمة التعريفية، كما يلي:
<pre dir=ltr class="code">
Id ":" ["inherits" ParentId] "trule" ";".
</pre>
   الإشارة داخل متن القاعدة إلى قاعدة ترميزية أخرى يعني استدعاءها أثناء عملية الترميز بصورة مشابهة لاستدعاء الدالّات لبعضها. ويُمكن تعليم القاعدة الترميزية بمبدل <span class="kwd">@inner</span> لإعلام المرمّز أن هذا الرمز لا يأتي منفرداً وإنماً فقط ليُستدعى من متن تعريف آخر.
   يمكن استخدام الأمر trule كصنف لمعطى يجعل هذا المعطى مؤشراً على قاعدة ترميزية ويُتبع بإسم أو مجموعة أسماء لقواعد ترميزية تحصر المعطى بين أحد هذه الأسماء أو قاعدة مشقة من أحدها. المثال التالي يُعرف مصفوفة من المؤشرات على تعريفات ترميزية مشتقة من Constant:
<pre dir=ltr class="samplecode">
consts : list[trule[Constant]];
</pre>
   </p>
   
   <p><span class="kwd">prule</span><br/>
   يُستخدم لتعريف قاعدة إعرابية (parsing rule). يُمكن للقاعدة الإعرابية أن ترث قاعدة أخرى ما يُعطيها كل صفاتها باستثناء ما تقوم القاعدة الوارثة بتعريفه بنفسها، أي أن التعريفات في القاعدة الوارثة تطغى على مثيلاتها في القاعدة المورّثة كما هو الحال مع الاشتقاق في البرمجة كائنية المنحى. تعريف القاعدة الإعرابية يكون بالصيغة التالية:
<pre dir=ltr class="code">
Id ":" "prule" ["inherits" ParentId] ["prefix" Ids] "as" ["(" ParamList ")" "=&gt;"] "{" RuleBody "}".
</pre>
   لتعريف قاعدة تستخدم متن قاعدة أخرى (أي تستخدم المتن من قالب) يستخدم التدوين التالي:
<pre dir=ltr class="code">
Id ":" "prule" ["inherits" ParentId] ["prefix" Ids] "ref" RuleReference ["(" ParamList ")"].
</pre>
   قائمة المعطيات اختيارية وسيأتي شرحها لاحقاً. استخدام متن قاعدة أخرى يُعامل معاملة تضمين المتن في القاعدة، أي أنه يطغى على المتن الموروث. يُمكن أيضاً تعريف قاعدة إعرابية فارغة، أو قاعدة دون متن طالما لا تُستخدم القاعدة مباشرة في التحليل بل فقط لتوريث بعض الصفات لمجموعة من القواعد الأخرى. المثال التالي يعرّف قاعدة إعرابية لعملية جمع:
<pre dir=ltr class="samplecode">
Multiply : prule as { Operand + lexer.Constant("*") + Operand };
</pre>
   كما هو الحال مع trule، يُمكن استخدام prule كصنف لمؤشرات على قاعدات إعرابية. المثال التالي يُعرف مصفوفة من المؤشرات على قاعدات مشتقة من Exp.
<pre dir=ltr class="samplecode">
exps : list[prule[Exp]];
</pre>
   الكلمة التعريفية prefix تُستخدم مع التحليل متعدد الأبعاد لتحديد البيانات الإعرابية الموازية التي يمكن دمجها مع البيانات الإعرابية الناتجة من هذه القاعدة. راجع القسم "القواعد الموازية" أدناه لمزيد من التفاصيل.
   </p>

   <p><span class="kwd">prule_group</span><br/>
   يعرّف مجموعة من القواعد الإعرابية يطبق المعرب عملية تبادل عليها عندما يُشار إلى هذه المجموعة.
<pre dir=ltr class="code">
Id ":" "prule_group" [ "[" ParentId "]" ].
</pre>
   يمكن تحديد القواعد الإعرابية الجائز إضافتها إلى المجموعة عن طريق تحديد اسم قاعدة مورِّثة، فيُحصر الاختيار في القواعد الوارثة لتلك القاعدة. على سبيل المثال:
<pre dir=ltr class="samplecode">
CmdGroup : prule_group[Command];
Statement : prule as { Expression || CmdGroup };
</pre>
   في المثال أعلاه CmdGroup تمثل مجموعة من الأوامر ويُسمح للقاعدة Command أو أي وريث لها بالإنضمام لهذه المجموعة. القاعدة Statement تشير إلى المجموعة فيقوم المعرب بالبحث بين عناصر هذه المجموعة عن قاعدة متوافقة مع الرمز المعطى.
   </p>
   
   <p><span class="kwd">module</span><br/>
   يُستخدم لتعريف حزمة من التعريفات. يُمكن للحزم أن ترث بعضها فتحتوي الحزمة الوارثة على كل تعريفات الحزمة المورّثة. تعريفات الحزمة الوارثة تطغى على التعريفات الموروثة كما هو الحال مع الاشتقاق في البرمجة كائنية المنحى. تعريف الحزمة يكون بالصيغة التالية:
<pre dir=ltr class="code">
Id ":" "module" ["inherits" ParentId] "{" ModuleBody "}" ";".
</pre>
  يُمكن لحزمة أن تعرف أحد القواعد الإعرابية كنقطة بداية وبذلك يكون جائزاً استخدام الحزمة كقاعدة إعرابية فيتم الإشارة إليها مباشرة من متن قواعد أخرى بدل الإشارة إلى قاعدة بداخلها ويتم ذلك باستخدام الأمر <span class="kwd">start</span> الذي يستقبل بعده إسم القاعدة المعنية. المثال التالي يُعرف حزمة تحتوي ويحدد أحد قواعدها كنقطة بداية.
<pre dir=ltr class="samplecode">
Exp : module {
  start Add;
  Add : prule as { Multiply + (lexer.Constant("*") + Multiply)*(0,1) };
  Multiply : prule as { root.Operand + (lexer.Constant("+") + root.Operand)*(0,1) };
}
</pre>
   الإشارة إلى قاعدة أو متغير ضمن حزمة أخرى يتم بتسبيق الإسم بنقطة تسبقها اسم الحزمة. الإسم <span class="kwd">root</span> يُشير إلى المجال الرئيسي خارج أي حزمة.
   </p>

   <p><span class="kwd">null</span><br/>
   الأمر null يُستخدم عند التوريث لإلغاء تعريف موروث عن طريق إعادة تعريفه بnull.
   </p>
   
   <h3>القواعد ذات المعطيات</h3>
   تعرّف قائمة المعطيات بالصيغة التالية:
<pre dir=ltr class="code">
ParamList : Name ":" Type ["=" Value] {"," Name ":" Type ["=" Value]}
</pre>
   إن غابت قيمة المعطى من التعريف فإن الناتج يكون قالباً لا يُستخدم مباشرة وإنما بعد إنشاء قاعدة موصولة به أو مشتقة منه.
   المثال التالي يوضح  كيفية إنشاء قالب وقاعدة موصولة به:
<pre dir=ltr class="samplecode">
Cmd : prule as (kwd:string,body:prule[Expression])=>{ lexer.Constant(kwd) + body };
Print : prule ref Cmd(kwd="print", body=MyExpression);
</pre>
   المثال التالي يوضح تحديد قيمة للمعطيات في تعريف القاعدة:
<pre dir=ltr class="samplecode">
LogicalExp : prule as (ops:list[string]=("&&", "||"))=>{
  Operand + (Constants(ops) + Operand)*(0,endless)
}
</pre>
   فيما يلي قائمة بأصناف المعطيات الجائزة في القواعد. تُستخدم هذه الأصناف في القواعد الترميزية والإعرابية بالإضافة لتعريفات الأصناف (الأمر type).
   <p><table class="dict2 bilingual">
   <tr><td>سلسلة محارف</td><td>string</td></tr>
   <tr><td>عدد صحيح</td><td>integer</td></tr>
   <tr><td>مصفوفة</td><td>list</td></tr>
   <tr><td>قاموس</td><td>map</td></tr>
   <tr><td>مؤشر على مجموعة محارف</td><td>char</td></tr>
   <tr><td>مؤشر على قاعدة ترميزية</td><td>trule</td></tr>
   <tr><td>مؤشر على قاعدة إعرابية</td><td>prule</td></tr>
   </table></p>
   يُمكن أيضاً تطبيق عمليات التسلسل والتبادل على المصفوفات باستخدام الأوامر التالية:
   <p><span class="kwd">concat</span><br/>
   يقوم هذا الأمر بتكرار عنصر معين وتطبيق عملية التسلسل عليه (+) مع ربط كل عنصر من عناصر المصفوفة بأحد هذه التكرارات. الأمر يأخذ الصيغة التالية:
<pre dir=ltr class="code">
"concat" "(" ListArg ":" LoopArg ")" "=>" "(" Grammar ")".
</pre>
   يقوم الأمر بتحويل ListArg إلى سلسلة عناصر مع استبدال كل عنصر منها بناتج تطبيق ذلك العنصر على القالب Grammar. المثال التالي يوضّح هذه العملية:
<pre dir=ltr class="samplecode">
Words : list("hello", "world");
HelloWorld : prule as { concat (Words:w)=>( w + "!" ) };
HelloWorldHardcoded : prule as { "hello" + "!" + "world" + "!" };
</pre>
   في هذا المثال HelloWorld مطابقة في نتيجتها ل HelloWorldHardcoded. فيقوم الأمر concat بتطبيق المقطع (w + "!") على كل عنصر من عناصر المصفوفة Words.
   </p>

   <p><span class="kwd">alternate</span><br/>
   هذا الأمر مطابق بأسلوبه للأمر concat لكنه يطبق عملية تبادل بين عناصر المصفوفة بدل عملية التسلسل. كما في المثال التالي:
<pre dir=ltr class="samplecode">
Words : list("hello", "world");
HelloWorld : prule as { alternate (Words:w)=>( w + "!" ) };
HelloWorldHardcoded : prule as { ("hello" + "!") || ("world" + "!") };
</pre>
   </p>

   <h3>الإشارة إلى الرموز داخل القاعدة الإعرابية</h3>
   الإشارة إلى الرموز يتم بتسبيقها ب .lexer متبوعاً باسم القاعدة الترميزية المعنية. يمكن حصر الرمز المقبول في قيمة محددة بدل قبول أي قيمة كانت وذلك بتضمين القيمة داخل قوسين بعد اسم القاعدة الترميزية. الأمثلة التالية توضح الحالتين:
<pre dir=ltr class="samplecode">
a : prule as { lexer.Identifier };
b : prule as { lexer.Identifier("hello") }
</pre>
   في المثال أعلاه القاعدة الإعرابية a تقبل أي رمز من نوع Identifier بينما القاعدة b لا تقبل إلى رمزاً من نوع Identifier قيمته hello.

   <h3>التوريث في الحزم</h3>
   عند توريث الحزم يمكن استبدال التعريفات الموروثة بأخرى بإضافة تعريف يحمل نفس الأسم كما في المثال:
<pre dir=ltr class="samplecode">
P : module {
  a : prule as { "cmd" + Expression }
};

C : module inherits P {
  a : prule as { "cmd" + Expression + Expression }
}
</pre>
   في هذا المثال تحتوي الحزمة C على تعريف جديد ل a يُلغي التعريف الموروث من P.<br/>
   يُمكن أيضا في الحزمة الوارثة تعديل التعريفات بدل استبدالها كليّاً. على سبيل المثال يمكن استبدال قيمة المعطيات في قاعدة إعرابية دون استبدال متن القاعدة كما في المثال:
<pre dir=ltr class="samplecode">
P : module {
  a : prule as (kwd:string="cmd")=>{ kwd + Expression }
};

C : module inherits P {
  a.kwd = "mycmd";
}
</pre>
   يُمكن جمع عمليات تعديل متعددة باستخدام الأقواس الحاصرة كما في المثال التالي:
<pre dir=ltr class="samplecode">
C : module inherits P {
  a.{kwd = "mycmd"; param = MyExpression}
}
</pre>
   <h3>أوامر وكلمات تعريفية أخرى</h3>
   بالإضافة إلى التعريفات هناك أوامر أخرى يمكن أن تظهر إلى جانب التعريفات، أي داخل متن الحزم أو ضمن المجال الرئيسي خارج الحزم:
   
   <p><span class="kwd">ignore</span><br/>
   يستخدم الأمر ignore لتعريف الرموز المهملة، أي لتعريف قاعدة ترميزية لرموز يتم إهمالها ولا تُرسل إلى المعرِب كما في تعريف الفراغات التي لا تدخل ضمن الإعراب وتأخذ الصيغة التالية:
<pre dir=ltr class="code">
"ignore" "{" TokenBody "}".
</pre>
   </p>
   
   <p><span class="kwd">start</span><br/>
   الأمر start يُعرّف نقطة البداية في الإعراب بتحديد اسم القاعدة الإعرابية التي يبدأ منها المعرِب. عند ظهور هذا الأمر داخل حزمة فإنه يحدد نقطة البداية لتلك الحزمة، أي عندما يُشار داخل متن قاعدة إعرابية إلى حزمة فإن المعرب ينتقل إلى القاعدة الإعرابية المُشار إليها بالإمر start داخل الحزمة.
   </p>

   <p><span class="kwd">lexer</span><br/>
   هذا الأمر يشير إلى الحزمة التي تحتوي على القواعد الترميزية. تُتبع الكلمة lexer باسم الحزمة التي تحتوي على القواعد الترميزية. يتعامل المرمّز فقط مع القواعد التي داخل الحزمة المعنية ويهمل القواعد التي خارجها. يجب وجود هذا الأمر في المجال الرئيسي لتحديد الحزمة الترميزية الرئيسية أما داخل الحزم فإن وجوده أختياري ويؤدي إلى استخدام  حزمة ترميزية مختلفة حال دخول المُعرب الحزمة المحتوية على هذا الأمر، والعودة إلى الحزمة الترميزية السابقة حال الخروج من تلك الحزمة والعودة للمجال السابق.
   </p>
   
   <p><span class="kwd">self</span><br/>
   الكلمة التعريفية self تستخدم للإشارة إلى القاعدة المحتوية على هذه الكلمة. على سبيل المثال، التعريفان التاليان متساويان:
<pre dir=ltr class="samplecode">
Multiply : prule as { Operand + (lexer.Constant("*") + self)*(0,1) };
Multiply : prule as { Operand + (lexer.Constant("*") + Multiply)*(0,1) }
</pre>
   </p>
   
   <h3>المبدّلات</h3>
   بالإضافة إلى الأوامر، هناك مبدّلات تُضاف إلى القواعد لتحديد ميّزات معينة لما تُضاف إليه. هذه المبّدلات تظهر فقط مرتبطة بأوامر أخرى ولا تظهر لوحدها في الجملة.
   
   <p><span dir=ltr class="kwd">@filter</span><br/>
   هذا المبدل يُستخدم كمرشّح لعناصر قائمة داخلة في عملية التبادل أو التسلسل. يأخذ هذا المبدل أحد هاتين الصيغتين:
<pre dir=ltr class="code">
"@filter" "(" number ")" &lt;concatenation or alternation&gt;
"@filter" "(" list ")" &lt;concatenation or alternation&gt;
</pre>
   في الصيغة الأولى يُبقي هذا المرشح على عنصر واحد من قائمة العناصر الداخلة في عملية التبادل أو التسلسل وهو العنصر ذو الموقع المقابل للرقم المُعطى. أما في الصيغة الثانية فإن المبدل يستلم قائمة من الأرقام كمعطيات بدل رقم واحد، كل عنصر من هذه القائمة يشير إلى أحد عناصر عملية التبادل أو التسلسل. على سبيل المثال:
<pre dir=ltr class="samplecode">
@filter(2) Exp1 || Exp2 || Exp3 || Exp4
</pre>
   القاعدة في المثال أعلاه مساوية لكتابة Exp2 بمفردها.
<pre dir=ltr class="samplecode">
@filter(2,1,4) Exp1 || Exp2 || Exp3 || Exp4
Exp2 || Exp1 || Exp4
</pre>
   وفي هذا المثال القاعدتان متطابقتان.
   </p>
   
   <p><span dir=ltr class="kwd">@priority</span><br/>
   يُستخدم هذا المبدل لتحديد الأسبقية في أماكن التفرّع الإعرابي ويأخذ الصيغة التالية:
<pre dir=ltr class="code">
"@priority" "(" [priority ","] tokensToLive ")" Grammar.
</pre>
   يحدد هذا المبدّل قيمتين، الأولى (priority) تمثّل الفرع ذو الأسبقية الأعلى أما الثانية فتحدد عمر الفروع غير ذات الأسبقية ويحدد العمر بعدد الرموز التي يستقبلها المُعرب. عندما تمر على المعرب العدد المحدد من الرموز فإنه يقوم بإلغاء الفروع التي مازالت قائمة. إذا كانت قيمة العمر 0 فإن المعرب لا يقوم بالتفرّع بل يأخد من البداية الفرع ذو الأسبقية الأعلى ويهمل غيره.<br/>
   يمكن لهذا المبّدل أن يطبَّق على عملية التكرار و التبادل كما يمكن أن يطبَّق على القاعدة الإعرابية نفسها لتحديد الأسبقية في حالة التفرع بين عدة قاعدات عند وصول المعرب إلى مجموعة إعرابية (prule_group). الأمثلة التالية توضح الحالات المختلفة:
<pre dir=ltr class="samplecode">
a + (@priority(in,0) b*(0,1));     // <span dir=rtl>الأسبقية للفرع b وتهمل الحالة الأخرى</span>
a + (@priority(out,0) b*(0,1));    // <span dir=rtl>الأسبقية لترك الفرع b</span>
@priority(2,3) a || b || c || d;   // <span dir=rtl>الأسبقية للفرع c مع إعطاء الفروع الأخرى فرصة مدتها 3 رموز قبل إلغائهم</span>
@priority(5,0) prule MyCmd = x;  // <span dir=rtl>أسبقية بقيمة 5 تعطى لهذه القاعدة ويؤدي ذلك لإلغاء أي قاعدة بأسبقية تقل عن 5</span>
</pre>
   </p>

   <p><span dir=ltr class="kwd">@limit</span><br/>
   يُستخدم للإشارة إلى القيود المطبقة على القواعد. يُعطى هذا المبدل مجموعة من الشروط التي تطبقها القاعدة على القواعد المتعاملة معها. على سبيل المثال:
<pre dir=ltr class="samplecode">
CmdTemplate : @limit[user.parent==Command] prule as (kwd:keywords)=>{ KeywordGroup(kwd) + Expression };
Command : @limit[child.terms==(CmdTemplate||CmdTemplate2)] prule;
</pre>
   في المثال أعلاه يشترط على أي مستخدم للقالب CmdTemplate أن يكون وريثاً للقاعدة Command. ويُشترط على ورثة Command أن يستخدموا أحد القالبين CmdTemplate و CmdTemplate2.
   </p>
   
   <P><span dir=ltr class="kwd">@unique</span><br/>
   يُستخدم في تعريف معطيات القوالب القواعدية للإشارة إلى فرادة ذلك المعطى. يُمنع تكرار القيمة نفسها لذات المتغير في طبعات مختلفة من ذلك القالب. مثال:
<pre dir=ltr class="samplecode">
Command : prule as (@unique kwd:string)=>{ kwd + Expression + ";" }
</pre>
   في المثال أعاله يُمنع إنشاء طبعتين من القالب Command بنفس القيمة لkwd.
   </p>

   <p><span dir=ltr class="kwd">@inner</span><br/>
   يُستخدم مع تعريفات القواعد الترميزية للإشارة إلى قواعد داخلية لا تُستخدم من قبل المرمّز منفردة وإنما فقط عندما يُشار إليها من متن قاعدة أخرى.
   </p>
   
   <h3>القواعد الموازية</h3>
   لتعريف قواعد موازية يُستخدم الأمر <span class="kwd">dimension</span> ويأخذ الصيغة التالية:
<pre dir=ltr class="code">
dimension {
  start : &lt;startingRule&gt;;
  diverge : &lt;divergePoint&gt;;
  onExit : &lt;exitHandler&gt;
}
</pre>
   يحتوي التعريف على ثلاث قيم:<br/>
   <b>startRule:</b> يحدد اسم القاعدة الإعرابية التي يبدأ منها البعد الجديد للإعراب.<br/>
   <b>divergePoint:</b> يحدد النقطة التي يحاول المعرب منها دخول البعد الآخر. يمكن لهذه القيمة أن تكون atRuleEntry (للمحاولة قبل دخول أي قاعدة جديدة) أو تكون atRuleExit (للمحاولة بعد الخروج من أي قاعدة) أو تكون atNewToken (للمحاولة عند استلام كل رمز جديد من المرمّز).<br/>
   <b>exitHandler:</b> يحدد التعامل مع البيانات الإعرابية الناتجة من إعراب البعد الآخر. تنفذ هذه الدالة بعد الإنتهاء من إعراب البعد الآخر والعودة للبعد الأساسي.
  </div>
 </div>
 </div>
 <div style="border-top: solid 1px; text-align: right; font-size:90%; padding-left:20px; padding-right:20px; padding-bottom:10px;">
  <p>جميع الحقوق محفوظة لـ <a href="http://sarmad-khalid.info/" style="color:black;" target="__blank">سرمد خالد عبداللّه</a> 2015م \ 1436هـ.<br/>
نُشر هذا الملف برخصة الأسُس العامة (Alusus Public License)، الإصدار 1.0، والمضمّنة مع هذا الملف
والمتوفرة أيضاً على الرابط <a style="white-space:nowrap;" href="http://alusus.net/alusus_license_1_0">http://alusus.net/alusus_license_1_0</a>. يرجى قراءة الرخصة للتعرف على شروط الاستخدام والنسخ.</p>
 </div>
</div>
</body>
</html>

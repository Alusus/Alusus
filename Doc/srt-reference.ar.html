<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <title>دليل المكتبات التنفيذية | لغة الأسس البرمجية</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="Resources/rtl/bootstrap.min.css">
    <link rel="stylesheet" href="Resources/font-awesome.min.css">
    <link rel="stylesheet" href="Resources/style.css">
    <link rel="stylesheet" href="Resources/highlight.default.css">
    <script src="Resources/jquery.min.js"></script>
    <script src="Resources/popper.min.js"></script>
    <script src="Resources/bootstrap.min.js"></script>
</head>

<body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light fixed-top">
        <div class="container">
            <a class="navbar-brand" href="index.html"><img src="Resources/logo.svg" alt="Alusus Programming Language" class="site-logo"></a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNavDropdown">
                <h3 style="padding-top: 0px; margin-top: 0px;">لغة الأسس - دليل المكتبات التنفيذية</h3>
            </div>
        </div>
    </nav>
    <div class="container">
        <!--content-separator-->
        <div class="row">
            <div class="col-md-3">
                <div class="card side-sticky">
                    <div class="card-header">دليل المكتبات التنفيذية</div>
                    <div class="card-content">
                        <a href="#Srl">دليل مكتبة التنفيذ المعيارية (Srl)</a><br>
                        <ul class="unstyled-list">
                            <li><a href="#Array">الصنف: مـصفوفة (Array)</a></li>
                            <li><a href="#String">الصنف: نـص (String)</a></li>
                            <li><a href="#Map">الصنف: تـطبيق (Map)</a></li>
                            <li><a href="#SrdRef">الصنف: سـندنا (SrdRef)</a></li>
                            <li><a href="#WkRef">الصنف: سـندهم (WkRef)</a></li>
                            <li><a href="#UnqRef">الصنف: سـندي (UnqRef)</a></li>
                            <li><a href="#Memory">الوحدة: ذاكـرة (Memory)</a></li>
                            <li><a href="#Math">الوحدة: ريـاضيات (Math)</a></li>
                            <li><a href="#Net">الوحدة: شـبكة (Net)</a></li>
                            <li><a href="#Console">الوحدة: طـرفية (Console)</a></li>
                            <li><a href="#System">الوحدة: نـظام (System)</a></li>
                            <li><a href="#Fs">الوحدة: نـم (Fs)</a></li>
                            <li><a href="#Regex">الوحدة: نـمط (Regex)</a></li>
                            <li><a href="#Time">الوحدة: وقـت (Time)</a></li>
                            <li><a href="#Srl-other">تعريفات أخرى</a></li>
                        </ul>
                        <a href="#closure">دليل مكتبة `مغلفة` (closure)</a><br>
                        <a href="#Build">دليل مكتبة `بـناء` (Build)</a><br>
                          <ul class="unstyled-list">
                            <li><a href="#Build-Exe">الصنف: تـنفيذي (Exe)</a></li>
                            <li><a href="#Build-Wasm">الصنف: ويـب_أسمبلي (Wasm)</a></li>
                            <li><a href="#Build-genExecutable">الدالة: أنشئ_تنفيذي (genExecutable)</a></li>
                            <li><a href="#Build-genWasm">الدالة: أنشئ_ويب_أسمبلي (genWasm)</a></li>
                          </ul>
                        <a href="#Zip">دليل مكتبة `ضـغط` (Zip)</a><br>
                        <a href="#Apm">دليل مدير الحزم</a><br>
                        <a href="#Core" class="top-level">دليل الوحدة `الـقلب` (Core)</a><br>
                          <ul class="unstyled-list">
                            <li><a href="#Core-importFile">الدالة: اشمل_ملف (importFile)</a></li>
                            <li><a href="#Core-addLocalization">الدالة: أضف_ترجمة (addLocalization)</a></li>
                            <li>
                              <a href="#Core-typesInfo">هوية الأصناف</a><br>
                              <ul class="unstyled-list">
                                <li><a href="#Core-TiObjectFactory">الصنف: مـصنع_كائن_بهوية (TiObjectFactory)</a></li>
                                <li><a href="#Core-TypeInfo">الصنف: هـوية_صنف (TypeInfo)</a></li>
                                <li><a href="#Core-TiObject">الصنف: كـائن_بهوية (TiObject)</a></li>
                                <li><a href="#Core-TiInterface">الصنف: وسـيط_بهوية (TiInterface)</a></li>
                                <li><a href="#Core-getInterface">الماكرو: هات_وسيط (getInterface)</a></li>
                                <li><a href="#Core-isDerivedFrom">الماكرو: أمشتق_من (isDerivedFrom)</a></li>
                                <li><a href="#Core-defDynCastedRef">الماكرو: عرف_سندا_بتمثيل_آمن (defDynCastedRef)</a></li>
                              </ul>
                            </li>
                            <li><a href="#Core-basicTypes">أصناف أساسية</a></li>
                            <li>
                              <a href="#Core-dynamicDataAccess">الوصول الديناميكي للبيانات</a><br>
                              <ul class="unstyled-list">
                                <li><a href="#Core-Binding">الوسيط: ربـط (Binding)</a></li>
                                <li><a href="#Core-Containing">الوسيط: احـتواء (Containing)</a></li>
                                <li><a href="#Core-DynamicContaining">الوسيط: احـتواء_مرن (DynamicContaining)</a></li>
                                <li><a href="#Core-MapContaining">الوسيط: احـتواء_تطبيقي (MapContaining)</a></li>
                                <li><a href="#Core-DynamicMapContaining">الوسيط: احـتواء_تطبيقي_مرن (DynamicMapContaining)</a></li>
                              </ul>
                            </li>
                            <li>
                              <a href="#Core-ast">أصناف شجرة البنية المجردة (AST)</a>
                              <ul class="unstyled-list">
                                <li><a href="#Core-Node">الصنف: عـقدة (Node)</a></li>
                                <li><a href="#Core-textAstTypes">الأصناف النصية</a></li>
                                <li><a href="#Core-expAstTypes">أصناف الأوامر والتراكيب</a></li>
                              </ul>
                            </li>
                          </ul>
                        <a href="#Spp" class="top-level">دليل الوحدة `نـبم` (Spp)</a><br>
                          <ul class="unstyled-list">
                            <li><a href="#Spp-buildMgr">الكائن: مدير_البناء (buildMgr)</a></li>
                            <li><a href="#Spp-grammarMgr">الكائن: مدير_القواعد (grammarMgr)</a></li>
                            <li><a href="#Spp-astMgr">الكائن: مدير_شبم (astMgr)</a></li>
                            <li>
                              <a href="#Spp-ast">أصناف شجرة البنية المجردة (AST)</a>
                              <ul class="unstyled-list">
                                <li><a href="#Spp-typesAstTypes">الأصناف</a></li>
                                <li><a href="#Spp-opsAstTypes">مؤثرات</a></li>
                                <li><a href="#Spp-stmtAstTypes">عبارات</a></li>
                                <li><a href="#Spp-otherAstTypes">أخرى</a></li>
                              </ul>
                            </li>
                          </ul>
                        <a href="#astManipulation" class="top-level">معالجة شجرة البنية المجردة</a><br>
                    </div>
                </div>
            </div>
            <div class="col-md-9">
                <h3 id="Srl">دليل مكتبة التنفيذ المعيارية (Srl)</h3>
                <hr>
                <div>
                    مكتبة التنفيذ المعيارية تتكون من وحدة واحدة اسمها `مـتم` (Srl) وتحتوي هذه الوحدة على الوحدات التالية:

                    <h4 class="foldable" id="Array">الصنف: مـصفوفة (Array)</h4>
                    <div>
                        قالب مصفوفة ديناميكية تتولى مسؤولية إدارة الذاكرة مع مراعاة الأداء وتجنب عمليات النسخ وحجز الذاكرة غير الضرورية. المثال التالي يوضح التعامل مع هذه المصفوفة الديناميكية:
                        <pre class="samplecode" dir=rtl style="text-align:right;">
دالة رئيسي {
  عرف م: مـصفوفة[صـحيح] = هات_مصفوفة()؛
  م.أضف(1)؛ // هنا يتم تمديد حجم الذاكرة المحجوزة
  عرف م2: مـصفوفة[صـحيح] = م؛ // هنا لا يتم إنشاء نسخة جديدة من الصوان
  م.أضف(2)؛ // الآن يتم إنشاء نسخة جديدة كي لا يتأثر م2
  اطبع_مصفوفة(م)؛ // لا يتم هنا إعادة حجز الذاكرة أو نسخها
  // الآن يتم تحرير ذاكرة م وم2
}

دالة هات_مصفوفة (): مـصفوفة[صـحيح] {
  عرف ن: مـصفوفة[صـحيح]؛
  ن.أضف(0)؛
  ارجع ن؛ // لا يتم هنا إعادة حجز الذاكرة أو نسخها
}

دالة اطبع_مصفوفة (ن: مـصفوفة[صـحيح]) {
  عرف ع: صـحيح؛
  لكل ع = 0، ع < ن.هات_الطول()، ++ع طـرفية.اطبع("%d\ج"، ن(ع))؛
}
</pre>
<pre class="samplecode" dir=ltr style="text-align:left;">
func main {
  def a: Array[Int] = getArray();
  a.add(1); // Here the allocated memory block is expanded.
  def a2: Array[Int] = a; // No new memory block is allocated here.
  a.add(2); // Now a new copy of the buffer is created so a2 is not affected.
  printArray(a); // No new memory block is created or copied here.
  // Now the memory blocks of a and a2 are freed.
}

func getArray(): Array[Int] {
  def a: Array[Int];
  a.add(0);
  return a; // No new memory block is allcoated here and memory copy happens.
}

func printArray (a: Array[Int]) {
  def i: Int;
  for i = 0, i < a.getLength(), ++i Console.print("%d\n", a(i));
}
</pre>

يحتوي الصنف `مـصفوفة` على الدالات التالية:
                        <ul class="subsections">
                            <li>
                              <b>التهيئة</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا~هيئ(سند[مـصفوفة[صـنف_المحتوى]])؛
  عملية هذا_هيئ(عدد_العناصر: صـحيح، العناصر: ...صـنف_المحتوى)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this~init(ref[Array[ContentType]]);
  handler this~init(count: Int, args: ...ContentType);
</pre>
                              الصيغة الأولى تهيئ المصفوفة من مصفوفة أخرى. ستستخدم المصفوفة الجديدة نفس المحتوى الذي في المصفوفة المعطاة ولن يتم
                              نسخ المحتوى حتى تغير إحدى المصفوفتي المحتوى، وعندها ينسخ المحتوى قبل التغيير لضمان عدم تأثر المصفوفة الأخرى.<br>
                              الصيغة الثانية تهيئ المصفوفة من العناصر المعطاة كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
عرف م1: مـصوفة[صحيح]({ 5، 2، 1 })؛ // ستحتوي المصفوفة على 3 عناصر: 5، 2، 1.
عرف م2: مـصفوفة[صحيح](3، 5، 2، 1)؛ // ستحتوي المصفوفة على 3 عناصر: 5، 2، 1.
</pre>
<pre class="samplecode" dir=ltr style="text-align:left;">
def a1: Array[Int]({ 5, 2, 1 }); // Array will contain 3 elements: 5, 2, and 1.
def a2: Array[Int](3, 5, 2, 1); // Array will contain 3 elements: 5, 2, and 1.
</pre>
                            </li>
                            <li>
                                <b>هات_الطول (getLength)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.هات_الطول (): صـحيح_متكيف؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.getLength (): ArchInt;
</pre>
ترجع عدد العناصر في المصفوفة.
                            </li>
                            <li>
                                <b>هات_حجم_الصوان (getBufSize)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.هات_حجم_الصوان (): صـحيح_متكيف؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.getBufSize (): ArchInt;
</pre>
ترجع عدد العناصر التي تتسع لها الذاكرة المحجوزة حاليًا. عند تجاوز هذا الحجم يقوم الكائن تلقائيا بتوسيع حجز الذاكرة.
                            </li>
                            <li>
                                <b>عيّن (assign)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.عين (م: سند[مـصفوفة[صـنف_المحتوى]])؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.assign (a: ref[Array[ContentType]]);
</pre>
تعيين محتوى جديد للمصفوفة من مصفوفة أخرى. هذه الدالة لا تنسخ المحتوى من المصفوفة الأخرى وإنما تتشارك معها بنفس الصوان لحين حاجة إحدى المصفوفتين لتغيير المحتوى، حينها تنسخ تلك المصفوفة الصوان وتنتهي المشاركة.
                            </li>
                            <li>
                                <b>أضف (add)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.أضف (م: صـنف_المحتوى)؛
عملية هذا.أضف (عدد_العناصر: صـحيح، العناصر: ...صـنف_المحتوى)؛
عملية هذا.أضف (م: مـصفوفة[صـنف_المحتوى])؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.add (e: ContentType);
handler this.add (argCount: Int, args: ...ContentType);
handler this.add (e: Array[ContentType]);
</pre>
                              الصيغة الأولى تضيف عنصرا إلى المصفوفة بعد توسيع حجز الذاكرة إن وجب. إذا كان المحتوى
                              مشارك مع مصفوفة أخرى تقوم الدالة بنسخ المحتوى إلى صوان جديد.<br>
                              الصيغة الثانية تضيف عدة عناصر مرة واحدة بدل أن تضيف عنصرا واحدًا.<br>
                              الصيغة الثالثة تضيف مصفوفة إلى المصفوفة الحالية، أي تضيف كل عناصر المصفوفة
                              المعطاة إلى المصفوفة الحالية. المصفوفة المعطاة لن تتأثر بهذا الاستدعاء.
<pre class="samplecode" dir=rtl style="text-align:right;">
م.أضف({ 5، 2، 1 })؛ // تضيف 3 عناصر: 5، 2، 1.
م.أضف(3، 5، 2، 1)؛ // تضيف 3 عناصر: 5، 2، 1.
</pre>
<pre class="samplecode" dir=ltr style="text-align:left;">
a.add({ 5, 2, 1 }); // Adds 3 elements: 5, 2, 1.
a.add(3, 5, 2, 1); // Adds 3 elements: 5, 2, 1.
</pre>
                            </li>
                            <li>
                                <b>احشر (insert)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.احشر (موقع: صـحيح_متكيف، عنصر: صـنف_المحتوى)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.insert (index: ArchInt, element: ContentType);
</pre>
إضافة عنصر جديد إلى المصفوفة في الموقع المحدد بعد توسيع حجز الذاكرة إن وجب. إذا كان المحتوى مشارك مع مصفوفة أخرى تقوم الدالة بنسخ المحتوى إلى صوان جديد.
                            </li>
                            <li>
                                <b>أزل (remove)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.أزل (موقع: صـحيح_متكيف)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.remove (index: ArchInt);
</pre>
إزالة العنصر الذي في الموقع المحدد. إذا كان المحتوى مشارك مع مصفوفة أخرى تقوم الدالة بنسخ المحتوى إلى صوان جديد.
                            </li>
                            <li>
                                <b>اجتزئ (slice)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.اجتزئ (بداية: صـحيح_متكيف، عدد: صـحيح_متكيف)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.slice (start: ArchInt, count: ArchInt);
</pre>
نسخ جزء من المصفوفة وإرجاعه كمصفوفة جديدة. يبدأ النسخ من العنصر `بداية` ويستمر حتى نسخ `عدد` من العناصر، أو حتى وصول نهاية المصفوفة (إن وصلنا نهاية المصفوفة قبل استيفاء العدد المطلوب).
                            </li>
                            <li>
                                <b>فرّغ (clear)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.فرّغ ()؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.clear ();
</pre>
إزالة جميع العناصر من المصفوفة. إذا كان المحتوى مشارك مع مصفوفة أخرى تقوم الدالة بنسخ المحتوى إلى صوان جديد.
                            </li>
                        </ul>
                    </div>

                    <h4 class="foldable" id="String">الصنف: نـص (String)</h4>
                    <div>
                        الصنف `نـص` يسهل التعامل مع سلاسل المحارف فهو يتولى مسؤولية حجز وتحرير الذاكرة الخاصة بسلسلة المحارف مع مراعاة الأداء وتجنب عمليات النسخ وحجز الذاكرة غير الضرورية. يوفر الصنف دالات لتسهيل العمليات المختلفة على سلاسل الحارف. المثال التالي يوضح التعامل
                        مع سلاسل المحارف:
<pre class="samplecode" dir=rtl style="text-align:right;">
دالة رئيسي {
  عرف نص: نـص = هات_نص()؛
  نص += " والحمد لله"؛ // هنا يتم تمديد حجم الذاكرة المحجوزة
  عرف نص2: نـص = نص؛ // هنا لا يتم إنشاء نسخة جديدة من النص
  نص += "."؛ // الآن يتم إنشاء نسخة جديدة كي لا يتأثر نص2
  اطبع_نص(نص)؛ // لا يتم هنا إعادة حجز الذاكرة أو نسخها
  // الآن يتم تحرير ذاكرة نص ونص2
}

دالة هات_نص (): نـص {
  عرف ن: نـص = "بسم الله"؛
  ارجع ن؛ // لا يتم هنا إعادة حجز الذاكرة أو نسخها
}

دالة اطبع_نص (ن: نـص) {
  طـرفية.اطبع(ن)؛ // يتم هنا التحويل تلقائيا من صنف نـص إلى مؤشر على محارف.
}
</pre>
<pre class="samplecode" dir=ltr style="text-align:left;">
func main {
  def str: String = getString();
  str += " world"; // Memory block is expanded here.
  def str2: String = str; // No new memory is allocated here.
  str += "."; // Copy of the string buffer is created so str2 is not affected.
  printStr(str); // No new memory allocation or copy happens here.
  // Now memory blocks of str and str2 are freed.
}

func getString (): String {
  def s: String = "Hello";
  return s; // No new memory allocation or copy happens here.
}

func printStr (s: String) {
  Console.print(s); // s is automatically casted into ptr[array[Char]].
}
</pre>
يحتوي الصنف `نـص` على المتغيرات والدالات التالية:
                        <ul class="subsections">
                            <li>
                                <b>صوان (buf)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عرف صوان: مؤشر[مصفوفة[مـحرف]]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
def buf: ptr[array[Char]];
</pre>
مؤشر على محتوى هذا النص.
                            </li>
                            <li>
                                <b>مؤثر الأقواس</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا(م: صـحيح_متكيف): مـحرف
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this(i: ArchInt): Char
</pre>
يمكن استخدام هذا المؤثر لإرجاع المحرف في الموقع المحدد.
                            </li>
                            <li>
                                <b>مؤثرات المقارنة</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا == مؤشر[مصفوفة[مـحرف]]: ثـنائي
عملية هذا < مؤشر[مصفوفة[مـحرف]]: ثـنائي
عملية هذا > مؤشر[مصفوفة[مـحرف]]: ثـنائي
عملية هذا <= مؤشر[مصفوفة[مـحرف]]: ثـنائي
عملية هذا >= مؤشر[مصفوفة[مـحرف]]: ثـنائي
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this == ptr[array[Char]]: Bool
handler this > ptr[array[Char]]: Bool
handler this < ptr[array[Char]]: Bool
handler this >= ptr[array[Char]]: Bool
handler this <= ptr[array[Char]]: Bool
</pre>
تقارن هذا النص مع النص المعطى.
                            </li>
                            <li>
                                <b>هات_الطول (getLength)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
1: عملية هذا.هات_الطول (): صـحيح_متكيف؛
2: دالة هات_الطول (م: مؤشر[مصفوفة[مـحرف]]): صـحيح_متكيف؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
1: handler this.getLength (): ArchInt;
2: func getLength (p: ptr[array[Char]]): ArchInt;
</pre>
1. ترجع طول هذا النص.<br> 2. ترجع طول سلسلة المحارف المعطاة.
                            </li>
                            <li>
                                <b>احجز (alloc)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.احجز (صـحيح_متكيف)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.alloc (ArchInt);
</pre>
تقوم بحجز مسبق للذاكرة. تمكن هذه الدالة المستخدم من حجز الذاكرة مسبقًا قبل تعبئتها بالمحتوى باستخدام التعامل المباشر مع صوان هذا النص. تنفع هذه الطريقة عند التعامل مع مكتبات تتعامل مع مؤشرات المحارف، مع الاستفادة
                                من خاصيات إدارة الذاكرة التي يوفرها هذا الصنف.
                            </li>
                            <li>
                                <b>غير_الحجز (realloc)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.غير_الحجز (صـحيح_متكيف)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.realloc (ArchInt);
</pre>
تغير حجم الذاكرة المحجوزة لهذا النص. تمكن هذه الدالة المستخدم من تغيير حجم الذاكرة المحجوزة قبل تغيير المحتوى باستخدام التعامل المباشر مع صوان هذا النص.
                            </li>
                            <li>
                                <b>عين (assign)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
1. عملية هذا.عين (نص: سند[نـص])؛
2. عملية هذا.عين (صوان: مؤشر[مصفوفة[مـحرف]])؛
3. عملية هذا.عين (صوان: مؤشر[مصفوفة[مـحرف]]، عدد: صـحيح_متكيف)؛
4. دالة عين (المقصد: مؤشر[مصفوفة[مـحرف]]، نسق: مؤشر[مصفوفة[مـحرف]]، ...أيما): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
1: handler this.assign (str: ref[String]);
2: handler this.assign (buf: ptr[array[Char]]);
3: handler this.assign (buf: ptr[array[Char]], count: ArchInt);
4: func assign (target: ptr[array[Char]], fmt: ptr[array[Char]], ...any): Int;
</pre>
1. تعيين محتوى جديد للنص من نص آخر. هذه الدالة لا تنسخ محتوى النص الآخر وإنما تتشارك معه بنفس الصوان لحين حاجة أحد النصين لتغيير المحتوى، حينها ينسخ ذاك النص الصوان وتنتهي المشاركة.<br> 2. تعيين محتوى جديد للنص من
                                صوان في الذاكرة. تنسخ هذه الدالة المحتوى من ذلك الصوان إلى صوان جديد يديره هذا النص.<br> 3. مشابهة للدالة 2 لكنها تنسخ فقط العدد المحدد من المحارف من الصوان المعطى.<br> 4. تعيين قيمة جديدة من نسق (format) وعدد غير محدد
                                من المعطيات إلى المقصد. يجب على المستخدم ضمان أن تكفي ذاكرة المقصد لاستيعاب الناتج كاملاً.<br> يمكن للمستخدم أيضًا استخدام المؤثر = للاستعاضة عن الدالتين 1 و 2.
                            </li>
                            <li>
                                <b>ألحق (append)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
1. عملية هذا.ألحق (صوان: مؤشر[مصفوفة[مـحرف]])؛
2. عملية هذا.ألحق (صوان: مؤشر[مصفوفة[مـحرف]]، عدد: صـحيح_متكيف)؛
3. عملية هذا.ألحق (م: مـحرف)؛
4. عملية هذا.ألحق (ص: صـحيح[64])؛
5. عملية هذا.ألحق (ع: عـائم[64])؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
1. handler this.append (buf: ptr[array[Char]]);
2. handler this.append (buf: ptr[array[Char]], count: ArchInt);
3. handler this.append (c: Char);
4. handler this.append (i: Int[64]);
5. handler this.append (f: Float[64]);
</pre>
1. ألحق الصوان المعطى بنهاية محتوى هذا النص.<br> 2. ألحق العدد المحدد من المحارف من الصوان المعطى.<br> 3. ألحق محرفا بنهاية هذا النص.<br> 4. ألحق العدد المعطى بنهاية هذا النص. هذه الدالة تلحق تمثيلاً نصيا للعدد المعطى.<br>                                5. مشابهة للدالة 4 لكنها تلحق عددا عائما بدل عدد صحيح.<br> يمكن أيضا الاستعاضة عن هذه الدالات (باستثناء الدالة 2) بالمؤثر +=.
                            </li>
                            <li>
                                <b>سلسل (concat)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
1. عملية هذا.سلسل (صوان: مؤشر[مصفوفة[مـحرف]])؛
2. عملية هذا.سلسل (صوان: مؤشر[مصفوفة[مـحرف]]، عدد: صـحيح_متكيف)؛
3. عملية هذا.سلسل (م: مـحرف)؛
4. عملية هذا.سلسل (ص: صـحيح[64])؛
5. عملية هذا.سلسل (ع: عـائم[64])؛
6. دالة سلسل (المقصد: مؤشر[مصفوفة[مـحرف]]، المصدر: مؤشر[مصفوفة[مـحرف]]): مؤشر؛
7. دالة سلسل (المقصد: مؤشر[مصفوفة[مـحرف]]، المصدر: مؤشر[مصفوفة[مـحرف]]، عدد: صـحيح_متكيف): مؤشر؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
1. handler this.concat (buf: ptr[array[Char]]);
2. handler this.concat (buf: ptr[array[Char]], count: ArchInt);
3. handler this.concat (c: Char);
4. handler this.concat (i: Int[64]);
5. handler this.concat (f: Float[64]);
6. func concat (target: ptr[array[Char]], source: ptr[array[Char]]): ptr;
7. func concat (target: ptr[array[Char]], source: ptr[array[Char]], count: ArchInt): ptr;
</pre>
1-5. هذه الدالات مشابهة لدالات `ألحق` لكنها ترجع النتيجة في نص جديد بدل تعديل النص الحالي. يمكن أيضًا الاستعاضة عن هذه الدالات 1 و3 و4 و5 بالمؤثر +.<br> 6. تلحق سلسلة محارف المصدر بنهاية سلسلة محارف المقصد. يجب على
                                المستخدم ضمان أن تكون ذاكرة المقصد المحجوزة كافية لاستيعاب العناصر الجديدة.<br> 7. مشابهة للدالة 6 لكنها تنسخ فقط العدد المحدد من عناصر المصدر.
                            </li>
                            <li>
                                <b>جد (find)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
1: عملية هذا.جد (صوان: مؤشر[مصفوفة[محرف]]): صـحيح_متكيف؛
2: عملية هذا.جد (م: مـحرف): صـحيح_متكيف؛
3: دالة جد (سلسلة: مؤشر[مصفوفة[مـحرف]]، مقطع: مؤشر[مصفوفة[مـحرف]]): مؤشر[مصفوفة[مـحرف]]؛
4: دالة جد (سلسلة: مؤشر[مصفوفة[مـحرف]]، م: مـحرف): مؤشر[مصفوفة[مـحرف]]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
1. handler this.find (buf: ptr[array[Char]]): ArchInt;
2. handler this.find (c: Char): ArchInt;
3. func find (haystack: ptr[array[Char]], needle: ptr[array[Char]]): ptr[array[Char]];
4. func find (haystack: ptr[array[Char]], c: Char): ptr[array[Char]];
</pre>
1. بحث عن سلسلة محارف داخل هذا النص. ترجع موقع بداية سلسلة المحارف المكتشفة، أو -1 إذا فشل العثورة عليها.<br> 2. بحث عن محرف داخل هذ النص. ترجع موقع المحرف المكتشف، أو -1 إذا فشل العثور عليه.<br> 3. بحث عن مقطع داخل
                                سلسلة المحارف المعطاة. ترجع مؤشر على بداية سلسلة المحارف المكتشفة، أو 0 إذا فشل العثور عليها.<br> 4. بحث عن محرف داخل سلسلة المحارف المعطاة. ترجع مؤشر على المحرف المكتشف، أو 0 إذا فشل العثور عليه.
                            </li>
                            <li>
                                <b>جد_آخر (findLast)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
1: عملية هذا.جد_آخر (صوان: مؤشر[مصفوفة[محرف]]): صـحيح_متكيف؛
2: عملية هذا.جد_آخر (م: مـحرف): صـحيح_متكيف؛
3: دالة جد_آخر (سلسلة: مؤشر[مصفوفة[مـحرف]]، مقطع: مؤشر[مصفوفة[مـحرف]]): مؤشر[مصفوفة[مـحرف]]؛
4: دالة جد_آخر (سلسلة: مؤشر[مصفوفة[مـحرف]]، م: مـحرف): مؤشر[مصفوفة[مـحرف]]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
1: handler this.findLast (buf: ptr[array[Char]]): ArchInt;
2: handler this.findLast (c: Char): ArchInt;
3: func findLast (haystack: ptr[array[Char]], needle: ptr[array[Char]]): ptr[array[Char]];
4: func findLast (haystack: ptr[array[Char]], c: Char): ptr[array[Char]];
</pre>
هذه الدالات مشابهة لدالات `جد` لكنهن تبدأن البحث من نهاية النص بدل البحث من البداية.
                            </li>
                            <li>
                                <b>قارن (compare)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
1. عملية هذا.قارن (صوان: مؤشر[مصفوفة[مـحرف]]): صـحيح؛
2. عملية هذا.قارن (صوان: مؤشر[مصفوفة[مـحرف]]، عدد: صـحيح_متكيف): صـحيح؛
3. دالة قارن (نص1: مؤشر[مصفوفة[مـحرف]]، نص2: مؤشر[مصفوفة[مـحرف]]): صـحيح؛
4. دالة قارن (نص1: مؤشر[مصفوفة[مـحرف]]، مص2: مؤشر[مصفوفة[مـحرف]]، عدد: صـحيح_متكيف): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
1. handler this.compare (buf: ptr[array[Char]]): Int;
2. handler this.compare (buf: ptr[array[Char]], count: ArchInt): Int;
3. func compare (str1: ptr[array[Char]], str2: ptr[array[Char]]): Int;
4. func compare (str1: ptr[array[Char]], str2: ptr[array[Char]], count: ArchInt): Int;
</pre>
1. تقارن النص الحالي بالنص المعطى وترجع 1 إذا كان النص الحالي أكبر أو -1 إذا كان أصغر أو 0 إذا كانا متطابقين.<br> 2. مشابهة للدالة 1 لكنها تقارن فقط العدد المحدد من عناصر الصوان المعطى.<br> 3. مشابهة للدالة 1 لكنها
                                تقارن مصفوفتي المحارف المعطاتين.<br> 4. مشابهة للدالة 3 لكنها تقارن عددا محددا فقط من محارف المصفوفة الثانية.
                            </li>
                            <li>
                                <b>استبدل (replace)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
1. عملية هذا.استبدل (التطابق: مؤشر[مصفوفة[محرف]]، البديل: مؤشر[مصفوفة[محرف]])؛
2. دالة استبدل (محارف: مؤشر[مصفوفة[مـحرف]]، من: مـحرف، إلى: مـحرف): مؤشر[مصفوفة[مـحرف]]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
1. handler this.replace (match: ptr[array[Char]], replacement: ptr[array[Char]]);
2. func replace (chars: ptr[array[Char]], from: Char, to: Char): ptr[array[Char]];
</pre>
1. تبدل جزءا من النص بآخر وترجع الناتج في نص جديد.<br> 2. تستبدل محرفًا مكان آخر في سلسلة المحارف المعطاة. هذه الدالة تغيّر المصفوفة المعطاة.
                            </li>
                            <li>
                                <b>شذب (trim)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.شذب (): نـص؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.trim (): String;
</pre>
تزيل الفراغات (المحارف غير المرئية سواء محرف المسافة أو غيرها) من طرفي النص وترجع الناتج في نص جديد.
                            </li>
                            <li>
                                <b>شذب_البداية (trimStart)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.شذب_البداية (): نـص؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.trimStart (): String;
</pre>
مشابهة لدالة `شذب` لكنها تشذب البداية فقط.
                            </li>
                            <li>
                                <b>شذب_النهاية (trimEnd)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.شذب_النهاية (): نـص؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.trimEnd (): String;
</pre>
مشابهة لدالة `شذب` لكنها تشذب النهاية فقط.
                            </li>
                            <li>
                                <b>كبر (toUpperCase)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.كبر (): نـص؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.toUpperCase (): String;
</pre>
تستبدل الأحرف اللاتينية الصغيرة بمثيلاتها الكبيرة وترجع الناتج في نص جديد.
                            </li>
                            <li>
                                <b>صغر (toLowerCase)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.صغر (): نـص؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.toLowerCase (): String;
</pre>
 تستبدل الأحرف اللاتينية الكبيرة بمثيلاتها الصغيرة وترجع الناتج في نص جديد.
                            </li>
                            <li>
                                <b>اجتزئ (slice)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.اجتزئ (بداية: صـحيح_متكيف، عدد: صـحيح_متكيف): نـص؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.slice (start: ArchInt, count: ArchInt): String;
</pre>
 ترجع جزءا من النص الحالي كنص جديد.
                            </li>
                            <li>
                                <b>قطع (split)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.قطع (فاصل: مؤشر[مصفوفة[مـحرف]]): مـصفوفة[نـص]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.split (separator: ptr[array[Char]]): Array[String];
</pre>
 ترجع أجزاء النص الحالي التي يفصلها الفاصل المعطى. إذا لم يوجد هذا النص فإنها ترجع عنصرا واحدا يحتوي النص كاملا.
                            </li>
                            <li>
                                <b>ادمج (merge)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة ادمج (أجزاء: مـصفوفة[نـص]، فاصل: مؤشر[مصفوفة[مـحرف]]): نـص؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func merge (parts: Array[String], separator: ptr[array[Char]]): String;
</pre>
 ترجع نصًا جديدا يحتوى الأجزاء المعطاة مفصولة بالفاصل المعطى.
                            </li>
                            <li>
                                <b>انسخ (copy)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
1. دالة انسخ (المقصد: مؤشر[مصفوفة[مـحرف]]، المصدر: مؤشر[مصفوفة[مـحرف]]): مؤشر؛
2. دالة انسخ (المقصد: مؤشر[مصفوفة[مـحرف]]، المصدر: مؤشر[مصفوفة[مـحرف]]، عدد: صـحيح_متكيف): مؤشر؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
1. func copy (target: ptr[array[Char]], source: ptr[array[Char]]): ptr;
2. func copy (target: ptr[array[Char]], source: ptr[array[Char]], count: ArchInt): ptr;
</pre>
 1. تنسخ سلسلة المحارف من المصدر إلى المقصد. يجب على المستخدم ضمان أن تكون الذاكرة المحجوزة للمقصد كافية لاستيعاب كامل مصفوفة المصدر.<br> 2. مشابهة للدالة 1 لكنها تنسخ فقط العدد المحدد من عناصر المصدر.
                            </li>
                            <li>
                                <b>امسح (scan)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة امسح (المصدر: مؤشر[مصفوفة[مـحرف]]، نسق: مؤشر[مصفوفة[مـحرف]]، ...أيما): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func scan (source: ptr[array[Char]], fmt: ptr[array[Char]], ...any): Int;
</pre>
 امسح سلسلة المحارف المعطاة بحثًا عن العناصر المحددة في النسق وإرجاع هذه العناصر في المعطيات الملحقة بعد النسق. هذه الدالة مطابقة لدالة النظام sscanf.
                            </li>
                            <li>
                                <b>أهو_مسافة (isSpace)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة أهو_مسافة (م: مـحرف): ثـنائي؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func isSpace (c: Char): Bool;
</pre>
 تخبرك فيما إذا كان المحرف المعطى مسافة أو إزاحة (tab) أو سطر جديد أو محرف الرجوع لبداية السطر.
                            </li>
                            <li>
                                <b>أمتطابق (isEqual)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة أمتطابق (نص1: مؤشر[مصفوفة[مـحرف]]، نص2: مؤشر[مصفوفة[مـحرف]]): ثـنائي؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func isEqual (str1: ptr[array[Char]], str2: ptr[array[Char]]): Bool;
</pre>
 تخبرك فيما لو كانت سلسلتا المحارف المعطاتان متطابقتين.
                            </li>
                            <li>
                                <b>أزل (remove)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة أزل (محارف: مؤشر[مصفوفة[مـحرف]]، م: مـحرف): مؤشر[مصفوفة[مـحرف]]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func remove (chars: ptr[array[Char]], c: Char): ptr[array[Char]];
</pre>
 تزيل كل مطابقة للمحرف المعطى من سلسلة المحارف المعطاة. إزالة المحرف تؤدي إلى تزحيف المحارف التي بعده لتحل محله.
                            </li>
                            <li>
                                <b>املأ (format)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة املأ (صيغة: مؤشر[مصفوفة[مـحرف]]، قيم: ...أيما): نـص؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func format (fmt: ptr[array[Char]], values: ...any): String;
</pre>
تنشئ نصًا جديدًا من الصيغة المعطاة بعد ملئها بالقيم المطاة. تعمل هذه الدالة بشكل مشابه لدالة sprintf، وذلك باستبدال الرموز البادئة ب% في
الصيغة بقيمة من قائمة المعطيات تطابق الصنف المحدد. الرمز % يتبعه محرف يدل على صنف القيمة المعطاة، وهي كالتالي:
                              <ul>
                                <li><b>%s</b> سلسلة محارف نصية.</li>
                                <li><b>%c</b> محرف مفرد.</li>
                                <li><b>%i</b> عدد صحيح بحجم 32 بت.</li>
                                <li><b>%l</b> عدد صحيح بحجم 64 بت.</li>
                                <li><b>%f</b> عدد عائم بحجم 32 بت.</li>
                                <li><b>%d</b> عدد عائم بحجم 64 بت.</li>
                                <li><b>%%</b> تطبع علامة % نفسها.</li>
                              </ul>
                            </li>
                            <li>
                                <b>اقرأ_صحيح (parseInt)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة اقرأ_صحيح (نص: مؤشر[مصفوفة[مـحرف]]): صـحيح[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func parseInt (str: ptr[array[Char]]): Int[64];
</pre>
تقرأ عددًا صحيحًا من سلسلة المحارف المعطاة وترجعه.
                            </li>
                            <li>
                                <b>اقرأ_عائم (parseFloat؛)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة اقرأ_عائم (نص: مؤشر[مصفوفة[مـحرف]]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func parseFloat (str: ptr[array[Char]]): Float[64];
</pre>
تقرأ عددًا عائمًا من سلسلة المحارف المعطاة وترجعه.
                            </li>
                        </ul>
                    </div>

                    <h4 class="foldable" id="Map">الصنف: تـطبيق (Map)</h4>
                    <div>
                        قالب تـطبيق (Map) يتيح تحديد صنفي المفتاح والقيمة ويتولى مسؤولية إدارة الذاكرة مع مراعاة الأداء وتجنب عمليات النسخ وحجز الذاكرة غير الضرورية. المثال التالي يوضح التعامل مع هذا التطبيق:
<pre class="samplecode" dir=rtl style="text-align:right;">
دالة رئيسي {
  عرف ت1: تـطبيق[صـحيح، صـحيح] = هات_تطبيق()؛
  ت1.حدد(7، 50)؛ // هنا يتم تمديد حجم الذاكرة المحجوزة.
  عرف ت2: تـطبيق[صـحيح، صـحيح] = ت1؛ // هنا لا يتم إنشاء نسخة جديدة من الصوان.
  ت2.حدد(12، 7)؛ // الآن يتم إنشاء نسخة جديدة كي لا يتأثر ت1.
  اطبع_تطبيق(ت2)؛ // لا يتم هنا إعادة حجز الذاكرة أو نسخها.
  اطبع_صحيح(ت2(7))؛ // سيطبع 50.
  اطبع_صحيح(ت2(12))؛ // سيطبع 7.
  // الآن يتم تحرير ذاكرة ت1 و ت2.
}

دالة هات_تطبيق (): تطبيق[صـحيح، صـحيح] {
  عرف ت: تـطبيق[صـحيح، صـحيح]؛
  ت.أضف(0، 10)؛
  ارجع ت؛ // لا يتم هنا إعادة حجز الذاكرة أو نسخها.
}

دالة اطبع_تطبيق (ت: تـطبيق[صـحيح، صـحيح]) {
  عرف ع: صـحيح؛
  لكل ع = 0، ع < ت.هات_الطول()، ++ع {
    طـرفية.اطبع("%d = %d\ج"، ت.المفتاح_عند(ع)، ت.القيمة_عند(ع))؛
  }
}
</pre>
<pre class="samplecode" dir=ltr style="text-align:left;">
func main {
  def m1: Map[Int, Int] = getMap();
  m1.set(7, 50); // Memory buffer is expanded here.
  def m2: Map[Int, Int] = m1; // Buffer is not cloned here.
  m2.set(12, 7); // Buffer is cloned here so that m1 is not affected.
  printMap(m2); // No buffer cloning happens here.
  printInt(m2(7)); // Prints 50.
  printInt(m2(12)); // Prints 7.
  // Now buffers of m1 and m2 are freed.
}

func getMap (): Map[Int, Int] {
  def m: Map[Int, Int];
  m.add(0, 10);
  return m; // No buffer cloning happens here.
}

func printMap (m: Map[Int, Int]) {
  def i: Int;
  for i = 0, i < m.getLength(), ++i {
    Console.print("%d = %d\n", m.keyAt(i), m.valAt(i));
  }
}
</pre>
                        يحتوي الصنف `تـطبيق` على العناصر التالية:
                        <ul class="subsections">
                            <li>
                              <b>التهيئة</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا~هيئ(استخدم_فهرسا: ثـنائي)؛
  عملية هذا~هيئ(سند[تـطبيق[صـنف_المفتاح، صـنف_المحتوى]])؛
  عملية هذا~هيئ(سند[تـطبيق[صـنف_المفتاح، صـنف_المحتوى]]، استخدم_فهرسا: ثـنائي)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this~init (useIndex: Bool);
  handler this~init (ref[Map[KeyType, ValueType]]);
  handler this~init (ref[Map[KeyType, ValueType]], useIndex: Bool);
</pre>
                              الصيغة الأولى تهيئ تطبيقًا فارغًا مع الاختيار بين استخدام فهرس من عدمه. استخدام الفهرس يسرع البحث عن العناصر في التطبيق، على حساب استهلاك الذاكرة وتبطيء إضافة العناصر.<br>
                              الصيغة الثانية تهيئ التطبيق من تطبيق آخر. سيستخدم التطبيق الجديد نفس المحتوى الذي في التطبيق المعطى ولن يتم
                              نسخ المحتوى حتى يغير أحد التطبيقين المحتوى، وعندها ينسخ المحتوى قبل التغيير لضمان عدم تأثر التطبيق الآخر. في
                              هذه الصيغة لن يتم استخدام فهرس حتى لو كان للتطبيق المعطى فهرس.<br>
                              الصيغة الثالثة مشابهة للثانية مع تمكين المستخدم من استخدام فهرس. إن طلب المستخدم استخدام فهرس فسيتم ذلك حتى
                              لو خلا التطبيق المعطى من الفهرس.
                            </li>
                            <li>
                                <b>مفاتيح (keys)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عرف مفاتيح: مـصفوفة[صـنف_المفتاح]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  def keys: Array[KeyType];
</pre>
                              مصفوفة المفاتيح التي في هذا التطبيق.
                            </li>
                            <li>
                                <b>قيم (values)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عرف قيم: مـصفوفة[صـنف_المحتوى]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  def values: Array[ValueType];
</pre>
                              مصفوفة المحتويات التي في هذا التطبيق.
                            </li>
                            <li>
                                <b>هات_الطول (getLength)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_الطول (): صـحيح_متكيف؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getLength (): ArchInt;
</pre>
                              ترجع عدد العناصر في التطبيق.
                            </li>
                            <li>
                                <b>المفتاح_عند (keyAt)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.المفتاح_عند (صـحيح_متكيف): سند[صـنف_المفتاح]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.keyAt (ArchInt): ref[KeyType];
</pre>
                              ترجع سندًا للمفتاح الذي عند الموقع المطلوب.
                            </li>
                            <li>
                                <b>القيمة_عند (valAt)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.القيمة_عند (صـحيح_متكيف): سند[صـنف_المحتوى]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.valAt (ArchInt): ref[ValueType];
</pre>
                              ترجع سندًا للقيمة التي عند الموقع المطلوب.
                            </li>
                            <li>
                                <b>حدد (set)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.حدد (
      مفتاح: صـنف_المفتاح، قيمة: صـنف_القيمة
  ): سند[تـطبيق[صـنف_المفتاح، صـنف_المحتوى]]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.set (
    key: KeyType, value: ValueType
  ): ref[Map[KeyType, ValueType]];
</pre>
                              تحدد قيمة للمفتاح المعطى. إن كان لهذا المفتاح قيمة فإنها ستبدل بالقيمة الجديدة. هذه الدالة ترجع سندا للتطبيق نفسه،
                              ما يمكن المستخدم من سلسلة عدة عمليات تحديد في جملة واحدة.
                            </li>
                            <li>
                                <b>حدد_عند (setAt)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.حدد_عند (
      تسلسل: صـحيح_متكيف، قيمة: صـنف_القيمة
  ): سند[تـطبيق[صـنف_المفتاح، صـنف_المحتوى]]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.setAt (
    index: ArchInt, value: ValueType
  ): ref[Map[KeyType, ValueType]];
</pre>
                              تحدد قيمة جيدة عند التسلسل المعطى، أي تغيير القيمة باستخدام تسلسلها بدلاً من مفتاحها.
                              هذه الدالة ترجع سندا للتطبيق نفسه، ما يمكن المستخدم من سلسلة عدة عمليات تحديد في جملة واحدة.
                            </li>
                            <li>
                                <b>احشر (insert)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.احشر (تسلسل: صـحيح_متكيف، مفتاح: صـنف_المفتاح، قيمة: صـنف_القيمة)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.insert (index: ArchInt, key: KeyType, value: ValueType);
</pre>
                              تضيف مفتاحًا جديدًا وقيمته عند التسلسل المحدد.
                            </li>
                            <li>
                                <b>أزل (remove)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.أزل (مفتاح: صـنف_المفتاح): ثـنائي؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.remove (key: KeyType): Bool;
</pre>
                              تزيل المفتاح المحدد وقيمته. ترجع 1 إذا أُزيل المفتاح، و 0 إذا لم يوجد المفتاح ابتداءًا.
                            </li>
                            <li>
                                <b>أزل_عند (removeAt)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.أزل_عند (تسلسل: صـحيح_متكيف)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.removeAt (index: ArchInt);
</pre>
                              تزيل المفتاح عند التسلسل المحدد وقيمتَه.
                            </li>
                            <li>
                                <b>فرغ (clear)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.فرغ ()؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.clear ();
</pre>
                              تفرغ كل المحتوى وتبدأ بتطبيق فارغ.
                            </li>
                            <li>
                                <b>جد_الموقع (findPos؛)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.جد_الموقع (مفتاح: صـنف_المفتاح): صـحيح_متكيف؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.findPos (key: KeyType): ArchInt;
</pre>
                              ترجع تسلسل المفتاح المعطى، أو -1 إن لم يوجد هذا المفتاح.
                            </li>
                        </ul>
                    </div>

                    <h4 class="foldable" id="SrdRef">الصنف: سـندنا (SrdRef)</h4>
                    <div>
                        قالب سند مشترك يتولى تلقائيا تحرير الكائن عندما تنتهي الحاجة له. يحتفظ هذا السند بعداد لعدد السندات المشتركة
                        التي تشير لنفس الكائن. كلما يُتلف أحد السندات يُنقص العداد وعندما يصل العداد لصفر يُتلف الكائن وتحرر ذاكرته.
<pre class="samplecode" dir=rtl style="text-align:right;">
دالة رئيسي {
  عرف س: سـندنا[صـنفي] = سـندنا[صـنفي].أنشئ()؛
  عرف ص: سـندنا[صـنفي] = س؛ // الآن كلا السندين يشيران لنفس الكائن وعداده الآن 2.
  س.حرر()؛ // العداد صار 1 لكن الكائن لم يُحرر بعد.
  ص.حرر()؛ // الآن أتلف الكائن وحررت ذاكرته.
}
</pre>
<pre class="samplecode" dir=ltr style="text-align:left;">
func main {
  def x: SrdRef[MyType] = SrdRef[MyType].construct();
  def y: SrdRef[MyType] = x; // Both refs point to same object. Counter is now 2.
  x.release(); // Counter is now 1 and the object is not freed yet.
  y.release(); // Now the object is destructed and its memory is released.
}
</pre>
                        يحتوي الصنف `سـندنا` على المتغيرات والدالات التالية:
                        <ul class="subsections">
                            <li>
                                <b>كائن (obj)</b><br/>
                                الكائن الذي يشير إليه هذا السند. في بعض الحالات قد تحتاج للوصول إلى الكائن نفسه مثلما هو الحال عندما
                                تحتاج مؤشرًا أو سندا اعتياديا للكائن أو في حالة الوصول إلى دالة للكائن باسم مطابق لإحدى دالات الصنف `سـندنا`.
                            </li>
                            <li>
                              <b>عداد_السندات (refCounter)</b><br/>
                              القيد الذي يحتفظ بعداد السندات التي تؤشر لنفس الكائن ويحتفظ أيضا بالبيانات المطلوبة لإتلاف وتحرير الكائن.
                            </li>
                            <li>
                              <b>احجز (alloc)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.احجز (): سند[صـنف_الكائن]؛
  دالة احجز (): سـندنا[صـنف_الكائن]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.alloc (): ref[ObjType];
  func alloc (): SrdRef[ObjType];
</pre>
                              تقوم هذه الدالة بحجز ذاكرة للكائن، لكنها لا تهيئ الكائن وتترك للمستخدم مسؤولية التهيئة باستخدام `~هيئ`.
                            </li>
                            <li>
                              <b>أنشئ (construct)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.أنشئ ()؛
  دالة أنشئ (): سـندنا[صـنف_الكائن]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.construct ();
  func construct (): SrdRef[ObjType];
</pre>
                              تقوم هذه الدالة بحجز ذاكرة للكائن وتهيئته أيضًا. تهيئة الكائن تتم دون أي معطيات لذا لاستخدام هذه الدالة يحتاج
                              الكائن لتمكين التهيئة دون معطيات. إذا احتجت تهيئة الكائن بمعطيات فستحتاج لاستخدام دالة `احجز` بدلًا من هذه الدالة
                              ثم التهيئة يدويا باستخدام `~هيئ`.
                            </li>
                            <li>
                              <b>تملك (own)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.تملك (كائن: سند[صـنف_الكائن])؛
  دالة تملك (كائن: سند[صـنف_الكائن]): سـندنا[صـنف_الكائن]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.own (obj: ref[ObType]);
  func own (obj: ref[ObjType]): SrdRef[ObjType];
</pre>
                              هذه الدالة تعين كائن هذا السند بكائن متوفر سلفًا. بعد استدعاء هذه الدالة يتولى هذا السند مسؤولية تحرير الكائن
                              تلقائيًا. يجب تجنب هذه الدالة إذا لم يكن الكائن المعطى محجوزًا ديناميكيًا أو إذا تولت شفرة أخرى مسؤولية تحرير
                              الكائن لأن ذلك سيؤدي إلى segmentation fault.
                            </li>
                            <li>
                              <b>حرر (release)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.حرر()؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.release();
</pre>
                              تصفر هذا السند وإذا كان هذا آخر سند يشير إلى الكائن فتُحرر الكائن قبل تصفير السند.
                            </li>
                            <li>
                              <b>عين (assign)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.عين (س: سند[سـندنا[صـنف_الكائن]])؛
  عملية هذا.عين (س: سند[سـندهم[صـنف_الكائن]])؛
  عملية هذا.عين (ع: سند[عـداد_السندات]، ك: سند[صـنف_الكائن])؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.assign (r: ref[SrdRef[ObjType]]);
  handler this.assign (r: ref[WkRef[ObjType]]);
  handler this.assign (c: ref[RefCounter], o: ref[ObjType]);
</pre>
                              تعين قيمة جديدة للسند، أي تغير السند ليؤشر إلى الكائن المعطى. الدالتان الأولى والثانية تأخذان
                              قيمة السند من صنف `سـندنا` وصنف `سـندهم` على التوالي وبنفس صنف الكائن، أما الدالة الثالثة فتستخدم لجعل السند يشير
                              إلى كائن بنفس صنف هذا السند لكنه ينتمي لسند من صنف آخر. تستخدم هذه الدالة في حالة التمثيل وما شابه مع ضمان أن
                              تحرير الكائن عند إتلاف السند سيؤدي إلى تحرير الكائن الأصلي وبصنفه الأصلي الذي أنشئ عليه. المثال التالي يوضح الفرق:
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرف س: سـندنا[صـنفي]؛
  س.أنشئ()؛
  عرف ص: سـندنا[صـنف_فرعي]؛
  ص.عين(س.عداد_السندات، س.فرعي)؛

  س.حرر()؛ // لن يحرر شيئًا الآن لأن ص ما زال يحجز الكائن.
  ص.حرر()؛ // هنا سيُحرر كائن س نفسه وليس س.فرعي.
</pre>
<pre class="samplecode" dir=ltr style="text-align:left;">
  def x: SrdRef[MyType];
  x.construct();
  def y: SrdRef[SubType];
  y.assign(x.refCounter, x.subObj);
  
  x.release(); // Nothing will be released as y still holds the object.
  y.release(); // Here x itself will be released, not x.subObj.
</pre>
                            </li>
                            <li>
                              <b>أهو_لعدم (isNull)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.أهو_لعدم(): ثـنائي؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.isNull(): Bool;
</pre>
                              تتحقق فيما لو كان السند يشير لعدم، أي فيما لو كان مؤشره صفرًا.
                            </li>
                        </ul>
                    </div>

                    <h4 class="foldable" id="WkRef">الصنف: سـندهم (WkRef)</h4>
                    <div>
                        قالب سند يشير لكائن لكنه لا يُساهم في تملك الكائن، أي أنه ليس له حصة في عداد السندات الخاص بالكائن. بمعنى آخر، إذا
                        كان هذا السند يشير لكان وأتلفت جميع سندات `سـندنا` المشيرة للكائن فإن الكائن سيُحرر رغم وجود `سـندهم` يشير إليه.
                        يفيد هذا النوع من السندات في تجنب حلقات السندات المغلقة التي تؤدي إلى تسرب في الذاكرة. فإن كان عندك كائن يمتلك
                        كائنًا آخر عبر `سـندنا` وكان الكائن الداخلي يحتاج سندًا للكائن الخارجي فاستخدام `سـندنا` في الكائن الداخلي سيؤدي
                        إلى حلقة مغلقة بينما استخدام `سـندهم` في الكائن الداخلي لي يؤدي للحلقة المغلقة لأن تحرير الكائن الخارجي في هذه
                        الحالة ممكن رغم وجود كائن داخلي يشير إليه.<br>
                        الفرق بين استخدام `سـندهم` واستخدام `سند` أن الأول يحمل معلومات عداد السندات وإن كان لا يستعملها، بينما السند التقليدي
                        لا يحمل تلك المعلومات، لذلك بالإمكان الحصول على `سـندنا` من `سـندهم` بينما لا يمكن الحصول على `سـندنا` من `سند`
                        لأن الأخير لا يحمل معلومات العداد التي يحتاجها `سـندنا`.<br>
                        طريقة استخدام `سـندهم` مطابقة لـ`سـندنا`. يملك صنف `سـندهم` العناصر التالية:
                        <ul class="subsections">
                          <li>
                              <b>كائن (obj)</b><br/>
                              الكائن الذي يشير إليه هذا السند. في بعض الحالات قد تحتاج للوصول إلى الكائن نفسه مثلما هو الحال عندما
                              تحتاج مؤشرًا أو سندا اعتياديا للكائن أو في حالة الوصول إلى دالة للكائن باسم مطابق لإحدى دالات الصنف `سـندهم`.
                          </li>
                          <li>
                            <b>عداد_السندات (refCounter)</b><br/>
                            القيد الذي يحتفظ بعداد السندات التي تؤشر لنفس الكائن ويحتفظ أيضا بالبيانات المطلوبة لإتلاف وتحرير الكائن.
                          </li>
                          <li>
                            <b>حرر (release)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.حرر()؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.release();
</pre>
                            تصفر هذا السند دون تغيير شيء في عداد السندات.
                          </li>
                          <li>
                            <b>عين (assign)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.عين (س: سند[سـندنا[صـنف_الكائن]])؛
  عملية هذا.عين (س: سند[سـندهم[صـنف_الكائن]])؛
  عملية هذا.عين (ع: سند[عـداد_السندات]، ك: سند[صـنف_الكائن])؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.assign (r: ref[SrdRef[ObjType]]);
  handler this.assign (r: ref[WkRef[ObjType]]);
  handler this.assign (c: ref[RefCounter], o: ref[ObjType]);
</pre>
                            تعين قيمة جديدة للسند، أي تغير السند ليؤشر إلى الكائن المعطى. الدالتان الأولى والثانية تأخذان
                            قيمة السند من صنف `سـندنا` وصنف `سـندهم` على التوالي وبنفس صنف الكائن، أما الدالة الثالثة فتستخدم لجعل السند يشير
                            إلى كائن بنفس صنف هذا السند لكنه ينتمي لسند من صنف آخر. تستخدم هذه الدالة في حالة التمثيل وما شابه مع ضمان أن
                            تحرير الكائن عند إتلاف السند سيؤدي إلى تحرير الكائن الأصلي وبصنفه الأصلي الذي أنشئ عليه. المثال التالي يوضح الفرق:
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرف س: سـندنا[صـنفي]؛
  س.أنشئ()؛
  عرف ع: سـندهم[صـنف_فرعي]؛
  ع.عين(س.عداد_السندات، س.فرعي)؛
  عرف ص: سـندنا[صـنف_فرعي]؛
  ص = ع؛

  س.حرر()؛ // لن يحرر شيئًا الآن لأن ص ما زال يحجز الكائن.
  ص.حرر()؛ // هنا سيُحرر كائن س نفسه وليس س.فرعي.
</pre>
<pre class="samplecode" dir=ltr style="text-align:left;">
  def x: SrdRef[MyType];
  x.construct();
  def y: WkRef[SubType];
  y.assign(x.refCounter, x.subObj);
  def z: SrdRef[SubType];
  z = y;
  
  x.release(); // Nothing is released here.
  z.release(); // x will be released here, not x.subObj.
</pre>
                          </li>
                          <li>
                              <b>أهو_لعدم (isNull)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.أهو_لعدم(): ثـنائي؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.isNull(): Bool;
</pre>
                              تتحقق فيما لو كان السند يشير لعدم، أي فيما لو كان مؤشره صفرًا.
                          </li>
                      </ul>
                    </div>

                    <h4 class="foldable" id="UnqRef">الصنف: سـندي (UnqRef)</h4>
                    <div>
                        أبسط أنواع السندات الذكية. هذا السند غير مشترك ولا يستخدم عدادًا للسندات. عند إتلاف هذا السند فإنه سيحرر الكائن
                        الذي يملكه مباشرة. مثال:
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرف س: سـندي[صـنفي]؛
  س.أنشئ()؛

  عرف ص: سـندي[صـنفي]؛
  ص = س؛ // خطأ.

  س.حرر()؛ // يُحرر الكائن هنا تلقائيا.
</pre>
<pre class="samplecode" dir=ltr style="text-align:left;">
  def x: UnqRef[MyType];
  x.construct();
  
  def y: UnqRef[MyType];
  y = x; // Error.
  
  x.release(); // Object will be released here.
</pre>
                        يحتوي هذا الصنف على العناصر التالية:
                        <ul class="subsections">
                          <li>
                              <b>كائن (obj)</b><br/>
                              الكائن الذي يشير إليه هذا السند. في بعض الحالات قد تحتاج للوصول إلى الكائن نفسه مثلما هو الحال عندما
                              تحتاج مؤشرًا أو سندا اعتياديا للكائن أو في حالة الوصول إلى دالة للكائن باسم مطابق لإحدى دالات الصنف `سـندهم`.
                          </li>
                          <li>
                            <b>أنشئ (construct)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.أنشئ()؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.construct();
</pre>
                            تقوم هذه الدالة بحجز ذاكرة للكائن وتهيئته أيضًا. تهيئة الكائن تتم دون أي معطيات لذا لاستخدام هذه الدالة يحتاج
                            الكائن لتمكين التهيئة دون معطيات.
                          </li>
                          <li>
                            <b>حرر (release)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.حرر()؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.release();
</pre>
                            تصفر هذا السند وتحرر الكائن.
                          </li>
                          <li>
                              <b>أهو_لعدم (isNull)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.أهو_لعدم(): ثـنائي؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.isNull(): Bool;
</pre>
                              تتحقق فيما لو كان السند يشير لعدم، أي فيما لو كان مؤشره صفرًا.
                          </li>
                        </ul>
                    </div>

                    <h4 class="foldable" id="Memory">الوحدة: ذاكـرة (Memory)</h4>
                    <div>
                        تحتوي وحدة `ذاكـرة` على الدالات التالية:
                        <ul class="subsections">
                            <li>
                                <b>احجز (alloc)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[malloc] دالة احجز (حجم: صـحيح_متكيف): مؤشر؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[malloc] func alloc (size: ArchInt): ptr;
</pre>
 مطابقة لدالة malloc من POSIX.
                            </li>
                            <li>
                                <b>أعد_الحجز (realloc)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[realloc] دالة أعد_الحجز (م: مؤشر، الحجم_الجديد: صـحيح_متكيف): مؤشر؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[realloc] func realloc (p: ptr, newSize: ArchInt): ptr;
</pre>
 مطابقة لدالة realloc من POSIX.
                            </li>
                            <li>
                                <b>احجز_مرصوف (allocAligned)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[aligned_alloc]
دالة احجز_مرصوف (رصف: صـحيح_متكيف، حجم: صـحيح_متكيف): مؤشر؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[aligned_alloc]
func allocAligned (alignment: ArchInt, size: ArchInt): ptr;
</pre>
 مطابقة لدالة aligned_alloc من POSIX.
                            </li>
                            <li>
                                <b>حرر (free)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[free] دالة حرر (م: مؤشر)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[free] func free (p: ptr);
</pre>
 مطابقة لدالة free من POSIX.
                            </li>
                            <li>
                                <b>انسخ (copy)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[memcpy] دالة (مقصد: مؤشر، مصدر: مؤشر، حجم: صـحيح_متكيف): مؤشر؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[memcpy] func (target: ptr, src: ptr, size: ArchInt): ptr;
</pre>
 مطابقة لدالة memcpy من POSIX.
                            </li>
                            <li>
                                <b>قارن (compare)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[memcmp] دالة قارن (حيز1: مؤشر، حيز2: مؤشر: حجم: صـحيح_متكيف): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[memcmp] func compare (s1: ptr, s2: ptr, size: ArchInt): Int;
</pre>
 مطابقة لدالة memcmp من POSIX.
                            </li>
                            <li>
                                <b>اضبط (set)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[memset] دالة (حيز: مؤشر، قيمة: صـحيح، عدد: صـحيح_متكيف): مؤشر؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[memset] func (s: ptr, c: Int, n: ArchInt): ptr;
</pre>
 مطابقة لدالة memset من POSIX.
                            </li>
                        </ul>
                    </div>

                    <h4 class="foldable" id="Math">الوحدة: ريـاضيات (Math)</h4>
                    <div>
                        تحتوي وحدة `ريـاضيات` على الدالات التالية:
                        <ul class="subsections">
                            <li>
                                <b>مطلق (abs)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[abs] دالة مطلق (ع: صـحيح[32]): صـحيح[32]؛
@تصدير[llabs] دالة مطلق (ع: صـحيح[64]): صـحيح[64]؛
@تصدير[fabsf] دالة مطلق (ع: عـائم[32]): عـائم[32]؛
@تصدير[fabs] دالة مطلق (ع: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[abs] func abs (i: Int[32]): Int[32];
@expname[llabs] func abs (i: Int[64]): Int[64];
@expname[fabsf] func abs (f: Float[32]): Float[32];
@expname[fabs] func abs (f: Float[64]): Float[64];
</pre>
 للحصول على القيمة المطلقة لرقم.
                            </li>
                            <li>
                                <b>باقي (mod)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[fmodf] دالة باقي (س: عـائم[32]، ص: عـائم[32]): عـائم[32]؛
@تصدير[fmod] دالة باقي (س: عـائم[64]، ص: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[fmodf] func mod (x: Float[32], y: Float[32]): Float[32];
@expname[fmod] func mod (x: Float[64], y: Float[64]): Float[64];
</pre>
 للحصول على باقي قسمة رقمين حقيقيين.
                            </li>
                            <li>
                                <b>أس_طبيعي (exp)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[expf] دالة أس_طبيعي (س: عـائم[32]): عـائم[32]؛
@تصدير[exp] دالة أس_طبيعي (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[expf] func exp (x: Float[32]): Float[32];
@expname[exp] func exp (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي exp و expf من POSIX.
                            </li>
                            <li>
                                <b>أس_طبيعي2 (exp2)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[exp2f] دالة أس_طبيعي2 (س: عـائم[32]): عـائم[32]؛
@تصدير[exp2] دالة أس_طبيعي2 (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[exp2f] func exp2 (x: Float[32]): Float[32];
@expname[exp2] func exp2 (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي exp2 و exp2f من POSIX.
                            </li>
                            <li>
                                <b>لو (log)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[logf] دالة لو (س: عـائم[32]): عـائم[32]؛
@تصدير[log] دالة لو (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[logf] func log (x: Float[32]): Float[32];
@expname[log] func log (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي log و logf من POSIX.
                            </li>
                            <li>
                                <b>لو2 (log2)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[log2f] دالة لو2 (س: عـائم[32]): عـائم[32]؛
@تصدير[log2] دالة لو2 (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[log2f] func log2 (x: Float[32]): Float[32];
@expname[log2] func log2 (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي log2 و log2f من POSIX.
                            </li>
                            <li>
                                <b>لو10 (log10)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[log10f] دالة لو10 (س: عـائم[32]): عـائم[32]؛
@تصدير[log10] دالة لو10 (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[log10f] func log10 (x: Float[32]): Float[32];
@expname[log10] func log10 (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي log10 و log10f من POSIX.
                            </li>
                            <li>
                                <b>جذر (sqrt)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[sqrtf] دالة جذر (س: عـائم[32]): عـائم[32]؛
@تصدير[sqrt] دالة جذر (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[sqrtf] func sqrt (x: Float[32]): Float[32];
@expname[sqrt] func sqrt (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي sqrt و sqrtf من POSIX.
                            </li>
                            <li>
                                <b>جذر3 (cbrt)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[cbrtf] دالة جذر3 (س: عـائم[32]): عـائم[32]؛
@تصدير[cbrt] دالة جذر3 (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[cbrtf] func cbrt (x: Float[32]): Float[32];
@expname[cbrt] func cbrt (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي cbrt و cbrtf من POSIX.
                            </li>
                            <li>
                                <b>ارفع (pow)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[powf] دالة ارفع (أساس: عـائم[32]، أس: عـائم[32]): عـائم[32]؛
@تصدير[pow] دالة ارفع (أساس: عـائم[64]، أس: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[powf] func pow (b: Float[32], e: Float[32]): Float[32];
@expname[pow] func pow (b: Float[64], e: Float[64]): Float[64];
</pre>
 مطابقة لدالتي pow و powf من POSIX.
                            </li>
                            <li>
                                <b>جا (sin)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[sinf] دالة جا (س: عـائم[32]): عـائم[32]؛
@تصدير[sin] دالة جا (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[sinf] func sin (x: Float[32]): Float[32];
@expname[sin] func sin (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي sin و sinf من POSIX.
                            </li>
                            <li>
                                <b>جا_عكسي (asin)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[asinf] دالة جا_عكسي (س: عـائم[32]): عـائم[32]؛
@تصدير[asin] دلة جا_عكسي (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[asinf] func asin (x: Float[32]): Float[32];
@expname[asin] func asin (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي asin و asinf من POSIX.
                            </li>
                            <li>
                                <b>جا_زائدي (sinh)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[sinhf] دالة جا_زائدي (س: عـائم[32]): عـائم[32]؛
@تصدير[sinh] دالة جا_زائدي (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[sinhf] func sinh (x: Float[32]): Float[32];
@expname[sinh] func sinh (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي sinh و sinhf من POSIX.
                            </li>
                            <li>
                                <b>جا_زائدي_عكسي (asinh)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[asinhf] دالة جا_زائدي_عكسي (س: عـائم[32]): عـائم[32]؛
@تصدير[asinh] دالة جا_زائدي_عكسي (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[asinhf] func asinh (x: Float[32]): Float[32];
@expname[asinh] func asinh (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي asinh و asinhf من POSIX.
                            </li>
                            <li>
                                <b>جتا (cos)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[cosf] دالة جتا (س: عـائم[32]): عـائم[32]؛
@تصدير[cos] دالة جتا (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[cosf] func cos (x: Float[32]): Float[32];
@expname[cos] func cos (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي cos و cosf من POSIX.
                            </li>
                            <li>
                                <b>جتا_عكسي (acos)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[acosf] دالة جتا_عكسي (س: عـائم[32]): عـائم[32]؛
@تصدير[acos] دالة جتا_عكسي (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[acosf] func acos (x: Float[32]): Float[32];
@expname[acos] func acos (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي acos و acosf من POSIX.
                            </li>
                            <li>
                                <b>جتا_زائدي (cosh)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[coshf] دالة جتا_زائدي (س: عـائم[32]): عـائم[32]؛
@تصدير[cosh] دالة جتا_عكسي (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[coshf] func cosh (x: Float[32]): Float[32];
@expname[cosh] func cosh (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي cosh و coshf من POSIX.
                            </li>
                            <li>
                                <b>جتا_زائجي_عكسي (acosh)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[acoshf] دالة جتا_زائجي_عكسي (س: عـائم[32]): عـائم[32]؛
@تصدير[asoch] دالة جتا_زائجي_عكسي (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[acoshf] func acosh (x: Float[32]): Float[32];
@expname[acosh] func acosh (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي acosh و acoshf من POSIX.
                            </li>
                            <li>
                                <b>ظل (tan)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[tanf] دالة ظل (س: عـائم[32]): عـائم[32]؛
@تصدير[tan] دالة ظل (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[tanf] func tan (x: Float[32]): Float[32];
@expname[tan] func tan (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي tan و tanf من POSIX.
                            </li>
                            <li>
                                <b>ظل_عكسي (atan)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[atanf] دالة ظل_عكسي (س: عـائم[32]): عـائم[32]؛
@تصدير[atan] دالة ظل_عكسي (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[atanf] func atan (x: Float[32]): Float[32];
@expname[atan] func atan (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي atan و atanf من POSIX.
                            </li>
                            <li>
                                <b>ظل_عكسي2 (atan2)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[atan2f] دالة ظل_عكسي2 (ص: عـائم[32]، س: عـائم[32]): عـائم[32]؛
@تصدير[atan2] دالة ظل_عكسي2 (ص: عـائم[64]، س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[atan2f] func atan2 (y: Float[32], x: Float[32]): Float[32];
@expname[atan2] func atan2 (y: Float[64], x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي atan2 و atan2f من POSIX.
                            </li>
                            <li>
                                <b>ظل_زائدي (tanh)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[tanhf] دالة ظل_زائدي (س: عـائم[32]): عـائم[32]؛
@تصدير[tanh] دالة ظل_زائدي (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[tanhf] func tanh (x: Float[32]): Float[32];
@expname[tanh] func tanh (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي tanh و tanhf من POSIX.
                            </li>
                            <li>
                                <b>ظل_زائدي_عكسي (atanh)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[atanhf] دالة ظل_زائدي_عكسي (س: عـائم[32]): عـائم[32]؛
@تصدير[atanh] جالة ظل_زائدي_عكسي (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[atanhf] func atanh (x: Float[32]): Float[32];
@expname[atanh] func atanh (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي atanh و atanhf من POSIX.
                            </li>
                            <li>
                                <b>سقف (ceil)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[ceilf] دالة سقف (س: عـائم[32]): عـائم[32]؛
@تصدير[ceil] دالة سقف (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[ceilf] func ceil (x: Float[32]): Float[32];
@expname[ceil] func ceil (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي ceil و ceilf من POSIX.
                            </li>
                            <li>
                                <b>جزء_صحيح (floor)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[floorf] دالة جزء_صحيح (س: عـائم[32]): عـائم[32]؛
@تصدير[floor] دالة جزء_صحيح (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[floorf] func floor (x: Float[32]): Float[32];
@expname[floor] func floor (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي floor و floorf من POSIX.
                            </li>
                            <li>
                                <b>تقريب (round)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[roundf] دالة تقريب (س: عـائم[32]): عـائم[32]؛
@تصدير[round] دالة تقريب (س: عـائم[64]): عـائم[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[roundf] func round (x: Float[32]): Float[32];
@expname[round] func round (x: Float[64]): Float[64];
</pre>
 مطابقة لدالتي round و roundf من POSIX.
                            </li>
                            <li>
                                <b>عشوائي (random)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[rand] دالة عشوائي (): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[rand] func random (): Int;
</pre>
 مطابقة لدالة rand من POSIX.
                            </li>
                            <li>
                                <b>جهز_العشوائية (seedRandom)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[srand] دالة جهز_العشوائية (ب: طـبيعي[32])؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[srand] func seedRandom (s: Word[32]);
</pre>
 مطابقة لدالة srand من POSIX.
                            </li>
                        </ul>
                    </div>

                    <h4 class="foldable" id="Net">الوحدة: شـبكة (Net)</h4>
                    <div>
                        تحتوي وحدة `شـبكة` على العناصر التالية:
                        <ul class="subsections">
                            <li>
                                <b>هات_اعتماديات_البناء (getBuildDependencies)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة هات_اعتماديات_البناء (): مـصفوفة[نـص]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func getBuildDependencies(): Array[String];
</pre>
                        ترجع أسماء الاعتماديات المطلوبة في حالة بناء نسخة تنفيذية من مشروع يعتمد على
                        وحدة `شـبكة`. في حالة `شـبكة` ترجع الدالة مكتبة واحدة وهي Curl. القيمة المرجعة
                        تحتوي المسار الكامل للملف وليس فقط الاسم لأن الأسس تعتمد على نسخة من Curl مضمنة
                        مع مكتبات الأسس.
                            </li>

                            <li>
                                <b>هات (get)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
1: دالة هات (
     الرابط: مؤشر[مصفوفة[مـحرف]]، الناتج: مؤشر[مؤشر]، حجم_الناتج: مؤشر[صـحيح]
   ) => ثـنائي؛
2: دالة هات (
     الرابط: مؤشر[مصفوفة[مـحرف]]، اسم_الملف: مؤشر[مصفوفة[مـحرف]]
   ) => ثـنائي؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
1: func get (
     url: ptr[array[Char]], result: ptr[ptr], resultCount: ptr[Int]
   ): Bool;
2: func get (
     url: ptr[array[Char]], filename: ptr[array[Char]]
   ): Bool;
</pre>
 1: تجلب المورد المحدد بالرابط وترجعه.<br> 2: تجلب المورد المحدد بالرابط وتخزنه في الملف المحدد.
                            </li>
                        </ul>
                    </div>

                    <h4 class="foldable" id="Console">الوحدة: طـرفية (Console)</h4>
                    <div>
                        تحتوي وحدة `طـرفية` على الدالات التالية:
                        <ul class="subsections">
                            <li>
                                <b>أدخل_محرفا (getChar)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[getchar] دالة أدخل_محرفا (): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[getchar] func getChar (): Int;
</pre>
 مطابقة لدالة getchar من POSIX.
                            </li>
                            <li>
                                <b>أخرج_محرفا (putChar)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[putchar] دالة أخرج_محرفا (محرف: صـحيح): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[putchar] func putChar (c: Int): Int;
</pre>
 مطابقة لدالة putchar من POSIX.
                            </li>
                            <li>
                                <b>اطبع (print)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
1. @تصدير[printf] دالة اطبع (نسق: مؤشر[مصفوفة[مـحرف]]، ...أيما): صـحيح؛
2. دالة اطبع (ص: صـحيح[64])؛
3. دالة اطبع (ع: عـائم[64])؛
4. دالة اطبع (ع: عـائم[64]، ص: صـحيح)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
1. @expname[printf] func print (fmt: ptr[array[Char]], ...any): Int;
2. func print (i: Int[64]);
3. func print (f: Float[64]);
4. func print (f: Float[64], n: Int);
</pre>
 1: مطابقة لدالة printf من POSIX.<br> 2: تطبع عدداً صحيحاً.<br> 3: تطبع عدداً عائماً.<br> 4: تطبع عدداً عائماً مع تحكم بعدد الأصفار على يمين الفاصلة.
                            </li>
                            <li>
                                <b>امسح (scan)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[scanf] دالة امسح (نسق: مؤشر[مصفوفة[مـحرف]]، ...أيما): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[scanf] func scan (fmt: ptr[array[Char]], ...any): Int;
</pre>
 مطابقة لدالة scanf من POSIX.
                            </li>
                            <li>
                                <b>أدخل_صحيح (getInt)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة أدخل_صحيح (): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func getInt (): Int;
</pre>
 تطلب من المستخدم إدخال عدد صحيح.
                            </li>
                            <li>
                                <b>أدخل_عائم (getFloat)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة أدخل_عائم (): عـائم؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
print getFloat (): Float;
</pre>
 تطلب من المستخدم إدخال عدد بفاصلة عائمة.
                            </li>
                            <li>
                                <b>أدخل_محارف (getString)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة أدخل_محارف (محارف: مؤشر[مصفوفة[مـحرف]]، عدد: طـبيعي)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func getString (str: ptr[array[Char]], size: Word);
</pre>
 تطلب من المستخدم إدخال سلسلة محارف.
                            </li>
                        </ul>

                        <h5 class="foldable">طـراز (Style)</h5>
                        <div>
                            تحتوي وحدة 'طـراز' على دالات للتحكم بطراز الكتابة في الطرفية. كل واحدة من هذه الدالات ترجع مؤشراً على مصفوفة محارف يمكن طباعتها في الطرفية للحصول على الطراز المطلوب.
                            <ul>
                                <li><b>صفر (reset)</b></li>
                                <li><b>لقب (bright)</b></li>
                                <li><b>خافت (dim)</b></li>
                                <li><b>مائل (italic)</b></li>
                                <li><b>خط_تحتي (underscore)</b></li>
                                <li><b>وميض (blink)</b></li>
                                <li><b>عكس (reverse)</b></li>
                                <li><b>مخفي (hidden)</b></li>
                                <li><b>كتابة_سوداء (fgBlack)</b></li>
                                <li><b>كتابة_حمراء (fgRed)</b></li>
                                <li><b>كتابة_خضراء (fgGreen)</b></li>
                                <li><b>كتابة_صفراء (fgYellow)</b></li>
                                <li><b>كتابة_زرقاء (fgBlue)</b></li>
                                <li><b>كتابة_أرجوانية (fgMagenta)</b></li>
                                <li><b>كتابة_سماوية (fgCyan)</b></li>
                                <li><b>كتابة_بيضاء (fgWhite)</b></li>
                                <li><b>خلفية_سوداء (bgBlack)</b></li>
                                <li><b>خلفية_حمراء (bgRed)</b></li>
                                <li><b>خلفية_خضراء (bgGreen)</b></li>
                                <li><b>خلفية_صفراء (bgYellow)</b></li>
                                <li><b>خلفية_زرقاء (bgBlue)</b></li>
                                <li><b>خلفية_أرجوانية (bgMagenta)</b></li>
                                <li><b>خلفية_سماوية (bgCyan)</b></li>
                                <li><b>خلفية_بيضاء (bgWhite)</b></li>
                            </ul>
                        </div>
                    </div>

                    <h4 class="foldable" id="System">الوحدة: نـظام (System)</h4>
                    <div>
                        تحتوي وحدة `نـظام` على التعريفات التالية:
                        <ul class="subsections">
                            <li>
                                <b>نم (sleep)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[usleep] دالة نم (ط: طـبيعي)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[usleep] func sleep (w: Word);
</pre>
 مطابقة لدالة usleep من POSIX.
                            </li>
                            <li>
                                <b>اضبط_متغير_محيطي (setEnv)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[setenv]
دالة اضبط_متغير_محيطي (
    اسم: مؤشر[مصفوفة[مـحرف]]، قيمة: مؤشر[مصفوفة[مـحرف]]، استبدال: صـحيح
): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[setenv]
func setEnv (
    name: ptr[array[Char]], value: ptr[array[Char]], overwrite: Int
): Int;
</pre>
 مطابقة لدالة setenv من POSIX.
                            </li>
                            <li>
                                <b>هات_متغير_محيطي (getEnv)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[getenv]
دالة هات_متغير_محيطي (اسم: مؤشر[مصفوفة[مـحرف]]): مؤشر[مصفوفة[مـحرف]]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[getenv]
func getEnv (name: ptr[array[Char]]): ptr[array[Char]];
</pre>
 مطابقة لدالة getenv من POSIX.
                            </li>
                            <li>
                                <b>شغل (exec)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[system] دالة شغل (أمر: مؤشر[مصفوفة[مـحرف]]): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[system] func exec (cmd: ptr[array[Char]]): Int;
</pre>
 مطابقة لدالة system من POSIX.
                            </li>
                            <li>
                                <b>اخرج (exit)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[exit] دالة اخرج (رمز_الخروج: صـحيح)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[exit] func exit (status: Int);
</pre>
 مطابقة لدالة exit من POSIX.
                            </li>
                        </ul>
                    </div>

                    <h4 class="foldable" id="Fs">الوحدة: نـم (Fs)</h4>
                    <div>
                        تحتوي وحدة `نـم` على الدالات والعناصر التالية للتعامل مع نظام الملفات:
                        <ul class="subsections">
                            <li>
                                <b>قـيد_مجلد (DirEnt)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
صنف قـيد_مجلد {
  عرف نوع: صـحيح[8]؛
  عرف اسم: مصفوفة[مـحرف، 256]؛
}
</pre>
<pre class="code" dir=ltr>
class DirEnt {
  def dType: Int[8];
  def dName: array[Char, FILENAME_LENGTH];
};
</pre> سجل معلومات عنصر من عناصر المجلد.
                            </li>
                            <br>

                            <li>
                                <b>اسـماء_ملفات (FileNames؛)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
صنف اسـماء_ملفات {
  عرف عدد: صـحيح؛
  عرف اسماء: مصفوفة[مصفوفة[مـحرف، 256]]؛
}
</pre>
<pre class="code" dir=ltr>
class FileNames {
  def count: Int;
  def names: array[array[Char, FILENAME_LENGTH]];
}
</pre> قائمة بأسماء ملفات.
                            </li>
                            <br>

                            <li>
                                <b>انـتقال (Seek)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
عرف انـتقال: {
  عرف _بداية_: لقب 0؛
  عرف _حالي_: لقب 1؛
  عرف _نهاية_: لقب 2؛
}؛
</pre>
<pre class="code" dir=ltr>
def Seek: {
  def SET: 0;
  def CUR: 1;
  def END: 2;
};
</pre> ثوابت التعامل مع دالة الانتقال.
                            </li>
                            <br>

                            <li>
                                <b>يوجد (exists)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة يوجد (اسم_الملف: مؤشر[مصفوفة[مـحرف]]): ثـنائي؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func exists (filename: ptr[array[Char]]): Bool;
</pre>
 تفحص وجود ملف أو مجلد معين.
                            </li>
                            <li>
                                <b>اعد_التسمية (rename)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[rename]
دالة أعد_التسمية (
    الاسم_القديم: مؤشر[مصفوفة[مـحرف]]، الاسم_الجديد: مؤشر[مصفوفة[مـحرف]]
): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[rename]
func rename (oldName: ptr[array[Char]], newName: ptr[array[Char]]): Int;
</pre>
 تعيد تسمية ملف أو مجلد.
                            </li>
                            <li>
                                <b>امح (remove)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[remove] دالة امح (اسم_الملف: مؤشر[مصفوفة[مـحرف]]): ثـنائي؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[remove] func remove (filename: ptr[array[Char]]): Bool;
</pre>
 تزيل ملفًا أو مجلدًا.
                            </li>
                            <li>
                                <b>افتح_ملف (openFile)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[fopen]
دالة افتح_ملف (
    اسم_الملف: مؤشر[مصفوفة[مـحرف]]، الوضع: مؤشر[مصفوفة[مـحرف]]
): مؤشر[مـلف]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[fopen]
func openFile (filename: ptr[array[Char]], mode: ptr[array[Char]]): ptr[File];
</pre>
 مطابقة لدالة fopen من POSIX.
                            </li>
                            <li>
                                <b>اغلق_ملف (closeFile)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[fclose] دالة اغلق_ملف (ملف: مؤشر[مـلف]): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[fclose] func closeFile(f: ptr[File]): Int;
</pre>
 مطابقة لدالة fclose من POSIX.
                            </li>
                            <li>
                                <b>اطبع (print)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[frpintf]
دالة اطبع (ملف: مؤشر[مـلف]، نسق: مؤشر[مصفوفة[مـحرف]]، ...أيما): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[fprintf]
func print (f: ptr[File], fmt: ptr[array[Char]], ...any): Int;
</pre>
 مطابقة لدالة fprintf من POSIX.
                            </li>
                            <li>
                                <b>امسح (scan)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[fscanf]
دالة امسح (ملف: مؤشر[مـلف]، نسق: مؤشر[مصفوفة[مـحرف]]، ...أيما): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[scanf]
func scan (f: ptr[File], fmt: ptr[array[Char]], ...any): Int;
</pre>
 مطابقة لدالة fscanf من POSIX.
                            </li>
                            <li>
                                <b>اكتب (write)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[fwrite]
دالة اكتب (
    محتوى: مؤشر، حجم: صـحيح_متكيف، عدد: صـحيح_متكيف، ملف: مؤشر[مـلف]
): صـحيح_متكيف؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[fwrite]
func write (
    content: ptr, size: ArchInt, count: ArchInt, f: ptr[File]
): ArchInt;
</pre>
 مطابقة لدالة fwrite من POSIX.
                            </li>
                            <li>
                                <b>اقرأ (read)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[fread]
دالة اقرأ (
    محتوى: مؤشر، حجم: صـحيح_متكيف، عدد: صـحيح_متكيف، ملف: مؤشر[مـلف]
): صـحيح_متكيف؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[fread]
func read (
    content: ptr, size: ArchInt, count: ArchInt, f: ptr[File]
): ArchInt;
</pre>
 مطابقة لدالة fread من POSIX.
                            </li>
                            <li>
                                <b>اطلق (flush)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[fflush] دالة اطلق (ملف: مؤشر[مـلف]): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[fflush] func flush (f: ptr[File]): Int;
</pre>
 مطابقة لدالة fflush من POSIX.
                            </li>
                            <li>
                                <b>هات_الموقع (tell)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[ftell] دالة هات_الموقع (ملف: مؤشر[مـلف]): صـحيح_متكيف؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[ftell] func tell (f: ptr[File]): ArchInt;
</pre>
 مطابقة لدالة tell من POSIX.
                            </li>
                            <li>
                                <b>انتقل (seek)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[fseek]
دالة انتقل (ملف: مؤشر[مـلف]، إزاحة: صـحيح_متكيف، انتقال: صـحيح): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[fseek]
func seek (f: ptr[File], offset: ArchInt, seek: Int): Int;
</pre>
 مطابقة لدالة tell من POSIX.
                            </li>
                            <li>
                                <b>أنشئ_ملف (createFile)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة أنشئ_ملف (
    اسم_الملف: مؤشر[مصفوفة[مـحرف]]، محتوى: مؤشر، حجم_المحتوى: صـحيح_متكيف
): ثـنائي؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func createFile (
    filename: ptr[array[Char]], content: ptr, contentSize: ArchInt
): Bool;
</pre>
 تنشئ ملفًا وتخزن فيه المحتوى المعطى.
                            </li>
                            <li>
                                <b>اقرأ_ملف (readFile)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة اقرأ_ملف (
    اسم_الملف: مؤشر[مصفوفة[مـحرف]]، ناتج: مؤشر[مؤشر]، حجم: مؤشر[صـحيح_متكيف]
): ثـنائي؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func readFile (
    filename: ptr[array[Char]], result: ptr[ptr], size: ptr[ArchInt]
): Bool;
</pre>
تقرأ المحتوى الكامل لملف وترجعه.
                            </li>
                            <li>
                                <b>انشئ_مجلد (makeDir)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة أنشئ_مجلد (اسم_المجلد: مؤشر[مصفوفة[مـحرف]]، الوضع: صـحيح): ثـنائي؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func makeDir (folderName: ptr[array[Char]], mode: Int): Bool;
</pre>
 تنشئ مجلدًا جديدًا.
                            </li>
                            <li>
                                <b>افتح_مجلد (openDir)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[opendir] دالة (اسم_المجلد: مؤشر[مصفوفة[مـحرف]]): مؤشر[مـجلد]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[opendir] func (folderName: ptr[array[Char]]): ptr[Dir];
</pre>
 مطابقة لدالة opendir من POSIX.
                            </li>
                            <li>
                                <b>اغلق_مجلد (closeDir)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[closedir] دالة (مجلد: مؤشر[مـجلد]): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[closedir] func (folder: ptr[Dir]): Int;
</pre>
 طابقة لدالة closedir من POSIX.
                            </li>
                            <li>
                                <b>صفر_مؤشر_مجلد (rewindDir)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[rewindDir] دالة صفر_مؤشر_مجلد (مجلد: مؤشر[مـجلد])؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[rewindDir] func rewindDir (dir: ptr[Dir]);
</pre>
 مطابقة لدالة rewinddir من POSIX.
                            </li>
                            <li>
                                <b>اقرأ_مجلد (readDir)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
1. @تصدير[readdir] دالة اقرأ_مجلد (مجلد: مؤشر[مـجلد]): مؤشر[قـيد_مجلد]؛
2. دالة اقرأ_مجلد (اسم_المجلد: مؤشر[مصفوفة[مـحرف]]): مؤشر[أسـماء_ملفات]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
1. @expname[readdir] func readDir (dir: ptr[Dir]): ptr[DirEnt];
2. func readDir (name: ptr[array[Char]]): ptr[FileNames];
</pre>
 1: مطابقة لدالة readdir من POSIX.<br> 2: ترجع قائمة بأسماء الملفات في مجلد معين.
                            </li>
                        </ul>
                    </div>

                    <h4 class="foldable" id="Regex">الوحدة: نـمط (Regex)</h4>
                    <div>
                        تحتوي وحدة `نـمط` على دالات للتعامل مع التعابير النمطية.
                        <ul class="subsections">
                            <li>
                                <b>طابق (match)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة طابق (
    نمط: مؤشر[مصفوفة[مـحرف]]، محارف: مؤشر[مصفوفة[مـحرف]]، خيارات: صـحيح
): مـصفوفة[نـص]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func match (
    pattern: ptr[array[Char]], str: ptr[array[Char]], flags: Int
): Array[String];
</pre>
 تطبق النمط المعطى على سلسلة المحارف المعطاة وترجع مصفوفة من النصوص. في حالة وجود تطابق تحمل المصفوفة التطابق الكامل للنمط في أول عنصر من المصفوفة بينما تحمل العناصر التالية التطابقات الجزئية المحددة ضمن النمط بالأقواس.
                                في حالة عدم وجود تطابق تكون النتيجة مصفوفة فارغة.
                            </li>

                            <li>
                                <b>مـطابق (Matcher)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
صـنف مـطابق (
    عملية هذا~هيئ(نمط: مؤشر[مصفوفة[مـحرف]])؛
    عملية هذا~هيئ(نمط: مؤشر[مصفوفة[مـحرف]]، خيارات: صـحيح)؛
    عملية هذا.هيئ(نمط: مؤشر[مصفوفة[مـحرف]])؛
    عملية هذا.هيئ(نمط: مؤشر[مصفوفة[مـحرف]]، خيارات: صـحيح)؛
    عملية هذا.حرر()؛
    عملية هذا.طابق(محارف: مؤشر[مصفوفة[مـحرف]]): مـصفوفة[نـص]؛
}
</pre>
<pre class="code" dir=ltr style="text-align:left;">
class Matcher {
    handler this~init(pattern: ptr[array[Char]]);
    handler this~init(pattern: ptr[array[Char]], flags: Int);
    handler this.initialize(pattern: ptr[array[Char]]);
    handler this.initialize(pattern: ptr[array[Char]], flags: Int);
    handler this.release();
    handler this.match (str: ptr[array[Char]]): Array[String];
}
</pre>
صنف يمكن المستخدم من تهيئة تعبير نمطي ثم استخدامه في عمليات بحث متعددة. الوظيفة `طابق` (match) تطبق التعبير النمطي على سلسلة المحارف المعطاة وترجع مصفوفة من النصوص. في حالة وجود تطابق تحمل المصفوفة التطابق الكامل للنمط في أول عنصر من المصفوفة بينما تحمل العناصر التالية التطابقات الجزئية المحددة ضمن النمط بالأقواس. في حالة عدم وجود تطابق تكون النتيجة مصفوفة فارغة.
                            </li>
                        </ul>
                    </div>

                    <h4 class="foldable" id="Time">الوحدة: وقـت (Time)</h4>
                    <div>
                        تحتوي وحدة `وقـت` على التعريفات التالية:
                        <ul class="subsections">
                            <li>
                                <b>وقـت (Time)</b><br/>
                                <pre class="code" dir=rtl style="text-align:right;">
صنف وقـت_مفصل {
  عرف ثانية: صـحيح؛
  عرف دقيقة: صـحيح؛
  عرف ساعة: صـحيح؛
  عرف يوم: صـحيح؛
  عرف شهر: صـحيح؛
  عرف سنة: صـحيح؛
  عرف يوم_اسبوعي: صـحيح؛
  عرف يوم_سنوي: صـحيح؛
  عرف إزاحة_زمنية: صـحيح؛
  عرف منطقة_زمنية: صـحيح؛
}؛
</pre>
                                <pre class="code" dir=ltr>
class DetailedTime {
  def second: Int;
  def minute: Int;
  def hour: Int;
  def day: Int;
  def month: Int;
  def year: Int;
  def weekDay: Int;
  def yearDay: Int;
  def daylightSaving: Int;
  def timezoneOffset: Int[64];
  def timezone: ptr[array[Char]];
};
</pre> سجل لحمل معلومات الوقت والتاريخ.
                            </li>
                            <li>
                                <b>هات_وقـت_مفصل (getDetailedTime)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
1. @تصدير[localtime] دالة هات_وقـت_مفصل (
     خز: مؤشر[طـبيعي[64]]
   ): مؤشر[وقـت_مفصل]؛
2. @تصدير[localtime_r] دالة هات_وقت_مفصل (
     خز: مؤشر[طـبيعي[64]]، مؤشر[وقـت_مفصل]
   ): مؤشر[وقـت_مفصل]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
1. @expname[localtime] func getDetailedTime (
     ts: ptr[Word[64]]
   ): ptr[DetailedTime];
2. @expname[localtime_r] func getDetailedTime (
     ts: ptr[Word[64]], ptr[DetailedTime]
   ): ptr[DetailedTime];
</pre>
 1. مطابقة لدالة localtime من POSIX. <br> 2. مطابقة لدالة localtime_r من POSIX.
                            </li>
                            <li>
                                <b>هات_الختم_الزمني (getTimestamp)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[time] دالة هات_الختم_الزمني (نتيجة: مؤشر[طـبيعي[64]]): مؤشر[طـبيعي[64]]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[time] func getTimestamp (result: ptr[Word[64]]): ptr[Word[64]];
</pre>
 مطابقة لدالة time من POSIX.
                            </li>
                            <li>
                                <b>هات_الساعة (getClock)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[clock] دالة هات_الساعة (): صـحيح[64]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[clock] func getClock (): Int[64];
</pre>
 مطابقة لدالة clock من POSIX.
                            </li>
                            <li>
                                <b>إلى_نص (toString)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
@تصدير[clock] دالة إلى_نص (خز: مؤشر[طـبيعي[64]]): مؤشر[مصفوفة[مـحرف]]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
@expname[clock] func toString (ts: ptr[Word[64]]): ptr[array[Char]];
</pre>
 مطابقة لدالة ctime من POSIX.
                            </li>
                        </ul>
                    </div>

                    <h4 class="foldable" id="Srl-other">تعريفات أخرى</h4>
                    <div>
                      <ul>
                        <li><b>مثل_سند (castRef)</b><br>
                          ماكرو لتسهيل تمثيل سند كسند لصنف مختلف. يستلم معطيين، الأول هو المتغير المراد تمثيله، والثاني هو الصنف المراد التمثيل إلى سنده.
                        </li>
                        <br>

                        <li><b>سند_لعدم (nullRef)</b><br>
                          ماكرو يعطيك سندًا قيمة مؤشره 0. يأخذ معطىً واحدًا هو الصنف المراد الحصول على سنده.
                        </li>
                        <br>

                        <li><b>هات_المسار_الكامل_لهذه_الشفرة (getThisSourceFullPath)</b><br>
                          ماكرو يعطيك سلسلة محارف حرفية (string literal) تحتوي على المسار الكامل لملف الشفرة
                          المصدرية الحالي. لا يأخذ هذا الماكرو أي معطيات.
                        </li>
                        <br>

                        <li><b>هات_مجلد_هذه_الشفرة (getThisSourceDirectory)</b><br>
                          ماكرو يعطيك سلسلة محارف حرفية (string literal) تحتوي على المسار الكامل للمجلد الذي
                          يحتوي ملف الشفرة المصدرية الحالي. لا يأخذ هذا الماكرو أي معطيات.
                        </li>
                      </ul>
                    </div>
                </div>

                <br>
                <h3 id="closure">دليل مكتبة `مغلفة` (closure)</h3>
                <hr>
                <div>
                  <p>مكتبة `مغلفة` توفر الدعم للدالات المُغلَّفة، وهي الدالات التي تُرفق بنسخة من البيئة التي تُغلفها، أي بنسخة من المتغيرات الخارجية التي تستخدمها الدالة.</p>
                  يمكن للدالات الضمنية الولوج إلى المتغيرات العمومية خارجها، لكن لا يمكنها الولوج إلى المتغيرات المحلية ضمن دالة خارجية تحوي الدالة الضمنية، وذلك لأن الدالة الخارجية قد ينتهي تنفيذها وتُزال متغيراتها من الذاكرة قبل استدعاء الدالة الضمنية. على سبيل المثال:
<pre class="samplecode" dir=rtl style="text-align:right;">
عرف مد: مؤشر[دالة]؛
دالة جهز_دالة {
    عرف ع: صحيح = 10؛
    مد = دالة {
        طـرفية.اطبع("%d\ج"، ع)؛ // خطأ: في الوقت الذي يُنفذ فيه هذا السطر
            // يكون ع قد أزيل من الذاكرة
    }؛
}

جهز_دالة()؛
مد()؛
</pre>
<pre class="samplecode" dir=ltr>
def pf: ptr[func];
func prepareFunc {
    def i: Int = 10;
    pf = func {
        Console.print("%d\n", i); // Error: by the time this line is executed
            // i would have been removed from memory
    };
}

prepareFunc();
pf();
</pre>
                  لتمكين الدالة من الولوج إلى متغيرات الدالة الخارجية تحتاج هذه الدالة أن تُرفق بنسخة من البيانات التي تستخدمها من البيئة الخارجية، وهذا ما توفره الدالات المُغلَّفة التي توفرها مكتبة `مغلفة` (clsoure)، فهي دالات يغلفها المترجم تلقائيًا بالبيئة الخارجية، أي يُرفقها بنسخة من كل متغير خارجي مؤقت تستخدمه الدالة المغلفة. تعريف الدالة المغلفة يشبه تعريف الدالة الضمنية باستثناء استخدام الكلمة المفتاحية `مغلفة` (closure) بدل `دالة`. مثال:
<pre class="samplecode" dir=rtl style="text-align:right;">
اشمل "مغلفة"؛

عرف مغ: مغلفة ()؛
دالة جهز_مغلفة {
    عرف ع: صحيح = 10؛
    مغ = مغلفة () {
        طـرفية.اطبع("%d\ج"، ع)؛ // صحيح: سيبدل المترجم هذا الولوج تلقائيًا
            // إلى ولوج إلى نسخة من ع.
    }؛
}

جهز_مغلفة()؛
مغ()؛
</pre>
<pre class="samplecode" dir=ltr>
import "closure";

def pc: closure ();
func prepareClosure {
    def i: Int = 10;
    pf = closure () {
        Console.print("%d\n", i); // Correct: access to i will be replaced
            // by the compiler to an access to a copy of i
    };
}

prepareClosure();
pc();
</pre>
                  من الملاحظ أعلاه أن كتابة مغلفة دون متن يجعلها تعريفًا لمغلفة، ومن المهم معرفته أن قيد المغلفة يحتوي على مؤشر إلى دالة، بالإضافة إلى سند مشترك إلى قيد البيانات. تبقى المسؤولية على المبرمج لمراعاة عدم الولوج إلى سندات مشتركة تؤدي إلى حلقة مغلقة من السندات المشتركة، وبالتالي تسريب في الذاكرة. على سبيل المثال، إن ولجت من المغلفة إلى سند مشترك وكان هذا السند المشترك يؤشر للقيد الذي يحتوي المغلفة فسينتهي بك الأمر إلى تسرب في الذاكرة (القيد يمسك بالمغلفة والتي بدورها تمسك بالقيد فيبقى كلاهما في الذاكرة دائمًا). في مثل هذه الحالات كل ما تحتاج فعله أن تجعل المغلفة تمسك بسند غير مشترك لتجنب تسريب الذاكرة. مثال:
<pre class="samplecode" dir=rtl style="text-align:right;">
اشمل "مغلفة"؛

صنف قـيد {
    عرف مغ: مغلفة ()؛
    عرف ص: صحيح؛
}

عرف ق1: سـندنا[قـيد]؛
ق1.أنشئ()؛
ق1.ص = 10؛
ق1.مغ = مغلفة () {
    طـرفية.اطبع("%d\ج"، ق1.ص)؛
}؛
ق1.حرر()؛ // لن يُحرر هنا ق1 ولا المغلفة التي يملكها.

عرف ق2: سـندنا[قـيد]؛
ق2.أنشئ()؛
ق2.ص = 10؛
عرف ق22: سـندهم[قـيد] = ق2؛
ق2.مغ = مغلفة () {
    طـرفية.اطبع("%d\ج"، ق22.ص)؛
}}
ق2.حرر()؛ // هنا سيحرر ق2 مع المغلفة التي يملكها.
</pre>
<pre class="samplecode" dir=ltr>
import "closure";

class Record {
    def c: closure ();
    def i: Int;
}

def r1: SrdRef[Record];
r1.construct();
r1.i = 10;
r1.c = closure() {
    Console.print("%d\n", r1.i);
};
r1.release(); // r1 will not be released and neither will the closure it owns.

def r2: SrdRef[Record];
r2.construct();
r2.i = 10;
def r22: WkRef[Record] = r2;
r2.c = closure() {
    Console.print("%d\n", r22.i);
};
r2.release(); // r2 will be released along with the closure it owns.
</pre>
                  يمكن للمغلفة أن تستلم قيمًا وترجع قيمًا كما هو الحال مع الدالات:
<pre class="samplecode" dir=rtl style="text-align:right;">
اشمل "مغلفة"؛

عرف مغ: مغلفة (عائم): صحيح؛
دالة جهز_مغلفة {
    عرف ع: صحيح = 10؛
    مغ = مغلفة (ن: عائم): صحيح {
        أرجع ع * ن؛
    }؛
}

جهز_مغلفة()؛
طـرفية.اطبع("%d\ج"، مغ(3.5))؛ // سيطبع 35
</pre>
<pre class="samplecode" dir=ltr>
import "closure";

def pc: closure (Float): Int;
func prepareClosure {
    def i: Int = 10;
    pf = closure (j: Float): Int {
        return i * j;
    };
}

prepareClosure();
Console.print("%d\n", pc(3.5)); // Prints 35
</pre>
                    <h4 id="Build-Exe">أسلوب التقاط البيانات المحيطة</h4>
                    <div>
                      يمكنك تحديد الأسلوب الذي تُلتقط فيه البيانات من محيط الدالة المغلفة، ويمكنك تحديد ذلك لكل متغير على حدة. على سبيل المثال إذا أردت قراءة قيمة من محيد الدالة لكنك لا تحتاج لتغييرها داخل المغلفة فقد يكفيك التقاط نسخة من ذلك المتغير، بينما إذا أردت تغيير قيمة المتغير داخل الدالة المغلفة فستحتاج لالتقاط سند إلى المتغير بدلاً من ذلك. للتحكم بأسلوب التقاط البيانات نتبع الصيغة التالية في تعريف المغلفة:
<pre class="code" dir=rtl style="text-align:right;">
مغلفة (/*تعريفات_اسلوب_الالتقاط*/)&amp;(/*تعريفات_المدخلات*/): /*صنف_الإرجاع*/ {
  // متن المغلفة
}
</pre>
<pre class="code" dir=ltr style="text-align:left;">
closure (/*capture_mode_defs*/)&(/*args_defs*/): /*ret_type*/ {
  // closure body
}
</pre>
                      في المثال التالي نحدد أسلوب الالتقاط للمتغير `ن` (n) بـ `كسند` (by_ref) وذلك يخبر يجعل المغلفة تحتفظ بسند للمتغير بدل الاحتفاظ بنسخة، وبالتالي فإن تغير قيمة المتغير داخل المغلفة سيؤدي لتغيير المنغير الأصلي خارج المغلفة.
<pre class="code" dir=rtl style="text-align:right;">
دالة اختبر_التقط_كسند (ن: صحيح) {
    عرف م: مغلفة (ع: صحيح): صحيح؛
    م = مغلفة (ن: كسند)&(ع: صحيح): صحيح {
        أرجع ع * ن++؛
    }
    اطبع("ن قبل استدعاء المغلفة: %d\ج"، ن)؛
    اطبع("نتيجة المغلفة: %d\ج"، م(3))؛
    اطبع("ن بعد استدعاء المغلفة: %d\ج"، ن)؛
}
اختبر_التقط_كسند(5)؛
/*
النتيجة:
ن قبل استدعاء المغلفة: 5
نتيجة المغلفة: 15
ن بعد استدعاء المغلفة: 6
*/
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func testCaptureByRef (n: Int) {
    def c: closure (i: Int): Int;
    c = closure (n: by_ref)&(i: Int): Int {
        return i * n++;
    };
    print("n before calling c: %d\n", n);
    print("closure result: %d\n", c(3));
    print("n after calling c: %d\n", n);
}
testCaptureByRef(5);
/*
output:
n before calling c: 5
closure result: 15
n after calling c: 6
*/
</pre>
                      <p>في هذا المثال لو غيرنا أسلوب التقاط ن من `كسند` إلى `كقيمة` لكانت القيمة المطبوعة بعد استعداء المغلفة 5 بدلاً من 6.</p>
                      تتوفر الأنماط التالية لالتقاط البيانات:
                      <ul>
                        <li><b>كسند (by_ref)</b>: تلتقط المغلفة سندًا على المتغير. إذا كان المتغير سندًا فإن المغلفة ستلتقط ذلك السند وليس سندا إلى السند.</b></li>
                        <li><b>كقيمة (by_val)</b>: تلتقط المغلفة قيمة المتغير. إذا كان المتغير المذكور سندا فإن الدالة ستلتقط القيمة التي يشير إليها السند وليس السند نفسه.</b></li>
                        <li><b>مطابق (identical)</b>: تلتقط المغلفة المتغير حرفيًا، فإذا كان المتغير سندا فتلتقط ذلك السند وإذا كان قيمة فتلتقط تلك القيمة..</b></li>
                        <li><b>تلقائي</b>: إذا لم تحدد نمط الالتقاط يدويا فإن النمط المعتمد هو التلقائي وفي هذا النمط يحدد المترجم أسلوب الالتقاط اعتمادًا على صنف المتغير، فإن كان الصنف من أصناف المستخدم وليس صنف `سـندنا` (SrdRef) فيستخدم الأسلوب `مطابق` وإلا (أي إذا كان `سـندنا` أو صنفًا أساسيًا) فيستخدم الأسلوب `كقيمة`.</li>
                      </ul>
                      
                      يمكن التحقق فيما إن كان مؤشر المغلفة صفرا أم لا باستخدام الدالة `أهو_لعدم` (isNull).
<pre class="code" dir=rtl style="text-align:right;">
    عرف م: مغلفة (ع: صحيح): صحيح؛
    م.أهو_لعدم() // يرجع 1
    م = مغلفة (ع: صحيح): صحيح { أرجع 0؛ }؛
    م.أهو_لعدم() // يرجع 0
</pre>
<pre class="code" dir=ltr style="text-align:left;">
    def c: closure (i: Int): Int;
    c.isNull() // returns true
    c = closure (i: Int): Int { return 0 };
    c.isNull() // returns false
</pre>
                    </div>
                </div>

                <br>
                <h3 id="Build">دليل مكتبة `بـناء` (Build)</h3>
                <hr>
                <div>
                    مكتبة `بـناء` تمكن المستخدم من بناء ملف تنفيذي لبرنامجه. تحتوي المكتبة على العناصر التالية:
                    <h4 id="Build-Exe">الصنف: تـنفيذي (Exe)</h4>
                    <div>
                        يمكّن المستخدم من بناء ملف تنفيذي لبرنامجه يعمل على نظام التشغيل الحالي. يحتاج هذا الصنف لتوفر أدوات gcc على نظام التشغيل.
                        بناء ملف تنفيذي يتم بالخطوات التالي:
                        <ul>
                          <li>
                            إنشاء كائن من صنف `تـنفيذي` (Exe) وإعطائه مؤشرًا على
                            عنصر الشفرة المصدرية المراد تحويله إلى ملف تنفيذي بالإضافة إلى اسم الملف التنفيذي المراد بناؤه.
                            يمكن الحصول على مؤشر العنصر باستخدام الأمر `~شبم` (~ast).
                          </li>
                          <li>
                            إضافة أي اعتماديات باستخدام الدالة `تـنفيذي.اضف_اعتمادية` (addDependency) وإعطائها مؤشرا على
                            الوحدة التي يعتمد عليها البرنامج. لاحظ أن إضافة الاعتمادية مطلوب فقط في حالة احتياج الوحدة إلى مكتبات
                            خارجية (تحدد الوحدة ما تحتاجه من مكتبات خارجية باستخدام المبدل `@اعتماديات` (@deps))، أما لو لم
                            تحتج الوحدة لمكتبات خارجية فلا حاجة لإضافتها كإعتمادية بشكل يدوي وإنما يفعل المترجم ذلك تلقائيا.<br>
                            يمكن أيضًا إعطاء الدالة إسم ملف الاعتمادية بدل إعطائها مؤشرا على وحدة، ويمكن في حالة استخدام أسماء
                            ملفات للاعتماديات استخدام الدالة `أضف_اعتماديات` (addDependencies) لتمرير عدة اعتماديات مرة واحدة.
                          </li>
                          <li>
                            إضافة أي خيارات إضافية يحتاجها المُجمِّع (linker) باستخدام الدالة `أضف_خيار` (addFlag) أو الدالة `أضف_خيارات` (addFlags).
                          </li>
                          <li>
                            إنشاء الملف التنفيذي باستدعاء الدالة `تـنفيذي.أنتج` (generate).
                          </li>
                        </ul>
                        المثال التالي يوضح هذه الخطوات:
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرف تنفيذي: مؤشر[بـناء.تـنفيذي](الـبسملة.ابدأ~شبم، "البسملة")؛
  تنفيذي.أضف_اعتمادية(جـتك~شبم)؛ // أو: تنفيذي.أضف_اعتمادية(نـص("libgtk..."))؛
  تنفيذي.أضف_اعتماديات(مـصفوفة[نـص]({ نـص("libcurl.so")، ... }))؛
  تنفيذي.أضف_خيار("-Wl,-rpath,@executable_path")؛
  إذا تنفيذي.أنتج() {
    مـتم.طـرفية.اطبع("اكتمل البناء.\ج")؛
  } وإلا {
    مـتم.طـرفية.اطبع("فشل البناء.\ج")؛
  }؛
</pre>
<pre class="samplecode" dir=ltr>
  def exe: ptr[Build.Exe](WidgetGuide.start~ast, "hello_world");
  exe.addDependency(Gtk~ast); // or exe.addDependency(String("libgtk...."));
  exe.addDependencies(Array[String]({ String("libcurl.so"), ... }));
  exe.addFlag("-Wl,-rpath,@executable_path");
  if exe.generate() {
    Srl.Console.print("Build complete.\n");
  } else {
    Srl.Console.print("Build failed.\n");
  };
</pre>
                          الشفرة التالية توضح كيف يمكن لمطوري المكتبات إضافة معلومات الاعتماديات الخارجية إلى وحداتهم:
<pre class="samplecode" dir=rtl style="text-align:right;">
  @اعتماديات["libmyextlib.so"] وحدة مـكتبتي {
    ...
  }؛
</pre>
<pre class="samplecode" dir=ltr>
  @deps["libmyextlib.so"] module MyLib {
    ...
  };
</pre>
                      بدون إضافة المبدل `@اعتماديات` فإن الدالة `أضف_اعتمادية` لا تفعل شيئا.
                    </div>

                    <h4 id="Build-Wasm">الصنف: ويـب_أسمبلي (Wasm)</h4>
                    <div>
                      هذا الصنف مشابه لصنف `تـنفيذي` ويستخدم بنفس الطريقة لكنه يولد شفرة ويب أسيمبلي بدل شفرة تستهدف
                      نظام التشغيل ومعمارية الجهاز الحالي. يحتاج هذا الصنف لوجود أداة wasm-ld على نظام التشغيل. مثال:
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرف ويب_أسمبلي: مؤشر[بـناء.ويـب_أسمبلي](الـبسملة.ابدأ~شبم، "البسملة")؛
  ويب_أسمبلي.أضف_اعتمادية(نـص("stdlib.wasm"))؛
  ويب_أسمبلي.أضف_خيارات({ نـص("--export=malloc"), نـص("--export=realloc") });
  إذا ويب_أسمبلي.أنتج() {
    مـتم.طـرفية.اطبع("اكتمل البناء.\ج")؛
  } وإلا {
    مـتم.طـرفية.اطبع("فشل البناء.\ج")؛
  }؛
</pre>
<pre class="samplecode" dir=ltr>
  def wasm: ptr[Build.Wasm](HelloWorld.start~ast, "hello_world");
  wasm.addDependency(String("stdlib.wasm"));
  wasm.addFlags({ String("--export=malloc"), String("--export=realloc") });
  if wasm.generate() {
    Srl.Console.print("Build complete.\n");
  } else {
    Srl.Console.print("Build failed.\n");
  };
</pre>
                    </div>

                    <h4 id="Build-genExecutable">الدالة: أنشئ_تنفيذي (genExeceutable)</h4>
                    <div>
                      دالة مساعدة لإنشاء ملف تنفيذي في خطوة واحدة. تنفع هذه الدالة فقط في حالة عدم احتياج عملية البناء لأي اعتماديات
                      أو خيارات إضافية. هذه الدالة مجرد وسيط للصنف `تـنفيذي` (Exe)، فهي داخليا تستخدم الصنف `تـنفيذي` لإنجاز العمل.
<pre class="samplecode" dir=rtl style="text-align:right;">
  بـناء.أنشئ_تنفيذي(ابدأ~شبم، "بسملة")؛
</pre>
<pre class="samplecode" dir=ltr>
  Build.genExecutable(start~ast, "hello_world");
</pre>
                    </div>

                    <h4 id="Build-genWasm">الدالة: أنشئ_ويب_أسمبلي (genWasm)</h4>
                    <div>
                      دالة مساعدة لإنشاء ملف ويب أسمبلي في خطوة واحدة. تنفع هذه الدالة فقط في حالة عدم احتياج عملية البناء لأي اعتماديات
                      أو خيارات إضافية. هذه الدالة مجرد وسيط للصنف `ويـب_أسمبلي` (Wasm)، فهي داخليا تستخدم الصنف `ويـب_أسمبلي` لإنجاز العمل.
<pre class="samplecode" dir=rtl style="text-align:right;">
  بـناء.أنشئ_ويب_أسمبلي(ابدأ~شبم، "بسملة")؛
</pre>
<pre class="samplecode" dir=ltr>
  Build.genWasm(start~ast, "hello_world");
</pre>
                    </div>
                </div>

                <br>
                <h3 id="Zip">دليل مكتبة `ضـغط` (Zip)</h3>
                <hr>
                <div>
                    تحتوي وحدة `ضـغط` على الدالات التالية:
                    <ul class="subsections">
                        <li>
                            <b>استخرج_من_ملف (extractFromFile)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة استخرج_من_ملف (
  اسم_الملف: مؤشر[مصفوفة[مـحرف]]، اسم_المجلد: مؤشر[مصفوفة[مـحرف]]،
  مستلم_الاشعارات: مؤشر[دالة (مؤشر[مصفوفة[مـحرف]]، مؤشر) => صـحيح]، معطيات: مؤشر
) => صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func extractFromFile (
    filename: ptr[array[Char]], folderName: ptr[array[Char]],
    callback: ptr[func (ptr[array[Char]], ptr): Int], arguments: ptr
): Int;
</pre>
 تستخرج ملفًا مضغوطا إلى المجلد المحدد.
                        </li>
                        <li>
                            <b>اضغط_إلى_ملف (compressToFile)</b><br/>
<pre class="code" dir=rtl style="text-align:right;">
دالة اضغط_إلى_ملف (
  اسم_المف: مؤشر[مصفوفة[مـحرف]]، ملفات: مؤشر[مصفوفة[مؤشر[مصفوفة[مـحرف]]]]، عدد_الملفات: صـحيح،
  نوع_الاستخراج: مؤشر[مصفوفة[مـحرف]]
) => صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func compressToFile (
    filename: ptr[array[Char]], files: ptr[array[ptr[array[Char]]]], fileCount: Int,
    extractType: ptr[array[Char]]
): Int;
</pre>
 تنشئ ملفًا مضغوطا يحتوي على الملفات المعطاة.
                        </li>
                    </ul>
                </div>

                <br>
                <h3 id="Apm">دليل مدير الحزم</h3>
                <hr>
                <div>
                    مدير حزم الأسس (محا أو apm) ينزل الحزم مباشرة من موقع GitHub ويمكن استخدامه عبر سطر الأوامر أو من داخل البرنامج مباشرة.<br> للحصول على تعليمات استخدام مدير الحزم من سطر الأوامر اكتب الأمر التالي:
                    <pre class="code" dir=rtl style="text-align:right;">
$ محا مساعدة
</pre>
                    <pre class="code" dir=ltr>
$ apm help
</pre> أما استخدام مدير الحزم من داخل البرنامج فيتم باستخدام دالة `اشمل_ملف` (importFile).
                    <pre class="code" dir=rtl style="text-align:right;">
اشمل "مـحا.أسس"؛
مـحا.اشمل_ملف("&lt;الناشر&gt;/&lt;اسم الحزمة&gt;" [، "&lt;اسم الملف&gt;"])؛
مـحا.اشمل_ملف("&lt;الناشر&gt;/&lt;اسم الحزمة&gt;"، { "&lt;اسم الملف 1&gt;"، "&lt;اسم الملف 2&gt;"، ... })؛
</pre>
<pre class="code" dir=ltr>
import "Apm.alusus";
Apm.importFile("&lt;author&gt;/&lt;pkg name&gt;" [, "&lt;filename&gt;"]);
Apm.importFile("&lt;author&gt;/&lt;pkg name&gt;", { "&lt;filename1&gt;", "&lt;filename2&gt;", ... });
</pre>
 الصيغة الثانية من الدالة تمكن المستخدم من شمول عدة ملفات من الحزمة دفعة واحدة. استخدام الصيغة الثانية لشمول عدة ملفات أسرع من استدعاء الصيغة الأولى عدة مرات، لأن كل استدعاء لهذه الدالة يؤدي إلى قراءة بيانات من موقع GitHub.<br>.
 أثناء تطوير الحزم غالبا ما يحتاج المطور لتجربة الحزمة محليًا قبل دفع التعديلات إلى المستودع. يمكن للمستخدم استخدام أمر الربط لربط حزمة معينة مع مجلد محلي فيقوم عندها مدير الحزم باستخدام النسخة المحلية بدل تنزيل نسخة المستودع.
                    أمر الربط يجب أن يُنفذ داخل مجلد المشروع الذي يستخدم الحزمة ويكون بهذه الصيغة:
<pre class="samplecode" dir=ltr>
$ cd &lt;example_project_folder&gt;
$ apm link &lt;author&gt;/&lt;package_name&gt;@&lt;release&gt; &lt;path_to_local_package_copy&gt;
</pre> يمكن إزالة الرابط باستخدام الأمر `افصل` وبهذه الصيغة:
                    <pre class="samplecode" dir=ltr>
$ cd &lt;example_project_folder&gt;
$ apm unlink &lt;author&gt;/&lt;package_name&gt;@&lt;release&gt;
</pre>
                </div>

                <!-- ********************************************************************** -->
                <br>
                <h3 id="Core">دليل الوحدة `الـقلب` (Core)</h3>
                <hr>
                <div>
                  تحوي الوحدة `الـقلب` على التعريفات التي تتيح للمبرمج التعامل مع القلب بشكل مباشر داخل برنامجه أو مكتبته.
                  هذه الوحدة تحوي تعريفات لبعض الأصناف والدالات التي يستخدمها القلب أثناء معالجة الملفات المصدرية وبالتالي
                  تتيح للمبرمج التعامل المباشر مع القلب ومع البيانات التي ينشئها. ليس كل ما في الـقلب موجود ضمن تعريفات هذه
                  الوحدة، فبعض الأصناف معرفة فقط ضمن شفرة السي++ التي كُتب بها القلب وهي داخلية لا يحتاج المبرمج التعامل معها
                  من داخل شفرة الأسس.

                  <h4 id="Core-importFile">الدالة: اشمل_ملف (importFile)</h4>
                  <div>
<pre class="code" dir=rtl style="text-align:right;">
دالة اشمل_ملف (اسم_الملف: مؤشر[مصفوفة[مـحرف]])؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func importFile (filename: ptr[array[Char]]);
</pre>
                    تشمل الملف المعطى اسمه. هذه الدالة تعمل عمل الإيعاز `اشمل` (import) ولا تختلف عن ذلك الإيعاز سوى بقدرتها
                    على شمول الملفات بشكل ديناميكي، أي باستخدام اسم ملف مولّد ديناميكيًا أثناء التنفيذ.
                  </div>

                  <h4 id="Core-addLocalization">الدالة: أضف_ترجمة (addLocalization)</h4>
                  <div>
<pre class="code" dir=rtl style="text-align:right;">
دالة أضف_ترجمة (
    رمز_اللغة: مؤشر[مصفوفة[مـحرف]]،
    المفتاح: مؤشر[مصفوفة[مـحرف]]،
    القيمة: مؤشر[مصفوفة[مـحرف]]
)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
func addLocalization (
    locale: ptr[array[Char]],
    key: ptr[array[Char]],
    value: ptr[array[Char]]
);
</pre>
                    تضيف ترجمة إلى قائمة الترجمات للغة معينة. إن لم توجد مدخلة مسبقًا للمفتاح المطلوب فإن الترجمة ستضاف
                    حتى لو كانت اللغة الحالية مختلفة عن لغة الترجمة المقدمة والسبب في ذلك أن وجود النص بلغة مغايرة خير
                    من عدم وجود نص على الإطلاق. أما إن وجدت مدخلة بهذا المفتاح فإن الترجمة ستُضاف فقط إذا طابقت لغة
                    الترجمة لغة النظام الحالية.<br>
                    تستخدم هذه الدالة لإضافة نصوص لإشعارات الأخطاء المخصصة، وتكون قيمة مفتاح الترجمة مساوية لرمز الخطأ.
                  </div>

                  <h4 id="Core-typesInfo">هوية الأصناف</h4>
                  <div>
                    في الوحدة <span class="inlinecode">القـلب.أسـاسيات (Core.Basic)</span> يوجد تعريفات لتمكين الأصناف من توفير معلومات عن هوية الصنف بشكل
                    ديناميكي (run time type info). أغلب الأصناف المستخدمة في القلب ومكتبة نمط البناء المعياري تحمل معها
                    معلومات الهوية. فيما يلي التعريفات التي توفر معلومات هوية الأصناف:

                    <h5 id="Core-TiObjectFactory">الصنف: مـصنع_كائن_بهوية (TiObjectFactory)</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">الـقلب.أسـاسيات (Core.Basic)</span>.<br>
                      هذا الصنف يستخدم لتمكين إنشاء كائنات جديدة ديناميكيًا من هوية صنف معين، أي أن هوية الصنف تحوي سندًا
                      لهذا المصنع. وبالتالي إن كان عندك سند لكائن بهوية فيمكن عن طريق هوية الكائن الوصول لمصنعه وإنشاء
                      كائنات جديدة من نفس الصنف. يحتوي مـصنع_كائن_بهوية على مؤشرات الدالات التالية:
                      <ul class="subsections">
                        <li>
                          <span class="inlinecode">أنشئ_محتكر (createPlain)</span><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عرف أنشئ_محتكر: مؤشر[@مشترك @دون_ربط دالة (): سند[كـائن_بهوية]]؛
</pre>
<pre class="code" dir=ltr>
  def createPlain: ptr[@shared @no_bind function ():ref[TiObject]];
</pre>
                          تنشئ كائنًا وترجع سندا اعتياديًا له بعد تهيئته.
                        </li>
                        <li>
                          <span class="inlinecode">أنشئ_مشترك (createShared)</span><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عرف أنشئ_مشترك: مؤشر[@مشترك @دون_ربط دالة (): سـندنا[كـائن_بهوية]]؛
</pre>
<pre class="code" dir=ltr>
  def createShared؛: ptr[@shared @no_bind function ():SrdRef[TiObject]];
</pre>
                            تنشئ كائنًا وترجع سندا مشتركًا له بعد تهيئته.
                          </li>
                        <li>
                          <span class="inlinecode">هيئ (initialize)</span><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عرف هيئ: مؤشر[@مشترك @دون_ربط دالة (سند[كـائن_بهوية])]؛
</pre>
<pre class="code" dir=ltr>
  def initialize: ptr[@shared @no_bind function (ref[TiObject])];
</pre>
                          تهيئ كائنًا محجوز في الذاكرة مسبقًا.
                        </li>
                        <li>
                          <span class="inlinecode">أتلف (terminate)</span><br/>
<pre class="code" dir=rtl style="text-align:right;">
  عرف أتلف: مؤشر[@مشترك @دون_ربط دالة (سند[كـائن_بهوية])]؛
</pre>
<pre class="code" dir=ltr>
  def terminate: ptr[@shared @no_bind function (ref[TiObject])];
</pre>
                          تتلف كائنًا دون تحرير ذاكرته.
                        </li>
                      </ul>
                    </div>

                    <h5 id="Core-TypeInfo">الصنف: هـوية_صنف (TypeInfo)</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">الـقلب.أسـاسيات (Core.Basic)</span>.<br>
                      يحمل معلومات عن هوية صنف معين. تشمل هذه المعلومات اسم الصنف والوحدة التي ينتمي إليها ومصنع الكائنات
                      وغيرها، ويحوي المتغيرات التالية:
                      <ul class="subsections">
                        <li>
                          <span class="inlinecode">اسم_الصنف (typeName): نـص (String)</span><br>
                          نص يحمل اسم الصنف دون المسار الكامل.
                        </li>
                        <li>
                          <span class="inlinecode">مسار_الصنف (typeNamespace): نـص (String)</span><br>
                          نص يحمل مسار الصنف الكامل دون اسم الصنف. فإذا كان عندك صنف <span class="inlinecode">وحـدة_خارجية.وحـدة_داخلية.صـنفي</span>
                          فإن هذا المتغير سيحوي القيمة `وحـدة_خارجية.وحـدة_داخلية`.
                        </li>
                        <li>
                          <span class="inlinecode">اسم_الحزمة (packageName): نـص (String)</span><br>
                          نص يحمل اسم الحزمة التي تحوي الصنف. على سبيل المثال، كل الأصناف المعرفة داخل القلب تحمل اسم
                          الحزمة Core، بينما الأصناف المعرفة داخل مكتبة نمط البناء المعياري تحمل اسم الحزمة Spp.
                        </li>
                        <li>
                          <span class="inlinecode">الرابط (url): نـص (String)</span><br>
                          رابط الحزمة على الشبكة العنكبوتية. الأسس لا تتعامل مع الرابط بشكل مباشر وإنما تعامله فقط كمعلومة
                          للمستخدم لتمييز الصنف في حالة تشابه الأسماء.
                        </li>
                        <li>
                          <span class="inlinecode">الاسم_الفريد (uniqueName): نـص (String)</span><br>
                          سلسلة محارف تتكون من جمع المعلومات أعلاه في معرف واحد فريد.
                        </li>
                        <li>
                          <span class="inlinecode">هوية_صنف_السلف (baseTypeInfo): سند[هـوية_صنف] (ref[TypeInfo])</span><br>
                          سند لهوية سلف هذا الصنف، أي لهوية الصنف الذي أُشتُق منه هذا الصنف. تكون السند صفرًا إن لم يمكن
                          لهذا الصنف سلف.
                        </li>
                        <li>
                          <span class="inlinecode">مصنع_الكائنات (objectFactory): سند[مـصنع_كائن_بهوية] (ref[TiObjectFactory])</span><br>
                          سند للمصنع الذي يُنشئ كائنات من هذا الصنف.
                        </li>
                      </ul>
                    </div>

                    <h5 id="Core-TiObject">الصنف: كـائن_بهوية (TiObject)</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">الـقلب.أسـاسيات (Core.Basic)</span>.<br>
                      الجذر لكل الأصناف الحاملة لهوية. يوفر إمكانية الوصول إلى هوية الصنف بالإضافة إلى الوصول إلى الوسطاء
                      التي يدعمها الصنف ويوفر أيضًا إمكانية التمثيل الديناميكي (dynamic casting). يحتوي هذا الصنف على
                      العناصر التالية:
                      <ul class="subsections">
                        <li>
                          <span class="inlinecode">هات_هويتي (getMyTypeInfo)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_هويتي (): سند[هـوية_صنف]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getMyTypeInfo (): ref[TypeInfo];
</pre>
                          تعطيك سندًا لهوية هذا الكائن.
                        </li>
                        <li>
                          <span class="inlinecode">أمشتق_من (isDerivedFrom)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.أمشتق_من (سند[هـوية_صنف]): ثـنائي؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.isDerivedFrom (ref[TypeInfo]): Bool;
</pre>
                          تُعلمك إن كان الكائن من الصنف ذي الهوية المعطاة، أو من صنف مشتق من ذلك الصنف.
                        </li>
                        <li>
                          <span class="inlinecode">هات_وسيط (getInterface)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_وسيط (سند[هـوية_صنف]): سند[وسـيط_بهوية]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getInterface (ref[TypeInfo]): ref[TiInterface];
</pre>
                          تستقبل سندًا لهوية وسيط وترجع سندًا لذلك الوسيط إن وجد، وإن لم يكن ذلك الوسيط مدعوما من هذا
                          الكائن فترجع صفرًا.
                        </li>
                      </ul>
                    </div>

                    <h5 id="Core-TiInterface">الصنف: وسـيط_بهوية (TiInterface)</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">الـقلب.أسـاسيات (Core.Basic)</span>.<br>
                      الجذر لكل أصناف الوسطاء. يوفر إمكانية الوصول إلى هوية الوسيط بالإضافة للوصول إلى الكائن الذي يملك
                      الوسيط. يحتوي هذا الصنف على العناصر التالية:
                      <ul class="subsections">
                        <li>
                          <span class="inlinecode">هات_هويتي (getMyInterfaceInfo)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_هويتي (): سند[هـوية_صنف]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getMyInterfaceInfo (): ref[TypeInfo];
</pre>
                          تعطيك سندًا لهوية هذا الوسيط.
                        </li>
                        <li>
                          <span class="inlinecode">هات_الكائن (getTiObject)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_الكائن (): سند[كـائن_بهوية]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getTiObject (): ref[TiObject];
</pre>
                          تُرجع الكائن الذي يملك هذا الوسيط.
                        </li>
                      </ul>
                    </div>

                    <h5 id="Core-getInterface">الماكرو: هات_الوسيط (getInterface)</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">الـقلب.أسـاسيات (Core.Basic)</span>.<br>
                      ماكرو لتسهيل الحصول على وسيط من كائن محدد. يستخدم بهذه الطريقة:
<pre class="code" dir=rtl style="text-align:right;">
  وسيط~عطل_التتبع = هات_الوسيط[كائن، صـنف_الوسيط]
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  interface~no_deref = getInterface[obj, InterfaceType];
</pre>
                    </div>

                    <h5 id="Core-isDerivedFrom">الماكرو: أمشتق_من (isDerivedFrom)</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">الـقلب.أسـاسيات (Core.Basic)</span>.<br>
                      يفحص ما إذا كان الكائن المعطى مشتقًا من الصنف المعطى، ويستخدم كالتالي:
<pre class="code" dir=rtl style="text-align:right;">
  إذا أمشتق_من[كائن، صـنف_الكائن] { ... }
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  if isDerivedFrom[obj, ObjType] { ... }
</pre>
                    </div>

                    <h5 id="Core-defDynCastedRef">الماكرو: عرف_سندا_بتمثيل_آمن (defDynCastedRef)</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">الـقلب.أسـاسيات (Core.Basic)</span>.<br>
                      ماكرو مساعد يختصر عملية تمثيل الصنف ديناميكيًا وخزن النتيجة في متغير جديد. مثال:
<pre class="code" dir=rtl style="text-align:right;">
  دالة اختبار (كائن_جذري: سند[صـنف_الجذر]) {
    عرف_سندا_بتمثيل_آمن[كائن_فرعي، كائن_جذري، صـنف_الفرع]؛
    إذا كائن_فرعي~مؤشر != 0 كائن_فرعي.عملية(...)؛
  }
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  func test (parentObj: ref[ParentType]) {
    defDynCastedRef[childObj, parentObj, ChildType];
    if childObj~ptr != 0 childObj.someFunc(...);
  }
</pre>
                    </div>
                  </div>

                  <h4 id="Core-basicTypes">أصناف أساسية</h4>
                  <div>
                    معرفة داخل الوحدة <span class="inlinecode">الـقلب.أسـاسيات (Core.Basic)</span>.<br>
                    تتوفر مجموعة من الأصناف تقابل الأصناف الأساسية مثل الأعداد الصحيحة والنصوص، لكنها مشتقة من
                    <span class="inlinecode">كـائن_بهوية</span> وبالتالي يمكن التعرف عليها والتعامل معها بسهولة أثناء
                    التنفيذ. هذه الأصناف تعرف عمليات المساواة والتهيئة بالإضافة للعناصر التالية:
                    <ul class="subsections">
                      <li>
                        <span class="inlinecode">القيمة (value)</span><br>
                        المتغير الذي يحوي القيمة الأصلية بصنفها الأساسي.
                      </li>
                      <li>
                        <span class="inlinecode">أنشئ (create)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  دالة أنشئ (ق: الـصنف_الأساسي): سـندنا[صـنف_المعلومة]
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  func create (v: BasicType): SrdRef[ObjType]
</pre>
                        تنشئ كائنًا من هذا الصنف بالقيمة المعطاة وترجع سندًا مشتركًا للكائن.
                      </li>
                      <li>
                        <span class="inlinecode">هات_هوية_الصنف (getTypeInfo)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  دالة هات_هوية_الصنف (): سند[هـوية_صنف]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  func getTypeInfo (): ref[TypeInfo];
</pre>
                        هذه الدالة تُرجع سندًا لهوية هذا الصنف، أي لهوية الكائنات المشتقة من هذا الصنف.
                      </li>
                    </ul>
                    المثال التالي يوضح طريقة تعريف واستخدام هذه الأصناف:
<pre class="code" dir=rtl style="text-align:right;">
  عرف ص: صـحيح_بهوية(45)؛
  اطبع_صحيح(ص.القيمة)؛
  ص = 7؛

  عرف ك: سند[كـائن_بهوية](ص)؛
  إذا أمشتق_من[ك، صـحيح_بهوية] {
    عرف س: سند[صـحيح_بهوية](مثل_سند[ك، صـحيح_بهوية])؛
    اطبع_صحيح(س.القيمة)؛
  }
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  def i: TiInt(45);
  printInt(i.value);
  i = 7;
  
  def o: ref[TiObject](i);
  if isDerivedFrom[o, TiInt] {
    def x: ref[TiInt](castRef[o, TiInt]);
    printInt(x.value);
  }
</pre>
                    فيما يلي قائمة الأصناف الأساسية بهوية:
                    <ul class="subsections">
                      <li><span class="inlinecode">صـحيح_بهوية (TiInt)</span></li>
                      <li><span class="inlinecode">طـبيعي_بهوية (TiWord)</span></li>
                      <li><span class="inlinecode">عـائم_بهوية (TiFloat)</span></li>
                      <li><span class="inlinecode">ثـنائي_بهوية (TiBool)</span></li>
                      <li><span class="inlinecode">نـص_بهوية (TiStr)</span></li>
                      <li><span class="inlinecode">مـؤشر_بهوية (TiPtr)</span></li>
                    </ul>
                  </div>

                  <h4 id="Core-dynamicDataAccess">الوصول الديناميكي للبيانات</h4>
                  <div>
                    الأصناف المستخدمة في شجرة البنية المجردة (Abstract Syntax Tree) تدعم مجموعة من الوسطاء لتمكين تصفح
                    الشجرة بشكل ديناميكي. هذه الوسطاء تمكن من الاستعلام عن عناصر الكائن وتمكن من الوصول لتلك القيم
                    لقراءتها أو تعديلها.

                    <h5 id="Core-Binding">الوسيط: ربـط (Binding)</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">الـقلب.أسـاسيات (Core.Basic)</span>.<br>
                      هذا الوسيط يمكن المستخدم من الوصول إلى أعضاء الكائن، ويحتوي على الدالات التالية:
                      <ul class="subsections">
                        <li>
                          <span class="inlinecode">حدد_عضوا (setMember)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.حدد_عضوا (اسم_العضو: مؤشر[مصفوفة[مـحرف]]، قيمة: سند[كـائن_بهوية])؛
  عملية هذا.حدد_عضوا (تسلسل_العضو: صـحيح، قيمة: سند[كـائن_بهوية])؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.setMember (memberName: ptr[array[Char]], value: ref[TiObject]);
  handler this.setMember (memberIndex: Int, value: ref[TiObject]);
</pre>
                          تحدد قيمة عضو من أعضاء الكائن. الصيغة الأولى لتحديد العضو اعتمادا على اسمه بينما الثانية تعتمد
                          على تسلسل العضو بين أعضاء الكائن.
                        </li>
                        <li>
                          <span class="inlinecode">هات_عدد_الأعضاء (getMemberCount)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_عدد_الأعضاء (): طـبيعي؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getMemberCount(): Word;
</pre>
                          تستعلم عن عدد الأعضاء التي يمتلكها الكائن.
                        </li>
                        <li>
                          <span class="inlinecode">هات_عضوا (getMember)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_عضوا (اسم_ألعضو: مؤشر[مصفوفة[مـحرف]]): سند[كـائن_بهوية]؛
  عملية هذا.هات_عضوا (تسلسل_العضو: صـحيح): سند[كـائن_بهوية]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getMember (memberName: ptr[array[Char]]): ref[TiObject];
  handler this.getMember (memberIndex: Int): ref[TiObject];
</pre>
                          تجلب قيمة العضو ذي الإسم المعطى في الصيغة الأولى، أو التسلسل المعطى في الصيغة الثانية.
                        </li>
                        <li>
                          <span class="inlinecode">هات_الصنف_المطلوب_للعضو (getMemberNeededType)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_الصنف_المطلوب_للعضو (اسم_العضو: مؤشر[مصفوفة[مـحرف]]): سند[هـوية_صنف]؛
  عملية هذا.هات_الصنف_المطلوب_للعضو (تسلسل_العضو: صـحيح): سند[هـوية_صنف]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getMemberNeededType (memberName: ptr[array[Char]]): ref[[TypeInfo];
  handler this.getMemberNeededType (memberIndex: Int): ref[TypeInfo];
</pre>
                          تجلب هوية الصنف المطلوب للعنصر ذي الإسم المعطى في الصيغة الأولى، أو التسلسل المعطى في الصيغة
                          الثانية.
                        </li>
                        <li>
                          <span class="inlinecode">هات_اسم_العضو (getMemberKey)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_اسم_العضو (تسلسل_العضو: صـحيح): نـص؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getMemberKey (index: Int): String;
</pre>
                          تجلب اسم العضو ذي التسلسل المعطى.
                        </li>
                        <li>
                          <span class="inlinecode">جد_تسلسل_العضو (findMemberIndex)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.جد_تسلسل_العضو (اسم_العضو: مؤشر[مصفوفة[مـحرف]]): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.findMemberIndex (name: ptr[array[Char]]): Int;
</pre>
                          ترجع تسلسل العضو ذي الاسم المعطى، أو -1 إن لم يوجد عضو بهذا الاسم.
                        </li>
                      </ul>
                    </div>

                    <h5 id="Core-Containing">الوسيط: احـتواء (Containing)</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">الـقلب.أسـاسيات (Core.Basic)</span>.<br>
                      يُستخدم هذا الوسيط للاستعلام عن الكائنات الأخرى التي يحتويها هذا الكائن، أي عن العقد الأخرى التي يمتلكها
                      هذا الكائن ضمن الشجرة.<br>
                      الفرق بين هذا الوسيط ووسيط ربـط أن الأخير يستخدم للاستعلام عن صفات الكائن نفسه والتي تعتبر وصفًا لتلك
                      العقدة بينما وسيط احـتواء يستعلم عن عقد أخرى مستقلة عن الكائن لكنها مرتبطة به. على سبيل المثال لو
                      كان عندك كائن يمثل مؤثرًا ثنائيا بين قيمتين فإن نوع المؤثر يعتبر صفة ويُستعلم عنه باستخدام ربـط
                      بينما العنصرين الذين على جانبي المؤثر يُستعلم عنهما باستخدام احـتواء.<br>
                      يحوي هذا الوسيط الدالات التالية:
                      <ul class="subsections">
                        <li>
                          <span class="inlinecode">حدد_عنصرا (setElement)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.حدد_عنصرا (تسلسل_العنصر: صـحيح، قيمة: سند[كـائن_بهوية])؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.setElement (index: Int, value: ref[TiObject]);
</pre>
                          تحديد كائن جديد للعنصر ذي التسلسل المعطى.
                        </li>
                        <li>
                          <span class="inlinecode">هات_عدد_العناصر (getElementCount)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_عدد_العناصر (): طـبيعي؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getElementCount (): Word;
</pre>
                          تجلب عدد العناصر التي يحتويها الكائن.
                        </li>
                        <li>
                          <span class="inlinecode">هات_عنصرا (getElement)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_عنصرا (تسلسل_ألعنصر: صـحيح): سند[كـائن_بهوية]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getElement (index: Int): ref[TiObject];
</pre>
                          تجلب العنصر الواقع عند التسلسل المعطى.
                        </li>
                        <li>
                          <span class="inlinecode">هات_الصنف_المطلوب_للعنصر (getElementNeededType)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_الصنف_المطلوب_للعنصر (تسلسل_العنصر: صـحيح): سند[هـوية_صنف]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getElementNeededType (index: Int): ref[TypeInfo];
</pre>
                          تجلب هوية الصنف المطلوب للعنصر ذي التسلسل المعطى.
                        </li>
                      </ul>
                    </div>

                    <h5 id="Core-DynamicContaining">الوسيط: احـتواء_مرن (DynamicContaining)</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">الـقلب.أسـاسيات (Core.Basic)</span>.<br>
                      مُشتق من <span class="inlinecode">احـتواء</span> ويضيف إمكانية تغيير عدد العناصر التي يحتويها
                      الكائن. يُستخدم هذا الوسيط مع الحاويات متغيرة الحجم، ويحوي الدالات التالية بالإضافة للدالات التي
                      يحويها الوسيط احـتواء.
                      <ul class="subsections">
                        <li>
                          <span class="inlinecode">أضف_عنصرا (addElement)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.أضف_عنصرا (القيمة: سند[كـائن_بهوية]): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.addElement (value: ref[TiObject]): Int;
</pre>
                          تضيف عنصرا جديدا إلى نهاية الحاوية وترجع تسلسل العنصر الجديد.
                        </li>
                        <li>
                          <span class="inlinecode">احشر_عنصرا (insertElement)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.احشر_عنصرا (تسلسل: صـحيح، قيمة: سند[كـائن_بهوية])؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.insertElement (index: Int, value: ref[TiObject]);
</pre>
                          تضيف عنصرا جديدا إلى الحاوية عند التسلسل المعطى بعد تزحيف كل العناصر التي عند ذلك التسلسل.
                        </li>
                        <li>
                          <span class="inlinecode">أزل_عنصرا (removeElement)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.أزل_عنصرا (تسلسل_العنصر: صـحيح)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.removeElement (index: Int);
</pre>
                          تزيل العنصر الذي عند التسلسل المعين ثم تزحف كل العناصر التي تلي ذلك التسلسل.
                        </li>
                        <li>
                          <span class="inlinecode">هات_الصنف_المطلوب_للعناصر (getElementsNeededType)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_الصنف_المطلوب_للعناصر (): سند[هـوية_صنف]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getElementsNeededType (): ref[TypeInfo];
</pre>
                          تجلب هوية الصنف المطلوب لعناصر هذه الحاوية دون الحاجة لتحديد عنصر معين.
                        </li>
                      </ul>
                    </div>

                    <h5 id="Core-MapContaining">الوسيط: احـتواء_تطبيقي (MapContaining)</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">الـقلب.أسـاسيات (Core.Basic)</span>.<br>
                      مُشتق من <span class="inlinecode">احـتواء</span> ويضيف إمكانية الوصول للعناصر عبر أسمائها بدل
                      تسلسلها. يحوي هذا الوسيط الدالات التالية:
                      <ul class="subsections">
                        <li>
                          <span class="inlinecode">حدد_عنصرا (setElement)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.حدد_عنصرا (
    اسم_ألعنصر: مؤشر[مصفوفة[مـحرف]]، قيمة: سند[كـائن_بهوية]
  ): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.setElement (
    elementName: ptr[array[Char]], value: ref[TiObject]
  ): Int;
</pre>
                          تحدد قيمة جديدة للعنصر ذي الاسم المعطى وترجع تسلسل هذا العنصر.
                        </li>
                        <li>
                          <span class="inlinecode">هات_عنصرا (getElement)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_عنصرا (اسم_العنصر: مؤشر[مصفوفة[مـحرف]]): سند[كـائن_بهوية]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getElement (elementName: ptr[array[Char]]): ref[TiObject];
</pre>
                          تجلب قيمة العنصر ذي الاسم المعطى.
                        </li>
                        <li>
                          <span class="inlinecode">هات_الصنف_المطلوب_للعنصر (getElementNeededType)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_الصنف_المطلوب_للعنصر (
    اسم_العنصر: مؤشر[مصفوفة[مـحرف]]
  ): سند[هـوية_صنف]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getElementNeededType (
    elementName: ptr[array[Char]]
  ): ref[TypeInfo];
</pre>
                          تجلب هوية الصنف المطلوب للعنصر ذي الاسم المعطى.
                        </li>
                        <li>
                          <span class="inlinecode">هات_اسم_العنصر (getElementKey)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_اسم_العنصر (تسلسل_العنصر: صـحيح): نـص)
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getElementKey (index: Int): String;
</pre>
                          تجلب اسم العنصر ذي التسلسل المعطى.
                        </li>
                        <li>
                          <span class="inlinecode">جد_تسلسل_العنصر (findElementIndex)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.جد_تسلسل_العنصر (اسم_العنصر: مؤشر[مصفوفة[مـحرف]]): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.findElementIndex (name: ptr[array[Char]]): Int;
</pre>
                          ترجع تسلسل العنصر ذي الاسم المعطى، أو -1 إن لم يوجد عنصر بهذا الاسم.
                        </li>
                      </ul>
                    </div>

                    <h5 id="Core-DynamicMapContaining">الوسيط: احـتواء_تطبيقي_مرن (DynamicMapContaining)</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">الـقلب.أسـاسيات (Core.Basic)</span>.<br>
                      مُشتق من <span class="inlinecode">احـتواء_تطبيقي</span> ويضيف إمكانية إزالة عناصر أو إضافة عناصر
                      جديدة ديناميكيا. يحوي هذا الوسيط الدالات التالية:
                      <ul class="subsections">
                        <li>
                          <span class="inlinecode">أضف_عنصرا (addElement)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.أضف_عنصرا (
    اسم_العنصر: مؤشر[مصفوفة[مـحرف]]، قيمة: سند[كـائن_بهوية]
  ): صـحيح؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.addElement (
    name: ptr[array[Char]], value: ref[TiObject]
  ): Int;
</pre>
                          يضيف عنصرا جديدا باسم الجديد إلى الحاوية ويرجع تسلسل العنصر الجديد.
                        </li>
                        <li>
                          <span class="inlinecode">احشر_عنصرا (insertElement)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.احشر_عنصرا (
    تسلسل: صـحيح، اسم: مؤشر[مصفوفة[مـحرف]]، قيمة: سند[كـائن_بهوية]
  )؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.insertElement (
    index: Int, name: ptr[array[Char]], value: ref[TiObject]
  );
</pre>
                          يضيف عنصرا جديدا عند التسلسل المحدد بعد تزحيف العناصر التي عند ذلك التسلسل أو تليه.
                        </li>
                        <li>
                          <span class="inlinecode">أزل_عنصرا (removeElement)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.أزل_عنصرا (تسلسل_العنصر: صـحيح)؛
  عملية هذا.أزل_عنصرا (اسم_ألعنصر: مؤشر[مصفوفة[مـحرف]])؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.removeElement (index: Int);
  handler this.removeElement (name: ptr[array[Char]]);
</pre>
                          تزيل العنصر ذي التسلسل المعطى في الصيغة الأولى أو الاسم المعطى في الصيغة الثانية.
                        </li>
                        <li>
                          <span class="inlinecode">هات_الصنف_المطلوب_للعناصر (getElementsNeededType)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_الصنف_المطلوب_للعناصر (): سند[هـوية_صنف]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getElementsNeededType (): ref[TypeInfo];
</pre>
                          تجلب هوية الصنف المطلوب لعناصر هذه الحاوية دون الحاجة لتحديد عنصر معين.
                        </li>
                      </ul>
                    </div>
                  </div>

                  <h4 id="Core-ast">أصناف شجرة البنية المجردة (AST)</h4>
                  <div>
                    كل الأصناف المكونة لشجرة البنية المجردة مشتقة من الصنف <span class="inlinecode">عـقدة (Node)</span>
                    وكلها تدعم وسطاء الوصول الديناميكي للبيانات، لذلك يمكن أثناء التنفيذ تصفح شجرة بنية مجردة بشكل
                    ديناميكي وهو ما يمكن المستخدم من قراءة وإنشاء أشجار البنية المجردة من داخل برنامجه بما يمكنه من
                    تطوير تراكيب نحوية جديدة تسهل عليه عمله.

                    <h5 id="Core-Node">الصنف: عـقدة (Node)</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">الـقلب.بـيانات (Core.Data)</span>.<br>
                      مُشتق من <span class="inlinecode">كـائن_بهوية</span>.<br>
                      جذر لأصناف بيانات أخرى مثل أصناف شجرة البنية المجردة. يمكن هذا الصنف من الوصول من كائن إلى مالكه.
                      <ul class="subsections">
                        <li>
                          <span class="inlinecode">المالك (owner): سند[عـقدة]</span><br>
                          سند إلى مالك هذا الكائن.
                        </li>
                        <li>
                          <span class="inlinecode">هات_هوية_الصنف (getTypeInfo)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  دالة هات_هوية_الصنف (): سند[هـوية_صنف]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  func getTypeInfo (): ref[TypeInfo];
</pre>
                          هذه الدالة تُرجع سندًا لهوية هذا الصنف، أي لهوية الكائنات المشتقة من هذا الصنف.
                        </li>
                      </ul>
                    </div>

                    <h5 id="Core-textAstTypes">الأصناف النصية</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">الـقلب.بـيانات.شـبم (Core.Data.Ast)</span>.<br>
                      مُشتق من <span class="inlinecode">عـقدة</span>.<br>
                      هذه الأصناف التي تحوي مقطعًا نصيّا مفردًا من الشفرة المصدرية، أي دون مؤثرات أو تراكيب. المقطع النصي
                      هنا يُقصد به أي سلسلة محارف يُفسرها المرمّز (lexer) كرمز واحد ولذا قد تكون معرفا أو رقما أو سلسلة
                      محارف. تحوي هذه الأصناف العناصر التالية:
                      <ul class="subsections">
                        <li>
                          <span class="inlinecode">القيمة (value): نـص_بهوية (TiStr)</span><br>
                          سلسلة المحارف المقروءة من الشفرة المصدرية.
                        </li>
                        <li>
                          <span class="inlinecode">هات_هوية_الصنف (getTypeInfo)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  دالة هات_هوية_الصنف (): سند[هـوية_صنف]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  func getTypeInfo (): ref[TypeInfo];
</pre>
                          هذه الدالة تُرجع سندًا لهوية هذا الصنف، أي لهوية الكائنات المشتقة من هذا الصنف.
                        </li>
                        <li>
                          <span class="inlinecode">أنشئ (create)</span><br>
<pre class="code" dir=rtl style="text-align:right;">
  دالة أنشئ (قيمة: مؤشر[مصفوفة[مـحرف]]): سـندنا[الـصنف]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  func create (value: ptr[array[Char]]): SrdRef[TheType];
</pre>
                          تنشئ كائنًا من هذا الصنف بالقيمة المعطاة وترجع سندًا مشتركًا له.
                        </li>
                      </ul>
                      فيما يلي قائمة بالأصناف النصية:
                      <ul class="subsections">
                        <li>
                          <span class="inlinecode">مـعرف (Identifier)</span><br>
                          أي معرف كان من الشفرة المصدرية مثل اسم متغير أو اسم دالة أو ما شابه.
                        </li>
                        <li>
                          <span class="inlinecode">نـص_حرفي (StringLiteral)</span><br>
                          يحوي سلسلة محارف، أي سلسلة المحارف المحصورة بين علامتي اقتباس. القيمة المخزنة في هذا الكائن
                          لا تشمل علامات الاقتباس كما أنها لا تشمل علامات المحارف المركبة (مثل رمز \) وإنما تشمل المحرف
                          نفسه فقط. على سبيل المثال، عندما يكتب المستخدم \" فإن قيمة هذا الكائن ستحوي فقط على " دون
                          علامة \.<br>
                          في حالة تقسيم المستخدم سلسلته النصية إلى عدة مقاطع (بإغلاق علامة الاقتباس ثم فتحها من جديد) فإن
                          القيمة التي في هذا الكائن ستكون سلسلة محارف تشمل جميع المقاطع ودون فراغات. على سبيل المثال،
                          إذا أدخل المستخدم <span class="inlinecode">"السلام"   " عليكم"</span> فإن قيمة هذا الكائن ستكون
                          <span class="inlinecode">السلام عليكم</span>.
                        </li>
                        <li>
                          <span class="inlinecode">مـحرف_حرفي (CharLiteral)</span><br>
                          يحوي محرفًا، أي المحرف المحصور في الشفرة المصدرية بين علامتي اقتباس مفردة، لكن القيمة
                          في هذا الكائن بدون علامتي الاقتباس.
                        </li>
                        <li>
                          <span class="inlinecode">صـحيح_حرفي (IntegerLiteral)</span><br>
                          يحوي عددا صحيحًا مع الرموز المتعلقة بصنف العدد الصحيح، مثلا: "456ص32".
                        </li>
                        <li>
                          <span class="inlinecode">عـائم_حرفي (FloatLiteral)</span><br>
                          يحوي عددا بفاصلة مع الرموز المتعلقة بصنف العدد، مثلا: "1.2f32".
                        </li>
                      </ul>
                    </div>

                    <h5 id="Core-expAstTypes">أصناف الأوامر والتراكيب</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">الـقلب.بـيانات.شـبم (Core.Data.Ast)</span>.<br>
                      مُشتق من <span class="inlinecode">عـقدة</span>.<br>
                      فيما يلي قائمة الأصناف الممثلة للأوامر والتراكيب وما شابه. باستثناء دالة <span class="inlinecode">هات_هوية_الصنف</span>
                      لا تملك هذه الأصناف دالات أخرى وإنما يمكن الوصول لأعضائها وعناصرها باستخدام وسطاء الوصول الديناميكي
                      للبيانات.
                      <ul class="subsections">
                        <li>
                          <span class="inlinecode">لـقب (Alias)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">قـوس (Bracket)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">جـسر (Bridge)</span><br>
                          يمثل هذا الصنف عبارة `استخدم` (use) التي تنشئ جسرًا من مجال يمكنه من الوصول تلقائيًا لعناصر مجال
                          آخر.
                        </li>
                        <li>
                          <span class="inlinecode">تـعريف (Definition)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">إيـعاز (GenericCommand)</span><br>
                          صنف عمومي يمكن استخدامه لحمل بيانات إيعاز غير محدد. يحمل نصا للكلمة المفتاحية مع فائمة مرنة
                          من البيانات.
                        </li>
                        <li>
                          <span class="inlinecode">قـائمة (List)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">تـطبيق (Map)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">قـائمة_دمج (MergeList)</span><br>
                          صنف خاص يبلغ المعرب أن يدمج عناصره مباشرة في المجال العلوي بدل أن تبقى كقائمة فرعية داخل
                          المجال العلوي.
                        </li>
                        <li>
                          <span class="inlinecode">مـمرر_معطيات (ParamPass)</span><br>
                          يمثل عملية تمرير بيانات إلى عنصر ما مثل استدعاء دالة أو ماكرو أو قالب.
                        </li>
                        <li>
                          <span class="inlinecode">مـجال (Scope)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">رمـز (Token)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_قبلي (PrefixOperator)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_بعدي (PostfixOperator)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_تعيين (AssignmentOperator)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_مقارنة (ComparisonOperator)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_جمع (AdditionOperator)</span><br>
                          لعملبات الجمع والطرح.
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_ضرب (MultiplicationOperator)</span><br>
                          لعمليات الضرب والقسمة.
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_بتي (BitwiseOperator)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_منطقي (LogOperator)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_ربط (LinkOperator)</span><br>
                          لمؤثرات الربط بين عنصر وعضو منه مثل مرثر النفطة أو مؤثر -> أو ما شابه.
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_شرط (ConditionalOperator)</span><br>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>

                <!-- ********************************************************************** -->
                <br>
                <h3 id="Spp">دليل الوحدة `نـبم`</h3>
                <hr>
                <div>
                <p>
                  الوحدة `نـبم` (نمط البرمجة المعياري) تحتوي على دالات للتعامل مباشرة مع مكتبة spp، وهي المكتبة المسؤولة عن دعم نمط البرمجة المعياري. عناصر هذه الوحدة تمكن المستخدم من التعامل مباشرة مع المترجم من خلال برنامجه.
                </p>
                  <h4 id="Spp-buildMgr">الكائن: مدير_البناء (buildMgr)</h4>
                  <div>
                    هذا الكائن المفرد يمكن المستخدم من التعامل مع مولد الشفرة التنفيذية ويحوي الدالات التالية:
                    <h5 id="Spp-buildMgr-dumpLlvmIrForElement">أدرج_تو_لعنصر (dumpLlvmIrForElement)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.أدرج_تو_لعنصر (عنصر: سند[كـائن_بهوية])؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.dumpLlvmIrForElement (element: ref[TiObject]);
</pre>
                    دالة `أدرج_تو_لعنصر` تقوم بطبع الترميز الوسطي لعنصر معين من الشفرة المصدرية. الترميز الوسطي المطبوع هو ترميز LLVM IR. تستقبل الدالة معطى واحد وهو مؤشر على شبكة البنية المجردة لذلك العنصر (Abstract Syntax Tree). يمكنك الحصول على هذا المؤشر باستخدام الأمر `~شبم` كما في المثال التالي:
<pre class="samplecode" dir=rtl style="text-align:right;">
  نـبم.مدير_البناء.أدرج_تو_لعنصر(دالتي~شبم)؛
</pre>
<pre class="samplecode" dir=ltr style="text-align:left;">
  Spp.buildMgr.dumpLlvmIrForElement(myFunc~ast);
</pre>
                    </div>

                    <h5 id="Spp-buildMgr-buildObjectFileForElement">أنشء_ملفا_رقميا_لعنصر (buildObjectFileForElement)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.أنشء_ملفا_رقميا_لعنصر (
    عنصر: سند[كـائن_بهوية]،
    اسم_الملف: مؤشر[مصفوفة[محرف]]،
    وصف_المعمارية: مؤشر[مصفوفة[محرف]]
  ): ثنائي
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.buildObjectFileForElement (
    element: ref[TiObject],
    filename: ptr[array[Char]],
    targetTriple: ptr[array[Char]]
  ): Bool;
</pre>
                    تنشئ هذه الدالة ملف شفرة مترجمة للعنصر المعني (object file). يمكن لاحقا تمرير هذا الملف إلى مُجمِّع (linker)
                    لإنشاء ملف تنفيذي. المعطى الثالث قيمة target triple تحدد المعمارية التي ستستخدم في البناء. في حالة تمرير 0
                    لهذا المعطى تُستخدم المعمارية الحالية للنظام. على سبيل المثال لبناء شفرة تنفيذية بمعمارية ويب أسمبلي تُمرر
                    القيمة "wasm32-unknown-unknown". يمكن مراجعة وثائق LLVM لمزيد من المعلومات حول هذه القيمة.<br>
                    ترجع الدالة 1 في حال نجح البناء، وبعكسه ترجع 0.
<pre class="samplecode" dir=rtl style="text-align:right;">
  نـبم.مدير_البناء.أنشء_ملفا_رقميا_لعنصر(وحـدتي~شبم، "اسم_الملف_الناتج"، 0)؛
</pre>
<pre class="samplecode" dir=ltr style="text-align:left;">
  Spp.buildMgr.buildObjectFileForElement(MyModule~ast, "output_filename", 0);
</pre>
                    </div>

                    <h5 id="Spp-buildMgr-raiseBuildNotice">ارفع_إشعار_بناء (raiseBuildNotice)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
  دالة ارفع_إشعار_بناء (
    رمز: مؤشر[مصفوفة[مـحرف]]، حدة: صـحيح، عنصر_شبم: سند[الـقلب.أسـاسيات.كـائن_بهوية]
  )؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  func raiseBuildNotice (
    code: ptr[array[Char]], severity: Int, astNode: ref[TiObject]
  );
</pre>
                    تمكن هذه الدالة المبرمج من رفع إشعار بناء بشكل برمجي أثناء المعالجة التمهيدية. تأخذ هذه الدالة ثلاث معطيات:
                    <ul>
                      <li><b>رمز</b>: رمز إشعار الخطأ المراد إظهاره للمستخدم. قائمة الرموز المتوفرة تجدها داخل المجلد Notices_L18n.</li>
                      <li><b>حدة</b>: قيمة تبين حدة الإشعار ويمكن أن تكون واحدا من هذه القيم:
                       <ul>
                         <li><b>0</b>: الإشعاء لخطأ جذري لا يُمكن استمرار البناء معه.</li>
                         <li><b>1</b>: إشعار خطأ، لكن الترجمة يمكنها الاستمرار لاكتشاف أخطاء أخرى إن وجدت.</li>
                         <li><b>2</b>: إشعاء لتحذير مهم يجب على المستخدم مراجعته.</li>
                         <li><b>3</b>: إشعار لتحذير قليل الأهمية يمكن للمستخدم تجاهله.</li>
                         <li><b>4</b>: إشعار إعلامي فقط وليس لخطأ.</li>
                       </ul>
                      </li>
                      <li><b>عنصر_شبم</b>: سند لعنصر شبم المعني بالإشعار. سيشير الإشعار إلى موقع الشفرة المصدرية الذي يظهر عنده العنصر. </li>
                    </ul>
                    مثال:
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرف رمز_خطأ: "SPPH1006"؛
  نـبم.مدير_البناء.ارفع_إشعار_بناء(رمز_خطأ، 1، عنصر_معطى_الدالة)؛
  // السطر أعلاه سيظهر إشعار خطأ: اسم معطى الدالّة غير صالح.
</pre>
<pre class="samplecode" dir=ltr style="text-align:left;">
  def errorCode: "SPPH1006";
  Spp.buildMgr.raiseBuildNotice(errorCode, 1, funcArgNode);
  // The above line will show an build error: Invalid function argument name.
</pre>
                    </div>
                  </div>

                  <h4 id="Spp-grammarMgr">الكائن: مدير_القواعد (grammarMgr)</h4>
                  <div>
                    هذا الكائن المفرد يمكن المستخدم من إنشاء قواعد جديدة للغة، ويحوي الدالات التالية:
                    <h5 id="Spp-buildMgr-addCustomCommand">أضف_أمرا_مخصصا (addCustomCommand)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
عرف كـائن_بهوية: لقب الـقلب.أسـاسيات.كـائن_بهوية؛

عملية هذا.أضف_أمرا_مخصصا (
    معرف: مؤشر[مصفوفة[مـحرف]]،
    شجرة_القاعدة: سند[كـائن_بهوية]
    معالج: مؤشر[دالة (سـندنا[كـائن_بهوية]): سـندنا[كـائن_بهوية]]
)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
def TiObject: alias Core.Basic.TiObject;

handler this.addCustomCommand (
    identifier: ptr[array[Char]],
    grammarAst: ref[TiObject],
    handler: ptr[func (SrdRef[TiObject]): SrdRef[TiObject]]
);
</pre>
                    تستخدم هذه الدالة لإضافة قاعدة لأمر جديد إلى قواعد اللغة ديناميكيًا. تستلم هذه الدالة ثلاث معطيات:
                    <ul>
                     <li><b>معرف</b>: سلسلة محارف تستخدم كمعرف للقاعدة الجديدة. يمكن تمرير أي قيمة لهذا المعرف طالما أنها من حروف وأرقام فقط ولا تتضارب مع معرف موجود مسبقًا.</li>
                     <li><b>شجرة_القاعدة</b>: شجرة بنية مجردة تصف قاعدة الأمر الجديد. تأخذ هذه الشجرة الشكل التالي:
<pre class="code" dir=rtl style="text-align:right;">
شبم {
    مفاتيح: <الكلمات المفتاحية للأمر>؛
    معطيات: <وصف للمعطيات التي تتبع الكلمة المفتاحية>؛
}
</pre>
<pre class="code" dir=ltr style="text-align:left;">
ast {
    keywords: &lt;keywords of the command&gt;;
    args: &lt;description of the args following the keyword&gt;;
}
</pre>
                      يمكن للأمر أن يملك كلمة مفتاحية واحدة، أو مجموعة كلمات (يفصلها في التعريف مؤثر |). يمكن للأمر أن لا يستقبل أي معطيات، أو أن يستقبل معطى واحد أو مجموعة معطيات (يفصلها في التعريف مؤثر +). كل معطى من هذه المعطيات يتكون من المسار المؤدي إلى القاعدة الإعرابية للمعطى، متبوعًا بعلامة * متبوعة بقوسين بينهما الحدين الأدنى والأعلى (على التوالي) لظهور هذا المعطى ضمن الأمر. راجع الشفرة المصدرية لقواعد لغة الأسس لمزيد من المعلومات حول القواعد المتوفرة التي يمكن استخدامها كمعطيات.
                     </li>
                     <li><b>معالج</b>: دالة تستقبل شجرة البناء المجردة التي أنشأها المترجم أثناء إعراب الشفرة المصدرية وتعالجها ثم تعيد شجرة بناء مجردة يتم حشرها كنتيجة نهائية لإعراب هذا الأمر.</li>
                    </ul>
                    مثال:
<pre class="samplecode" dir=rtl style="text-align:right;">
نـبم.مدير_القواعد.أضف_أمرا_مخصصا(
    "أمـر_اختبار"،
    شبم {
        مفاتيح: "أمر_اختبار" | "test_cmd"؛
        معطيات: "module".Expression*(0,2) +
                "module".Set*(1,1)؛
    }،
    دالة (معطيات: سـندنا_بهوية): سـندنا_بهوية { ... }
)؛
</pre>
<pre class="samplecode" dir=ltr style="text-align:left;">
Spp.grammarMgr.addCustomCommand(
    "TestCommand",
    ast {
        keywords: "test_cmd";
        args: "module".Expression(0, 2) + "module".Set*(1,1);
    },
    func (args: SrdRef[TiObject]): SrdRef[TiObject] { ... }
);
</pre>
                    المثال أعلاه يعرف أمرًا جديدا يبدأ إما بالكلمة المفتاحية `أمر_اختبار` أو بالكلمة المفتاحية `test_cmd`، ثم يتبع الكلمة المفتاحية معطى من نوع تركيب يمكن أن يظهر مرة واحدة أو مرتين متتابعتين أو لا يظهر أساسًا، ويتبع هذه التراكيب معطى من نوع كتلة (set) يجب أن يظهر مرة واحدة تحديدًا.
                    </div>

                    <h5 id="Spp-buildMgr-addCustomCommand">أضف_قاعدة_مخصصة (addCustomGrammar)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
عرف كـائن_بهوية: لقب الـقلب.أسـاسيات.كـائن_بهوية؛

عملية هذا.أضف_قاعدة_مخصصة (
    معرف: مؤشر[مصفوفة[مـحرف]]،
    معرف_الأصل: مؤشر[مصفوفة[مـحرف]]،
    شجرة_القاعدة: سند[كـائن_بهوية]
)؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
def TiObject: alias Core.Basic.TiObject;

handler this.addCustomGrammar (
    identifier: ptr[array[Char]],
    baseIdentifier: ptr[array[Char]],
    grammarAst: ref[TiObject]
);
</pre>
                      تستخدم هذه الدالة لإضافة قاعدة جديدة إلى قواعد اللغة ديناميكيًا. تختلف هذه الدالة عن دالة `أضف_أمرا_مخصصا` (addCustomCommand) بأنها القاعدة الجديدة لا يشترط أن تكون أمرًا (وإنما يمكنها أن تكون تركيبا أو أي شيء) وتكون القاعدة الجديدة مشتقة من قاعدة أخرى. تستلم هذه الدالة ثلاث معطيات:
                    <ul>
                     <li><b>معرف</b>: سلسلة محارف تستخدم كمعرف للقاعدة الجديدة. يمكن تمرير أي قيمة لهذا المعرف طالما أنها من حروف وأرقام فقط ولا تتضارب مع معرف موجود مسبقًا.</li>
                     <li><b>معرف_الأصل</b>: معرف القاعد الأصل التي ستُشتق منها القاعدة الجديدة.</li>
                     <li><b>شجرة_القاعدة</b>: شجرة بنية مجردة تصف التغييرات التي ستطبق على القاعدة الجديدة مقارنة بالقاعدة الأصل. تأخذ هذه الشجرة الشكل التالي:
<pre class="code" dir=rtl style="text-align:right;">
شبم {
    &lt;مسار_القيمة_المراد_تعديلها&gt;: { &lt;القيمة_الجديدة&gt; }؛
    ...
}
</pre>
<pre class="code" dir=ltr style="text-align:left;">
ast {
    &lt;path_to_value_to_update&gt;: { &lt;new_value&gt; };
    ...
}
</pre>
                      شجرة القاعدة تحتوي مجموعة من المدخلات، كل مدخلة تتكون من المسار للقيمة المراد تعديلها ثم القيمة الجديدة. المسار يكون نسبة لجذر القاعدة.
                     </li>
                    </ul>
                      في المثال التالي سيتم إنشاء قاعدة جديدة مشتقة من القاعدة FuncSigExpression مع تعديل واحد وهو تغيير معطيات القاعدة الفرعية BitwiseExp. اطلع على قواعد لغة الأسس لتعرف القاعدات التي يمكنك الاشتقاق منها وما تحتاج لتعديله عند الاشتقاق.
<pre class="code" dir=ltr style="text-align:left;">
Spp.grammarMgr.addCustomGrammar(
    "ClosureSigExp",
    "FuncSigExpression",
    ast {
        BitwiseExp.vars: { enable: 1 }
    }
);
</pre>
                  </div>
                  </div>

                  <h4 id="Spp-astMgr">الكائن: مدير_شبم (astMgr)</h4>
                  <div>
                    هذا الكائن المفرد يحتوي دالات للتعامل مع شجرة البنية المجردة (Abstract Syntax Tree). يحتوي على الدالات التالية:
                    <h5 id="Spp-astMgr-findElements">جد_عناصر (findElements)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.جد_عناصر (
    معيار_البحث: سند[الـقلب.أسـاسيات.كـائن_بهوية]،
    موقع_البحث: سند[الـقلب.أسـاسيات.كـائن_بهوية]،
    خيارات: طـبيعي
  ): مـصفوفة[سند[الـقلب.أسـاسيات.كـائن_بهوية]]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.findElements (
    comparison: ref[Core.Basic.TiObject],
    target: ref[Core.Basic.TiObject],
    flags: Word
): Array[ref[Core.Basic.TiObject]];
</pre>
                      تبحث ضمن الشفرة المصدرية عن عناصر تطابق معيار البحث المعطى. المعطيان الأول والثاني سندان على شجرتي بنية مجردة،
                      الأولى لتركيب يمثل معيار البحث بينما الثانية هي الشجرة التي سيتم البحث فيها.<br>
                      الخيار الثالث يمكن أن يكون واحدا من هذه القيم:
                      <ul>
                        <li>
                          <b>خـيارات_الساعي._تخطى_المالكين_ (SeekerFlags.SKIP_OWNERS)</b><br/>
                          تُعلم الساعي أن لا يبحث في المجالات التي يقعل موقع البحث الحالي داخلها. على سبيل المثال، إذا بحثت
                          ضمن مسار `عـام.فـرعي` فإنه مبدئيًا سيبحث ضمن `فـرعي` ثم ضمن `عـام`، فإذا أضفت هذا الخيار فإنه
                          سيبحث ضمن `فـرعي` فقط.
                        </li>
                        <li>
                          <b>خـيارات_الساعي._تخطى_الاستخدامات_ (SeekerFlags.SKIP_USES)</b><br/>
                          تُبلغ الساعي أن يتجاهل عبارات `استخدم` (use) أثناء البحث. بدون هذا الخيار فإن الساعي سيبحث في
                          المجالات التي تشير إليها هذه العبارات.
                        </li>
                        <li><b>خـيارات_الساعي._تخطى_الأبناء_ (SeekerFlags.SKIP_CHILDREN)</b><br/>
                          تُعلم الساعي أن لا يبحث في المجالات الفرعية. مثلا إذا بحثت ضمن المجال `عـام` وكان هذا المجال يحتوي
                          على المجال `فـرعي` فإن الساعي سيبحث في `عـام` ثم `فـرعي` ما لم تُعطه هذا الخيار، فإن فعلت فسيبحث
                          في `عـام` فقط.
                        </li>
                      </ul>
                      المثال التالي يبحث عن كل الدالات ضمن صنف محدد:
<pre class="samplecode" dir=rtl style="text-align:right;">
  العناصر = نـبم.مدير_شبم.جد_عناصر(
    شبم { نوع_العنصر == "دالة" }،
    صـنفي~شبم،
    نـبم.خـيارات_الساعي._تخطى_المالكين_ | نـبم.خـيارات_الساعي._تخطى_الاستخدامات_ | نـبم.خـيارات_الساعي._تخطى_الأبناء_
  )؛
</pre>
<pre class="samplecode" dir=ltr>
  elements = Spp.astMgr.findElements(
    ast { elementType == "function" },
    MyClass~ast,
    Spp.SeekerFlags.SKIP_OWNERS | Spp.SeekerFlags.SKIP_USES | Spp.SeekerFlags.SKIP_CHILDREN
  );
</pre>
                      يمكن باستخدام معيار البحث البحث حسب نوع العنصر أو حسب المبدلات المطبقة على العنصر. ويمكن أيضا استخدام
                      شرط مركب يحتوي على مؤثري `و` و `أو`. فيما يلي بعض الأمثلة على معايير البحث:
<pre class="samplecode" dir=rtl style="text-align:right;">
  نوع_العنصر == "دالة" // بحث عن دالات
  نوع_العنصر == "صنف" // بحث عن أصناف المستخدم
  نوع_العنصر == "وحدة" // بحث عن وحدات
  نوع_العنصر == "متغير" // بحث عن متغيرات
  مبدل == "عمومي" // بحث عن عناصر مطبق عليها مبدل @عمومي
  نوع_العنصر == "دالة" و مبدل == "عمومي" // بحث عن دالات عليها مبدل @عمومي
</pre>
<pre class="samplecode" dir=ltr>
  elementType == "function" // search for functions
  elementType == "type" // search for types
  elementType == "module" // search for modules
  elementType == "var" // serach for variables
  modifier == "public" // search for elements with @public modifier
  elementType == "func" && modifier == "public" // search for functions with @public modifier
</pre>
                    </div>

                    <h5 id="Spp-astMgr-getModifiers">هات_المبدلات (getModifiers)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_المبدلات (
    عنصر: سند[الـقلب.أسـاسيات.كـائن_بهوية]
  ): سند[الـقلب.أسـاسيات.احـتواء]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getModifiers (
      element: ref[Core.Basic.TiObject]
  ): ref[Core.Basic.Containing];
</pre>
                      تجلب قائمة المبدلات المطبقة على العنصر المُعطى.
                    </div>

                    <h5 id="Spp-astMgr-findModifier">جد_مبدلا (findModifier)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.جد_مبدلا (
    مبدلات: سند[الـقلب.أسـاسيات.احـتواء]،
    كلمة_مفتاحية: مؤشر[مصفوفة[مـحرف]]
  ): سند[الـقلب.أسـاسيات.كـائن_بهوية]
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.findModifier(
      modifiers: ref[Core.Basic.Containing],
      kwd: ptr[array[Char]]
  ): ref[Core.Basic.TiObject];
</pre>
                      إيجاد مبدل ضمن قائمة مبدلات. يتم البحث باستخدام الكلمة المفتاحية للمبدل. مثلا، للبحث عن مبدل `@تصدير[...]`
                      نحتاج لتمرير الكلمة المفتاحية `تصدير`.
                    </div>

                    <h5 id="Spp-astMgr-findModifierForElement">جد_مبدلا_لعنصر (findModifierForElement)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.جد_مبدلا_لعنصر (
    عنصر: سند[الـقلب.أسـاسيات.كـائن_بهوية]،
    كلمة_مفتاحية: مؤشر[مصفوفة[مـحرف]]
  ): سند[الـقلب.أسـاسيات.كـائن_بهوية]
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.findModifierForElement(
    element: ref[Core.Basic.TiObject],
    kwd: ptr[array[Char]]
  ): ref[Core.Basic.TiObject];
</pre>
                      إيجاد المبدل بالكلمة المعيارية المعطاة على العنصر المعطى.
                    </div>

                    <h5 id="Spp-astMgr-getModifierKeyword">هات_كلمة_المبدل_المفتاحية (getModifierKeyword)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
  عملية هذا.هات_كلمة_المبدل_المفتاحية (
    مبدل: سند[الـقلب.أسـاسيات.كـائن_بهوية]
  ): نـص
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  handler this.getModifierKeyword(
    modifier: ref[Core.Basic.TiObject]
  ): Srl.String;
</pre>
                      تُرجع الكلمة المفتاحية للمبدل المعطى.
                    </div>

                    <h5 id="Spp-astMgr-getModifierStringParams">هات_المعطيات_النصية_لمبدل (getModifierStringParams)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.هات_المعطيات_النصية_لمبدل (
    مبدل: سند[الـقلب.أسـاسيات.كـائن_بهوية]،
    الناتج: سند[مـصفوفة[نـص]]
): ثـنائي
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.getModifierStringParams(
    modifier: ref[Core.Basic.TiObject],
    result: ref[Array[String]]
) => Bool;
</pre>
                      تُرجع قائمة بكل المعطيات النصية الممررة للمبدل. مثلاً لو كان عندنا مبدل `@اعتماديات["مكتبة1"، "مكتبة2"]`
                      واستخدمنا هذه الدالة فإننا سنحصل منها على مصفوفة من عنصرين، الأول قيمته "مكتبة1" والثاني "مكتبة2".
                      تُرجع الدالة قيمة ثنائية تكون 1 عند نجاح العملية و0 عند فشلها.
                    </div>

                    <h5 id="Spp-astMgr-getSourceFullPathForElement">هات_المسار_الكامل_لشفرة_عنصر (getSourceFullPathForElement)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.هات_المسار_الكامل_لشفرة_عنصر (
    عنصر: سند[الـقلب.أسـاسيات.كـائن_بهوية]
): نـص
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.getSourceFullPathForElement(
    element: ref[Core.Basic.TiObject]
) => String;
</pre>
                      ترجع اسم الملف الكامل مع المسار لملف الشفرة المصدرية الذي يحتوي العنصر المعطى.
                    </div>

                    <h5 id="Spp-astMgr-getSourceDirectoryForElement">هات_مجلد_شفرة_عنصر (getSourceDirectoryForElement)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.هات_مجلد_شفرة_عنصر (
    عنصر: سند[الـقلب.أسـاسيات.كـائن_بهوية]
): نـص
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.getSourceDirectoryForElement(
    element: ref[Core.Basic.TiObject]
) => String;
</pre>
                      ترجع المسار الكامل للمجلد الذي يحتوي ملف الشفرة المصدرية الذي يحتوي العنصر المعطى.
                    </div>

                    <h5 id="Spp-astMgr-insertAst">احشر_شبم (insertAst)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.احشر_شبم (
    عنصر: سند[الـقلب.أسـاسيات.كـائن_بهوية]،
    استعاضات: سند[تـطبيق[نـص، سند[الـقلب.أسـاسيات.كـائن_بهوية]]]
): ثـنائي
عملية هذا.احشر_شبم (
    عنصر: سند[الـقلب.أسـاسيات.كـائن_بهوية]،
    استعاضات: سند[تـطبيق[نـص، سـندنا[الـقلب.أسـاسيات.كـائن_بهوية]]]
): ثـنائي
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.insertAst(
    element: ref[Core.Basic.TiObject],
    interpolations: ref[Map[String, ref[Core.Basic.TiObject]]]
) => Bool;
handler this.insertAst(
    element: ref[Core.Basic.TiObject],
    interpolations: ref[Map[String, SrdRef[Core.Basic.TiObject]]]
) => Bool;
</pre>
                      تحشر شجرة البنية المجردة المعطاة في الموضع الحالي بعد تطبيق الاستعاضات المعطاة على الشجرة المعطاة بنفس طريقة
                      عمل الماكروهات. المعطى الأول للدالة هو الشجرة التي سيتم حشرها بينما المعطى الثاني يحمل قائمة الاستعاضات.<br>
                      الموضع الذي ستُحشر فيه الشفرة هو الموضع الحالي للمعالجة التمهيدية، أي الموضع الذي ظهرت فيه عبارة `تمهيد` التي
                      استدعت دالة `احشر_شبم`. المثال التالي يحشر عشرة تعريفات لمتغيرات من صنف صحيح أسماؤها من ن0 إلى ن9:
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرف ع: صـحيح؛
  لكل ع = 0، ع < 5، ++ع {
      عرف عداد: نـص_بهوية = نـص.املأ("%i"، ع)؛
      نـبم.مدير_شبم.أنشئ_شبم(
          شبم { عرف ن__عداد__: صـحيح }،
          تـطبيق[نـص، سند[كـائن_بهوية]]().حدد(نـص("عداد")، عداد)
      )؛
  }
</pre>
<pre class="samplecode" dir=ltr>
  def i: Int;
  for i = 0, i < 10, ++i {
      def counter: TiStr = String.format("%i", i);
      Spp.astMgr.insertAst(
          ast { def n__counter__: Int },
          Map[String, ref[TiObject]]().set(String("counter"), counter)
      );
  }
</pre>
                    </div>

                    <h5 id="Spp-astMgr-buildAst">أنشئ_شبم (buildAst)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.أنشئ_شبم (
    عنصر: سند[الـقلب.أسـاسيات.كـائن_بهوية]،
    استعاضات: سند[تـطبيق[نـص، سند[الـقلب.أسـاسيات.كـائن_بهوية]]]،
    النتيجة: سند[سـندنا[الـقلب.أسـاسيات.كـائن_بهوية]]
): ثـنائي
عملية هذا.أنشئ_شبم (
    عنصر: سند[الـقلب.أسـاسيات.كـائن_بهوية]،
    استعاضات: سند[تـطبيق[نـص، سـندنا[الـقلب.أسـاسيات.كـائن_بهوية]]]،
    النتيجة: سند[سـندنا[الـقلب.أسـاسيات.كـائن_بهوية]]
): ثـنائي
عملية هذا.أنشئ_شبم (
    عنصر: سند[الـقلب.أسـاسيات.كـائن_بهوية]،
    استعاضات: سند[تـطبيق[نـص، سند[الـقلب.أسـاسيات.كـائن_بهوية]]]
): سـندنا[الـقلب.أسـاسيات.كـائن_بهوية]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.buildAst(
    element: ref[Core.Basic.TiObject],
    interpolations: ref[Map[String, ref[Core.Basic.TiObject]]],
    result: ref[SrdRef[Core.Basic.TiObject]]
) => Bool;
handler this.buildAst(
    element: ref[Core.Basic.TiObject],
    interpolations: ref[Map[String, SrdRef[Core.Basic.TiObject]]],
    result: ref[SrdRef[Core.Basic.TiObject]]
) => Bool;
handler this.buildAst(
    element: ref[Core.Basic.TiObject],
    interpolations: ref[Map[String, ref[Core.Basic.TiObject]]]
): SrdRef[Core.Basic.TiObject];
</pre>
                      هذه الدالة مشابهة لدالة `احشر_شبم` غير أنها تنشئ شجرة البنية المجردة وترجعها للمستدعي بدل أن تحشرها
                      مباشرة في الموضع الحالي للمعالجة التميهدية. يمكن للمستخدم لاحقًا أن يحشر النتيجة المستلمة في الموضع
                      الحالي باستخدام دالة `احشر_شبم`. المثال التالي تعديل على المثال أعلاه ليستخدم هذه الدالة وليضيف أيضًا
                      تصفيرًا للمتغيرات التي يعرفها. المثال ينشئ تعريفًا ثم يستخدم التعريف الناتج كاستعاضة في استدعاء لاحق
                      لدالة `احشر_شبم`:
<pre class="samplecode" dir=rtl style="text-align:right;">
  عرف ع: صـحيح؛
  لكل ع = 0، ع < 5، ++ع {
      عرف عداد: نـص_بهوية = نـص.املأ("%i"، ع)؛
      عرف نتيجة: سـندنا[كـائن_بهوية]؛
      نـبم.مدير_شبم.أنشئ_شبم(
          شبم { عرف ن__عداد__: صـحيح }،
          تـطبيق[نـص، سند[كـائن_بهوية]]().حدد(نـص("عداد")، عداد)،
          نتيجة
      )؛
      نـبم.مدير_شبم.احشر_شبم(
          شبم{
              تعريف؛
              ن__عداد__ = 0؛
          }،
          تـطبيق[نـص، سند[كـائن_بهوية]]()
              .حدد(نـص("عداد")، عداد)
              .حدد(نـص("تعريف")، نتيجة)
      )؛
  }
</pre>
<pre class="samplecode" dir=ltr>
  def i: Int;
  for i = 0, i < 10, ++i {
      def counter: TiStr = String.format("%i", i);
      def result: SrdRef[TiObject];
      Spp.astMgr.buildAst(
          ast { def n__counter__: Int },
          Map[String, ref[TiObject]]().set(String("counter"), counter),
          result
      );
      Spp.astMgr.insertAst(
          ast {
              definition;
              n__counter = 0;
          },
          Map[String, ref[TiObject]]()
              .set(String("counter"), counter)
              .set(String("definition"), result)
      );
  }
</pre>
                    </div>

                    <h5 id="Spp-astMgr-getCurrentPreprocessOwner">هات_مالك_عبارة_التمهيد_الحالية (getCurrentPreprocessOwner)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.هات_مالك_عبارة_التمهيد_الحالية (): سند[الـقلب.أسـاسيات.كـائن_بهوية]
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.getCurrentPreprocessOwner(): ref[Core.Basic.TiObject];
</pre>
                      ترجع هذه الدالة سندًا لعنصر شبم الذي يملك عبارة التمهيد قيد التنفيذ.
                    </div>

                    <h5 id="Spp-astMgr-getCurrentPreprocessInsertionPosition">هات_محشر_عبارة_التمهيد_الحالية (getCurrentPreprocessInsertionPosition)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.هات_محشر_عبارة_التمهيد_الحالية (): صـحيح
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.getCurrentPreprocessInsertionPosition(): Int;
</pre>
                      ترجع هذه الدالة التسلسل (ضمن مالك عبارة التمهيد الحالية) الذي ستُحشر عنده عناصر شبم عند استدعاء دالة `احشر_شبم`.
                    </div>

                    <h5 id="Spp-astMgr-getVariableDomain">هات_نطاق_المتغير (getVariableDomain)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.هات_نطاق_المتغير (
    عنصر: سند[الـقلب.أسـاسيات.كـائن_بهوية]
): صـحيح
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.getVariableDomain(element: ref[Core.Basic.TiObject]) => Int;
</pre>
                      ترجع هذه الدالة قيمة توضح النطاق الذي عُرف فيه المتغير المعطى للدالة. الناتج واحد هذه القيم:
<pre class="code" dir=rtl style="text-align:right;">
  عرف نـطاق_التعريف: {
      عرف _دالة_:  0؛ // المتغير معرَّف داخل دالة كمتغير محلي.
      عرف _كائن_:  1؛ // المتغير عضو في كائن.
      عرف _عمومي_: 2؛ // المتغير عمومي أو متغير مشترك داخل دالة.
  }
</pre>
<pre class="code" dir=ltr style="text-align:left;">
  def DefinitionDomain: {
      def FUNCTION: 0; // Var is a function local variable.
      def OBJECT:   1; // Var is a class member.
      def GLOBAL:   2; // Var is a global or shared variable.
  }
</pre>
                    </div>

                    <h5 id="Spp-astMgr-traceType">تتبع_الصنف (traceType)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.تتبع_الصنف (عنصر: سند[الـقلب.أسـاسيات.كـائن_بهوية]): سند[نـبم.شـبم.صـنف]
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.traceType(element: ref[Core.Basic.TiObject]) => ref[Spp.Ast.Type];
</pre>
                      تتبع هذه الدالة الصنف المشار إليه بعنصر ش.ب.م المعطى وترجع ذلك الصنف.
                    </div>

                    <h5 id="Spp-astMgr-computeResultType">استنبط_صنف_الناتج (computeResultType)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.استنبط_صنف_الناتج (
    عنصر: سند[الـقلب.أسـاسيات.كـائن_بهوية]،
    ناتج: سند[سند[الـقلب.أسـاسيات.كـائن_بهوية]]،
    الناتج_قيمة: سند[ثـنائي]
): سند[ثـنائي]
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.computeResultType(
    element: ref[Core.Basic.TiObject],
    result: ref[ref[Core.Basic.TiObject]],
    resultIsValue: ref[Bool]
) => Bool;
</pre>
                      تستنبط هذه الدالة الناتج من التركيب المعطى وترجعه. الناتج قد يكون صنفًا وقد يكون أي تعريف آخر مثل
                      وحدة أو صنف. المعطى الأخير يخبرك إن كان الناتج قيمة (مثلاً متغير من الصنف المعطى) أم الصنف
                      نفسه (أي يخبرك فيما لو كان التركيب معرفا لصنف أم معرفًا لمتغير من ذلك الصنف).
                    </div>

                    <h5 id="Spp-astMgr-traceType">كرر_شبم (cloneAst)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.كرر_شبم (
    عنصر: سند[الـقلب.أسـاسيات.كـائن_بهوية]
): مـتم.سـندنا[الـقلب.أسـاسيات.كـائن_بهوية]؛
عملية هذا.كرر_شبم (
    عنصر: سند[الـقلب.أسـاسيات.كـائن_بهوية]،
    عنصر_موقع_الشفرة_المصدرية: سند[الـقلب.أسـاسيات.كـائن_بهوية]
): مـتم.سـندنا[الـقلب.أسـاسيات.كـائن_بهوية]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.cloneAst(element: ref[Core.Basic.TiObject]): Srl.SrdRef[Core.Basic.TiObject] {
    return this.cloneAst(element, nullRef[Core.Basic.TiObject]);
}
handler this.cloneAst(
    element: ref[Core.Basic.TiObject], sourceLocationNode: ref[Core.Basic.TiObject]
): Srl.SrdRef[Core.Basic.TiObject];
</pre>
                      تنسخ هذه الدالة شجرة الكائنات المعطاة. النسخة الثانية من هذه الدالة تتيح لك إضافة موقع في الشفرة
                      المصدرية إلى مكدس مواقع الشفرة المصدرية المرتبطة بالشجرة المولدة. المعطى الثاني في النسخة الثانية
                      ليس موقع الشفرة المصدرية المراد إضافته إلى المكدس وإنما عنصر ش.ب.م المراد أخذ الموقع منه.
                    </div>

                    <h5 id="Spp-astMgr-traceType">أدرج_بيانات (dumpData)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.أدرج_بيانات (عنصر: سند[الـقلب.أسـاسيات.كـائن_بهوية])؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.dumpData(obj: ref[Core.Basic.TiObject]);
</pre>
                      تطبع شجرة البيانات المعطاة في الطرفية بصيغة نصية.
                    </div>

                    <h5 id="Spp-astMgr-traceType">هات_صنف_السند_ل (getReferenceTypeFor)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.هات_صنف_السند_ل (
    صنف_شبم: سند[الـقلب.أسـاسيات.كـائن_بهوية]
): سند[نـبم.شـبم.صـنف_سند]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.getReferenceTypeFor(
    astType: ref[Core.Basic.TiObject]
): ref[Spp.Ast.ReferenceType];
</pre>
                      ترجع صنف السند للصنف المعطى.
                    </div>

                    <h5 id="Spp-astMgr-traceType">حاول_جلب_صنف_المحتوى_العميق (tryGetDeepReferenceContentType)</h5>
                    <div>
<pre class="code" dir=rtl style="text-align:right;">
عملية هذا.حاول_جلب_صنف_المحتوى_العميق (
    صنف_شبم: سند[نـبم.شـبم.صـنف]
): سند[نـبم.شـبم.صـنف]؛
</pre>
<pre class="code" dir=ltr style="text-align:left;">
handler this.tryGetDeepReferenceContentType(
    astType: ref[Spp.Ast.Type]
): ref[Spp.Ast.Type];
</pre>
                      ترجع صنف المحتوى للصنف المعطى. إن كان الصنف المعطى سندا فإن الدالة ترجع المحتوى الذي يشير إليه
                      ذلك السند، وإلا فإنها ترجع الصنف نفسه. إن كان الصنف المعطى سندا لسند فإن الدالة تستمر بالبحث
                      عن المحتوى بشكل تعاودي (recursive) حتى تصل إلى صنف غير سند فترجعه.
                    </div>

                  </div>

                  <h4 id="Spp-ast">أصناف شجرة البنية المجردة (AST)</h4>
                  <div>
                    <h5 id="Spp-typesAstTypes">الأصناف</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">نـبم.شـبم (Spp.Ast)</span>.<br>
                      <ul class="subsections">
                        <li>
                          <span class="inlinecode">صـنف (Type)</span><br>
                          مُشتق من <span class="inlinecode">عـقدة (Node)</span>.<br>
                          الجذر لكل الأصناف في لغة الأسس.
                        </li>
                        <li>
                          <span class="inlinecode">صـنف_بيانات (DataType)</span><br>
                          مُشتق من <span class="inlinecode">صـنف</span>.<br>
                          الجذر لكل أصناف البيانات.
                        </li>
                        <li>
                          <span class="inlinecode">صـنف_صحيح (IntegerType)</span><br>
                          مُشتق من <span class="inlinecode">صـنف_بيانات</span>.<br>
                        </li>
                        <li>
                          <span class="inlinecode">صـنف_عائم (FloatType)</span><br>
                          مُشتق من <span class="inlinecode">صـنف_بيانات</span>.<br>
                        </li>
                        <li>
                          <span class="inlinecode">صـنف_مصفوفة (ArrayType)</span><br>
                          مُشتق من <span class="inlinecode">صـنف_بيانات</span>.<br>
                        </li>
                        <li>
                          <span class="inlinecode">صـنف_مؤشر (PointerType)</span><br>
                          مُشتق من <span class="inlinecode">صـنف_بيانات</span>.<br>
                        </li>
                        <li>
                          <span class="inlinecode">صـنف_سند (ReferenceType)</span><br>
                          مُشتق من <span class="inlinecode">صـنف_بيانات</span>.<br>
                        </li>
                        <li>
                          <span class="inlinecode">صـنف_عدم (VoidType)</span><br>
                          مُشتق من <span class="inlinecode">صـنف_بيانات</span>.<br>
                        </li>
                        <li>
                          <span class="inlinecode">صـنف_مستخدم (UserType)</span><br>
                          مُشتق من <span class="inlinecode">صـنف_بيانات</span>.<br>
                        </li>
                        <li>
                          <span class="inlinecode">صـنف_دالة (FunctionType)</span><br>
                          مُشتق من <span class="inlinecode">صـنف</span>.<br>
                        </li>
                      </ul>
                    </div>

                    <h5 id="Spp-opsAstTypes">مؤثرات</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">نـبم.شـبم (Spp.Ast)</span>.<br>
                      مُشتق من <span class="inlinecode">عـقدة</span>.<br>
                      <ul class="subsections">
                        <li>
                          <span class="inlinecode">مـؤثر_إشارة_لشبم (AstRefOp)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_تمثيل (CastOp)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_تهيئة (InitOp)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_إتلاف (TerminateOp)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_التالي (NextArgOp)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_تتبع (DerefOp)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_تعطيل_التتبع (NoDerefOp)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_محتوى (ContentOp)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_مؤشر (PointerOp)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_حجم (SizeOp)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_صنف (TypeOp)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـؤثر_استخدم_في (UseInOp)</span><br>
                        </li>
                      </ul>
                    </div>

                    <h5 id="Spp-stmtAstTypes">عبارات</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">نـبم.شـبم (Spp.Ast)</span>.<br>
                      مُشتق من <span class="inlinecode">عـقدة</span>.<br>
                      <ul class="subsections">
                        <li>
                          <span class="inlinecode">عـبارة_إذا (IfStatement)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">عـبارة_بينما (WhileStatement)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">عـبارة_لكل (ForStatement)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">عـبارة_أكمل (ContinueStatement)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">عـبارة_اقطع (BreakStatement)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">عـبارة_ارجع (ReturnStatement)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">عـبارة_تمهيد (PreprocessStatement)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">عـبارة_ترجمة_قبلية (PreGenTransformStatement)</span><br>
                        </li>
                      </ul>
                    </div>

                    <h5 id="Spp-otherAstTypes">أخرى</h5>
                    <div>
                      معرف داخل الوحدة <span class="inlinecode">نـبم.شـبم (Spp.Ast)</span>.<br>
                      مُشتق من <span class="inlinecode">عـقدة</span>.<br>
                      <ul class="subsections">
                        <li>
                          <span class="inlinecode">قـالب (Template)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">تـعريف_معطى_قالب (TemplateVarDef)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـتن (Block)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">دالـة (Function)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـاكرو (Macro)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">وحـدة (Module)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">مـتغير (Variable)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">رزمـة_معطيات (ArgPack)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">إيـعاز_شبم_حرفي (AstLiteralCommand)</span><br>
                        </li>
                        <li>
                          <span class="inlinecode">إشـارة_لهذا_الصنف (ThisTypeRef)</span><br>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>

                <!-- ********************************************************************** -->
                <br>
                <h3 id="astManipulation">معالجة شجرة البنية المجردة</h3>
                <hr>
                <div>
                  قابلية برامج الأسس على قراءة وإنشاء شجرة البنية المجردة أثناء التنفيذ تمكن المبرمج من تطوير اللغة من
                  داخل برنامجه بإضافة قواعد جديدة لترجمة الشفرة المصدرية. في المثال التالي نعرف ماكرو يترجم التركيب
                  المعطى إلى سلسلة محارف تحتوي عبارة الشرط، مع استبدال المتغيرات بقيمها الحقيقية أثناء التنفيذ.
<pre class="samplecode" dir=rtl style="text-align:right;">
  اشمل "مـتم/طـرفية"؛
  اشمل "مـتم/سندات"؛
  اشمل "مـتم/نـظام"؛
  اشمل "الـقلب/بـيانات"؛
  اشمل "مـتم/نـص"؛
  اشمل "مـتم/تـطبيق"؛
  اشمل "نـبم"؛

  استخدم مـتم؛
  استخدم الـقلب.أسـاسيات؛
  استخدم الـقلب.بـيانات؛
  استخدم الـقلب.بـيانات.شـبم؛
  عرف سـندنا_لكائن_بهوية: لقب سـندنا[الـقلب.أسـاسيات.كـائن_بهوية]؛

  دالة أنشئ_حيثما (كائن: سند[كـائن_بهوية]): سـندنا_لكائن_بهوية {
      عرف نتيجة: سـندنا_لكائن_بهوية؛
      إذا كائن~مؤشر == 0 {
          نـظام.فشل(1، "أنشئ_حيثما: الكائن معدوم.\ج")؛
      }

      إذا أمشتق_من[كائن، مـؤثر_مقارنة] {
          عرف ربط: سند[ربـط](هات_وسيط[كائن، ربـط])؛
          عرف حاوية_تطبيق: سند[احـتواء_تطبيقي](هات_وسيط[كائن، احـتواء_تطبيقي])؛
          إذا !نـبم.مدير_شبم.أنشئ_شبم(
              شبم { نـص("{{اسم}}") + نـص(" {{مؤثر}} '") + القيمة + نـص("'") }،
              تـطبيق[نـص، سند[كـائن_بهوية]]()
                  .حدد(نـص("اسم")، حاوية_تطبيق.هات_عنصرا("first"))
                  .حدد(نـص("مؤثر")، ربط.هات_عضوا("type"))
                  .حدد(نـص("القيمة")، حاوية_تطبيق.هات_عنصرا("second"))،
              نتيجة
          ) {
              نـظام.فشل(1، "أنشئ_حيثما/مـؤثر_مقارنة: خطأ\ج")؛
          }
      } وإلا إذا أمشتق_من[كائن، مـؤثر_منطقي] {
          عرف ربط: سند[ربـط](هات_وسيط[كائن، ربـط])؛
          عرف حاوية_تطبيق: سند[احـتواء_تطبيقي](هات_وسيط[كائن، احـتواء_تطبيقي])؛
          عرف مؤثر: نـص_بهوية؛
          إذا مثل_سند[ربط.هات_عضوا("type")، نـص_بهوية].القيمة == "and" مؤثر = "و" وإلا مؤثر = "أو"؛
          إذا !نـبم.مدير_شبم.أنشئ_شبم(
              شبم { (شرط1) + نـص(" {{مؤثر}} ") + (شرط2) }،
              تـطبيق[نـص، سند[كـائن_بهوية]]()
                  .حدد(نـص("شرط1")، أنشئ_حيثما(حاوية_تطبيق.هات_عنصرا("first")).كائن)
                  .حدد(نـص("مؤثر")، مؤثر)
                  .حدد(نـص("شرط2")، أنشئ_حيثما(حاوية_تطبيق.هات_عنصرا("second")).كائن)،
              نتيجة
          ) {
              نـظام.فشل(1، "أنشئ_حيثما/مـؤثر_منطقي: خطأ\ج")؛
          }
      } وإلا إذا أمشتق_من[كائن، قـوس] {
          عرف حاوية_تطبيق: سند[احـتواء_تطبيقي](هات_وسيط[كائن، احـتواء_تطبيقي])؛
          إذا !نـبم.مدير_شبم.أنشئ_شبم(
              شبم { نـص("(") + (شرط) + نـص(")") }،
              تـطبيق[نـص، سند[كـائن_بهوية]]()
                  .حدد(نـص("شرط")، أنشئ_حيثما(حاوية_تطبيق.هات_عنصرا("operand")).كائن)،
              نتيجة
          ) {
              نـظام.فشل(1، "أنشئ_حيثما/قـوس: خطأ\ج")؛
          }
      } وإلا {
          إذا !نـبم.مدير_شبم.أنشئ_شبم(
              كائن،
              تـطبيق[نـص، سند[كـائن_بهوية]]()،
              نتيجة
          ) {
              نـظام.فشل(1، "فشل بناء الشرط.\ج")؛
          }
      }
      أرجع نتيجة؛
  }

  ماكرو حيثما [شرط] {
      تمهيد {
          إذا !نـبم.مدير_شبم.احشر_شبم(
              أنشئ_حيثما(شبم شرط).كائن
          ) {
              نـظام.فشل(1، "فشل حشر الشرط.\ج")؛
          }
      }
  }

  دالة اختبر {
      عرف الاسم_الأول: نـص("محمد")؛
      عرف الوظيفة: نـص("مهندس")؛
      عرف حيثما: نـص = حيثما[الاسم == الاسم_الأول و (الوظيفة == الوظيفة أو الوظيفة == "محامي")]؛
      طـرفية.اطبع("%s\ج"، حيثما.صوان)؛
      // نتيجة التنفيذ: الاسم == 'محمد' و (الوظيفة == 'مهندس' أو الوظيفة == 'محامي')
  }
  اختبر()؛
</pre>
<pre class="samplecode" dir=ltr>
  import "Srl/Console";
  import "Srl/refs";
  import "Srl/System";
  import "Core/Data";
  import "Spp";

  use Srl;
  use Core.Basic;
  use Core.Data;
  use Core.Data.Ast;
  def TioSrdRef: alias SrdRef[Core.Basic.TiObject];

  func generateWhere (obj: ref[TiObject]): TioSrdRef {
      def result: TioSrdRef;
      if obj~ptr == 0 {
          System.fail(1, "generateWhere: obj is null.\n");
      }

      if isDerivedFrom[obj, ComparisonOperator] {
          def binding: ref[Binding](getInterface[obj, Binding]);
          def mapContaining: ref[MapContaining](getInterface[obj, MapContaining]);
          if !Spp.astMgr.buildAst(
              ast { String("{{name}}") + String(" {{op}} '") + val  + String("'") },
              Map[String, ref[TiObject]]()
                  .set(String("name"), mapContaining.getElement("first"))
                  .set(String("op"), binding.getMember("type"))
                  .set(String("val"), mapContaining.getElement("second")),
              result
          ) {
              System.fail(1, "generateWhere/ComparisonOperator: error\n");
          }
      } else if isDerivedFrom[obj, LogOperator] {
          def binding: ref[Binding](getInterface[obj, Binding]);
          def mapContaining: ref[MapContaining](getInterface[obj, MapContaining]);
          if !Spp.astMgr.buildAst(
              ast { (cond1) + String(" {{op}} ") + (cond2) },
              Map[String, ref[TiObject]]()
                  .set(String("cond1"), generateWhere(mapContaining.getElement("first")).obj)
                  .set(String("op"), binding.getMember("type"))
                  .set(String("cond2"), generateWhere(mapContaining.getElement("second")).obj),
              result
          ) {
              System.fail(1, "generateWhere/LogOperator: error\n");
          }
      } else if isDerivedFrom[obj, Bracket] {
          def mapContaining: ref[MapContaining](getInterface[obj, MapContaining]);
          if !Spp.astMgr.buildAst(
              ast { String("(") + (cond) + String(")") },
              Map[String, ref[TiObject]]()
                  .set(String("cond"), generateWhere(mapContaining.getElement("operand")).obj),
              result
          ) {
              System.fail(1, "generateWhere/Bracket: error\n");
          }
      } else {
          if !Spp.astMgr.buildAst(
              obj,
              Map[String, ref[TiObject]](),
              result
          ) {
              System.fail(1, "Failed to build condition.\n");
          }
      }
      return result;
  }

  macro where [condition] {
      preprocess {
          if !Spp.astMgr.insertAst(
              generateWhere(ast condition).obj
          ) {
              System.fail(1, "Failed to insert condition.\n");
          }
      }
  }

  func test {
      def firstName: String("Mohammed");
      def position: String("Engineer");
      def query: String = where[name == firstName && (pos == position || pos == "Lawyer")];
      Console.print("%s\n", query.buf);
      // Execution output: name == 'Mohammed' && (pos == 'Engineer' || pos == 'Lawyer')
  }
  test();
</pre>
                </div>
              </div>
        </div>
        <!--content-separator-->
        <footer class="footer">
            <hr>
            <div class="container-fluid">
                <div class="row">
                    <div class="col-sm-8 pull-left1">
                        <ul class="nav nav-pills.nav">
                            <li><strong>جميع الحقوق محفوظة لشركة الأسس للبرمجيات 2022م \ 1444هـ.</strong></li>
                        </ul>
                    </div>
                </div>
            </div>
        </footer>
    </div>
    <script src="Resources/highlight.pack.js"></script>
    <script src="Resources/index.js"></script>

</body>

</html>
